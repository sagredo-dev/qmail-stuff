This patch can be used to create qmail-dk, qmail-dkim.
qmail-dk is based on Russ Nelson's patch:
http//:www.qmail.org/qmail-1.03-dk-0.54.patch
qmail-dkim uses hacked libdkim libraries from libdkim project
at http://libdkim.sourceforge.net/
The hacked libraries have been included in this patch


#fetch libdomainkeys from http://sourceforge.net/projects/domainkeys/
tar xfz libdomainkeys-0.69.tar.gz
cd libdomainkeys-0.69
echo "-lresolv" > dns.lib
make
cp libdomainkeys.a ..
cd ..
tar xfz /path/to/netqmail-1.06.tar.gz
patch -p0 < this-patch-file
cd netqmail-1.06
make
cp qmail-dk qmail-dkim /var/qmail/bin/

Then to use it you have to set some environment variables in the
programs that (ultimately) invoke qmail-queue.  If you are running
netqmail-1.06, or otherwise have the qmailqueue patch installed, you
can invoke it like this:

65.172.240.33-62:allow,RELAYCLIENT="",DKSIGN="/etc/domainkeys/dog",QMAILQUEUE="bin/qmail-dk"
192.203.178.:allow,DKVERIFY="DEGIJKfh",QMAILQUEUE="bin/qmail-dk"


diff -Naur netqmail-1.06.org/alloc.c netqmail-1.06/alloc.c
--- netqmail-1.06.org/alloc.c	1998-06-15 16:23:16.000000000 +0530
+++ netqmail-1.06/alloc.c	2018-04-03 17:28:43.650318276 +0530
@@ -1,6 +1,6 @@
 #include "alloc.h"
 #include "error.h"
-extern char *malloc();
+extern void *malloc();
 extern void free();
 
 #define ALIGNMENT 16 /* XXX: assuming that this alignment is enough */
diff -Naur netqmail-1.06.org/auto-int8.c netqmail-1.06/auto-int8.c
--- netqmail-1.06.org/auto-int8.c	1998-06-15 16:23:16.000000000 +0530
+++ netqmail-1.06/auto-int8.c	2018-04-03 17:28:43.651318296 +0530
@@ -7,7 +7,7 @@
 char buf1[256];
 substdio ss1 = SUBSTDIO_FDBUF(write,1,buf1,sizeof(buf1));
 
-void puts(s)
+void my_puts(s)
 char *s;
 {
   if (substdio_puts(&ss1,s) == -1) _exit(111);
@@ -30,11 +30,11 @@
   scan_8long(value,&num);
   strnum[fmt_ulong(strnum,num)] = 0;
 
-  puts("int ");
-  puts(name);
-  puts(" = ");
-  puts(strnum);
-  puts(";\n");
+  my_puts("int ");
+  my_puts(name);
+  my_puts(" = ");
+  my_puts(strnum);
+  my_puts(";\n");
   if (substdio_flush(&ss1) == -1) _exit(111);
   _exit(0);
 }
diff -Naur netqmail-1.06.org/auto-int.c netqmail-1.06/auto-int.c
--- netqmail-1.06.org/auto-int.c	1998-06-15 16:23:16.000000000 +0530
+++ netqmail-1.06/auto-int.c	2018-04-03 17:28:43.652318316 +0530
@@ -7,7 +7,7 @@
 char buf1[256];
 substdio ss1 = SUBSTDIO_FDBUF(write,1,buf1,sizeof(buf1));
 
-void puts(s)
+void my_puts(s)
 char *s;
 {
   if (substdio_puts(&ss1,s) == -1) _exit(111);
@@ -30,11 +30,11 @@
   scan_ulong(value,&num);
   strnum[fmt_ulong(strnum,num)] = 0;
 
-  puts("int ");
-  puts(name);
-  puts(" = ");
-  puts(strnum);
-  puts(";\n");
+  my_puts("int ");
+  my_puts(name);
+  my_puts(" = ");
+  my_puts(strnum);
+  my_puts(";\n");
   if (substdio_flush(&ss1) == -1) _exit(111);
   _exit(0);
 }
diff -Naur netqmail-1.06.org/auto-str.c netqmail-1.06/auto-str.c
--- netqmail-1.06.org/auto-str.c	1998-06-15 16:23:16.000000000 +0530
+++ netqmail-1.06/auto-str.c	2018-04-03 17:28:43.653318336 +0530
@@ -5,7 +5,7 @@
 char buf1[256];
 substdio ss1 = SUBSTDIO_FDBUF(write,1,buf1,sizeof(buf1));
 
-void puts(s)
+void my_puts(s)
 char *s;
 {
   if (substdio_puts(&ss1,s) == -1) _exit(111);
@@ -25,20 +25,20 @@
   value = argv[2];
   if (!value) _exit(100);
 
-  puts("char ");
-  puts(name);
-  puts("[] = \"\\\n");
+  my_puts("char ");
+  my_puts(name);
+  my_puts("[] = \"\\\n");
 
   while (ch = *value++) {
-    puts("\\");
+    my_puts("\\");
     octal[3] = 0;
     octal[2] = '0' + (ch & 7); ch >>= 3;
     octal[1] = '0' + (ch & 7); ch >>= 3;
     octal[0] = '0' + (ch & 7);
-    puts(octal);
+    my_puts(octal);
   }
 
-  puts("\\\n\";\n");
+  my_puts("\\\n\";\n");
   if (substdio_flush(&ss1) == -1) _exit(111);
   _exit(0);
 }
diff -Naur netqmail-1.06.org/base64.h netqmail-1.06/base64.h
--- netqmail-1.06.org/base64.h	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/base64.h	2018-04-03 17:28:43.654318357 +0530
@@ -0,0 +1,14 @@
+/*
+ * $Log: base64.h,v $
+ * Revision 1.3  2004-06-18 22:55:43+05:30  Cprogrammer
+ * added RCS log
+ *
+ */
+#ifndef BASE64_H
+#define BASE64_H
+#include "stralloc.h"
+
+extern int b64decode(const unsigned char *, int, stralloc *);
+extern int b64encode(stralloc *, stralloc *);
+
+#endif
diff -Naur netqmail-1.06.org/base64sub.c netqmail-1.06/base64sub.c
--- netqmail-1.06.org/base64sub.c	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/base64sub.c	2018-04-03 17:28:43.654318357 +0530
@@ -0,0 +1,170 @@
+/*
+ * $Log: base64sub.c,v $
+ * Revision 1.6  2010-03-03 09:33:16+05:30  Cprogrammer
+ * renamed base64 to base64sub
+ *
+ * Revision 1.5  2004-10-22 20:18:37+05:30  Cprogrammer
+ * added RCS id
+ *
+ * Revision 1.4  2004-09-19 14:36:11+05:30  Cprogrammer
+ * corrected number of bytes in stralloc variable 'out'
+ *
+ * Revision 1.3  2004-07-30 17:36:47+05:30  Cprogrammer
+ * fixed bugs in b64decode()
+ *
+ * Revision 1.2  2004-07-17 21:16:27+05:30  Cprogrammer
+ * added RCS log
+ *
+ */
+#include "base64.h"
+#include "stralloc.h"
+#include "substdio.h"
+#include "str.h"
+
+static char    *b64alpha = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
+#define B64PAD '='
+
+/*
+ * returns 0 ok, 1 illegal, -1 problem 
+ */
+
+int
+b64decode(in, l, out)
+	const unsigned char *in;
+	int             l;
+	stralloc       *out;		/*- not null terminated */
+{
+	int             p = 0;
+	int             n;
+	unsigned int    x;
+	int             i, j;
+	char           *s;
+	unsigned char   b[3];
+
+	if (l == 0)
+	{
+		if (!stralloc_copys(out, ""))
+			return -1;
+		return 0;
+	}
+	while (in[l - 1] == B64PAD)
+	{
+		p++;
+		l--;
+	}
+	n = (l + p) / 4;
+	out->len = (n * 3) - p;
+	if (!stralloc_ready(out, out->len))
+		return -1;
+	s = out->s;
+	for (i = 0; i < n - 1; i++)
+	{
+		x = 0;
+		for (j = 0; j < 4; j++)
+		{
+			if (in[j] >= 'A' && in[j] <= 'Z')
+				x = (x << 6) + (unsigned int) (in[j] - 'A' + 0);
+			else
+			if (in[j] >= 'a' && in[j] <= 'z')
+				x = (x << 6) + (unsigned int) (in[j] - 'a' + 26);
+			else
+			if (in[j] >= '0' && in[j] <= '9')
+				x = (x << 6) + (unsigned int) (in[j] - '0' + 52);
+			else
+			if (in[j] == '+')
+				x = (x << 6) + 62;
+			else
+			if (in[j] == '/')
+				x = (x << 6) + 63;
+			else
+			if (in[j] == '=')
+				x = (x << 6);
+		}
+		s[2] = (unsigned char) (x & 255);
+		x >>= 8;
+		s[1] = (unsigned char) (x & 255);
+		x >>= 8;
+		s[0] = (unsigned char) (x & 255);
+		x >>= 8;
+		s += 3;
+		in += 4;
+	}
+	x = 0;
+	for (j = 0; j < 4; j++)
+	{
+		if (in[j] >= 'A' && in[j] <= 'Z')
+			x = (x << 6) + (unsigned int) (in[j] - 'A' + 0);
+		else
+		if (in[j] >= 'a' && in[j] <= 'z')
+			x = (x << 6) + (unsigned int) (in[j] - 'a' + 26);
+		else
+		if (in[j] >= '0' && in[j] <= '9')
+			x = (x << 6) + (unsigned int) (in[j] - '0' + 52);
+		else
+		if (in[j] == '+')
+			x = (x << 6) + 62;
+		else
+		if (in[j] == '/')
+			x = (x << 6) + 63;
+		else
+		if (in[j] == '=')
+			x = (x << 6);
+	}
+	b[2] = (unsigned char) (x & 255);
+	x >>= 8;
+	b[1] = (unsigned char) (x & 255);
+	x >>= 8;
+	b[0] = (unsigned char) (x & 255);
+	x >>= 8;
+	for (i = 0; i < 3 - p; i++)
+		s[i] = b[i];
+	out->len = (n * 3) - p;
+	return 0;
+}
+
+int
+b64encode(in, out)
+	stralloc       *in;
+	stralloc       *out;		/*- not null terminated */
+{
+	unsigned char   a, b, c;
+	int             i;
+	char           *s;
+
+	if (in->len == 0)
+	{
+		if (!stralloc_copys(out, ""))
+			return -1;
+		return 0;
+	}
+	if (!stralloc_ready(out, in->len / 3 * 4 + 4))
+		return -1;
+	s = out->s;
+	for (i = 0; i < in->len; i += 3)
+	{
+		a = in->s[i];
+		b = i + 1 < in->len ? in->s[i + 1] : 0;
+		c = i + 2 < in->len ? in->s[i + 2] : 0;
+		*s++ = b64alpha[a >> 2];
+		*s++ = b64alpha[((a & 3) << 4) | (b >> 4)];
+		if (i + 1 >= in->len)
+			*s++ = B64PAD;
+		else
+			*s++ = b64alpha[((b & 15) << 2) | (c >> 6)];
+
+		if (i + 2 >= in->len)
+			*s++ = B64PAD;
+		else
+			*s++ = b64alpha[c & 63];
+	}
+	out->len = s - out->s;
+	return 0;
+}
+
+void
+getversion_base64sub_c()
+{
+	static char    *x = "$Id: base64sub.c,v 1.6 2010-03-03 09:33:16+05:30 Cprogrammer Stab mbhangui $";
+
+	x++;
+}
diff -Naur netqmail-1.06.org/caldate.h netqmail-1.06/caldate.h
--- netqmail-1.06.org/caldate.h	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/caldate.h	2018-04-03 17:28:43.655318377 +0530
@@ -0,0 +1,24 @@
+/*
+ * $Log: caldate.h,v $
+ * Revision 1.3  2004-10-09 23:20:20+05:30  Cprogrammer
+ * added function prototypes
+ *
+ * Revision 1.2  2004-06-18 22:57:44+05:30  Cprogrammer
+ * added RCS log
+ *
+ */
+#ifndef CALDATE_H
+#define CALDATE_H
+
+struct caldate
+{
+	long            year;
+	int             month;
+	int             day;
+};
+
+void            caldate_frommjd(struct caldate *, long, int *, int *);
+long            caldate_mjd(struct caldate *);
+unsigned int    caldate_fmt(char *, struct caldate *);
+
+#endif
diff -Naur netqmail-1.06.org/caltime.h netqmail-1.06/caltime.h
--- netqmail-1.06.org/caltime.h	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/caltime.h	2018-04-03 17:28:43.655318377 +0530
@@ -0,0 +1,30 @@
+/*
+ * $Log: caltime.h,v $
+ * Revision 1.3  2004-10-09 23:20:26+05:30  Cprogrammer
+ * added function prototypes
+ *
+ * Revision 1.2  2004-06-18 22:57:47+05:30  Cprogrammer
+ * added RCS log
+ *
+ */
+#ifndef CALTIME_H
+#define CALTIME_H
+
+#include "caldate.h"
+#include "tai.h"
+
+struct caltime
+{
+	struct caldate  date;
+	int             hour;
+	int             minute;
+	int             second;
+	long            offset;
+};
+
+void            caltime_tai(struct caltime *, struct tai *);
+void            caltime_utc(struct caltime *, struct tai *, int *, int *);
+
+unsigned int    caltime_fmt(char *, struct caltime *);
+
+#endif
diff -Naur netqmail-1.06.org/case_startb.c netqmail-1.06/case_startb.c
--- netqmail-1.06.org/case_startb.c	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/case_startb.c	2018-04-03 17:28:43.656318397 +0530
@@ -0,0 +1,49 @@
+/*
+ * $Log: case_startb.c,v $
+ * Revision 1.3  2004-10-22 20:23:18+05:30  Cprogrammer
+ * added RCS id
+ *
+ * Revision 1.2  2004-07-17 21:17:13+05:30  Cprogrammer
+ * added RCS log
+ *
+ */
+#include "case.h"
+
+int
+case_startb(s, len, t)
+	register char  *s;
+	unsigned int    len;
+	register char  *t;
+{
+	register unsigned char x;
+	register unsigned char y;
+
+	for (;;)
+	{
+		y = *t++ - 'A';
+		if (y <= 'Z' - 'A')
+			y += 'a';
+		else
+			y += 'A';
+		if (!y)
+			return 1;
+		if (!len)
+			return 0;
+		--len;
+		x = *s++ - 'A';
+		if (x <= 'Z' - 'A')
+			x += 'a';
+		else
+			x += 'A';
+		if (x != y)
+			return 0;
+	}
+}
+
+void
+getversion_case_startb_c()
+{
+	static char    *x = "$Id: case_startb.c,v 1.3 2004-10-22 20:23:18+05:30 Cprogrammer Stab mbhangui $";
+
+	x++;
+}
diff -Naur netqmail-1.06.org/conf-cc netqmail-1.06/conf-cc
--- netqmail-1.06.org/conf-cc	1998-06-15 16:23:16.000000000 +0530
+++ netqmail-1.06/conf-cc	2018-04-03 17:28:43.656318397 +0530
@@ -1,3 +1,3 @@
-cc -O2
+cc -O2 -g
 
 This will be used to compile .c files.
diff -Naur netqmail-1.06.org/conf-domainkeys netqmail-1.06/conf-domainkeys
--- netqmail-1.06.org/conf-domainkeys	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/conf-domainkeys	2018-04-03 17:28:43.657318417 +0530
@@ -0,0 +1 @@
+-DDOMAIN_KEYS
diff -Naur netqmail-1.06.org/config.h netqmail-1.06/config.h
--- netqmail-1.06.org/config.h	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/config.h	2018-04-03 17:28:43.657318417 +0530
@@ -0,0 +1,10 @@
+/* config.h.  Generated from config.h.in by configure.  */
+/* config.h.in.  Generated from configure.in by autoheader.  */
+
+/* Define to 1 if you have the <arpa/nameser.h> header file. */
+
+/* Define to 1 if you have the <dlfcn.h> header file. */
+
+/* HAVE_EVP_SHA256 */
+#define HAVE_EVP_SHA256 1
+
diff -Naur netqmail-1.06.org/conf-ld netqmail-1.06/conf-ld
--- netqmail-1.06.org/conf-ld	1998-06-15 16:23:16.000000000 +0530
+++ netqmail-1.06/conf-ld	2018-04-03 17:28:43.658318437 +0530
@@ -1,3 +1,3 @@
-cc -s
+cc -g
 
 This will be used to link .o files into an executable.
diff -Naur netqmail-1.06.org/control.c netqmail-1.06/control.c
--- netqmail-1.06.org/control.c	1998-06-15 16:23:16.000000000 +0530
+++ netqmail-1.06/control.c	2018-04-03 17:28:43.658318437 +0530
@@ -85,6 +85,82 @@
  return 1;
 }
 
+int
+control_readulong(i, fn)
+	unsigned long  *i;
+	char           *fn;
+{
+	unsigned long   u;
+
+	switch (control_readline(&line, fn))
+	{
+	case 0:
+		return 0;
+	case -1:
+		return -1;
+	}
+	if (!stralloc_0(&line))
+		return -1;
+	if (!scan_ulong(line.s, &u))
+		return 0;
+	*i = u;
+	return 1;
+}
+
+/*
+ * read entire file in variable sa
+ * without any interpretation (e.g. comments)
+ * To be used in case a file contains '#' character
+ * in the first column (which control_readfile() will
+ * skip
+ */
+int
+control_readnativefile(sa, fn, mode)
+	stralloc       *sa;
+	char           *fn;
+	int             mode;
+{
+	substdio        ss;
+	int             fd, match;
+
+	if (!stralloc_copys(sa, ""))
+		return -1;
+	if ((fd = open_read(fn)) == -1)
+	{
+		if (errno == error_noent)
+			return(0);
+		return -1;
+	}
+	substdio_fdbuf(&ss, read, fd, inbuf, sizeof(inbuf));
+	for (;;)
+	{
+		if (getln(&ss, &line, &match, '\n') == -1)
+			break;
+		if (!match && !line.len)
+		{
+			close(fd);
+			return 1;
+		}
+		if (mode) /* for qmail-dk */
+		{
+			striptrailingwhitespace(&line);
+			if (!stralloc_0(&line))
+				break;
+			if (line.s[0] && !stralloc_cat(sa, &line))
+				break;
+		} else
+		if (!stralloc_cat(sa, &line))
+			break;
+		if (!match)
+		{
+			close(fd);
+			return 1;
+		}
+	}
+	close(fd);
+	return -1;
+}
+
 int control_readfile(sa,fn,flagme)
 stralloc *sa;
 char *fn;
diff -Naur netqmail-1.06.org/control.h netqmail-1.06/control.h
--- netqmail-1.06.org/control.h	1998-06-15 16:23:16.000000000 +0530
+++ netqmail-1.06/control.h	2018-04-03 17:28:43.659318457 +0530
@@ -3,8 +3,10 @@
 
 extern int control_init();
 extern int control_readline();
+extern int control_readulong();
 extern int control_rldef();
 extern int control_readint();
+extern int control_readnativefile();
 extern int control_readfile();
 
 #endif
diff -Naur netqmail-1.06.org/dk-filter.9 netqmail-1.06/dk-filter.9
--- netqmail-1.06.org/dk-filter.9	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/dk-filter.9	2018-04-03 17:28:43.659318457 +0530
@@ -0,0 +1,102 @@
+.TH dk-filter 8
+.SH NAME
+dk-filter \- sign/verify using DK/DKIM (SSP/ADSP optionally) and deliver a mail message for delivery
+.SH SYNOPSIS
+.B FILTERARGS=QMAILHOME/bin/dk-filter
+.SH DESCRIPTION
+.B dk-filter
+is a qfilter which can be set as a filter for
+.BR spawn-filter(8) .
+The filter can be set either as
+.B FILTERARGS
+or in the control file
+.BR filterargs .
+
+.B dk-filter
+supports DK/DKIM signing and verification and can optionally use
+.B Sender Signing Practice (SSP)
+or
+.B Author Domain Signing Practice.
+It uses the libdkim and OpenSSL libraries.  To sign a message, set the
+.B DKIMSIGN
+or
+.B DKSIGIN
+environment variables to the pathname of the private key that will be
+used to sign the message. If there is a % character in the environment
+variable, it is removed and replaced by the domain name in the From: header.
+If, after substituting the %, that file does not exist, QMAILHOME/control/domainkeys/%/default
+will be used as the key. If again, after substituting the % sign, the file does not exist,
+QMAILHOME/control/domainkeys/default will be used as the key.
+After all substitutions, if the key file does not exist, the message will not be signed.
+If there is no % and the file does not exist, the message will be rejected with error 35.
+The selector (s=) will be taken from the basename of the file.
+The private key should be created by 
+.BR dknewkey(8) .
+
+You can set various DK options in getopt style, by setting the environment variable DKSIGNOPTIONS
+ b <advice_length>    Length of Advice
+ c <canonicalization> simple, nofws
+ s <privkeyfile>
+ h                    show headers included
+ r                    Skip Duplicate Headers
+.EX
+ DKSIGNOPTIONS="-h -r -c nofws"
+ sets the h= tag, skips duplicate headers and sets nofws canonicalization
+.EE
+
+You can set various DKIM options in getopt style, by setting the environment variable DKIMSIGNOPTIONS
+
+ b <standard>         1 - allman, 2 - ietf or 3 - both
+ c <canonicalization> r for relaxed [DEFAULT], s - simple,
+                      t relaxed/simple, u - simple/relaxed
+ l                    include body length tag
+ q                    include query method tag;
+ t                    include a timestamp tag
+ h
+ i <identity>         the identity, if not provided it will not be included
+ x <expire_time>      the expire time in seconds since epoch
+                      ( DEFAULT = current time + 604800)
+                      if set to - then it will not be included
+ z <hash>             1 for sha1, 2 for sha256, 3 for both
+ s <privkeyfile>
+ y <selector>
+
+.EX
+ DKIMSIGNOPTIONS="-b 1 -c r -q"
+ sets allman standard, with relaxed canonicalization and include query method tag
+.EE
+
+.B dk-filter
+uses the domain found in the Sender: header to set the domain tag. If not it uses the From: header. You can override this by
+setting 
+.B DKIMDOMAIN
+environment variable.
+.B DKIMDOMAIN
+can be set to an email address or a domain (without the at sign).
+To verify a message, set the
+.B DKIMVERIFY
+or
+.B DKVERIFY
+environment variables
+.B dk-filter
+always inserts the 
+.B DKIM-Status
+or
+.B DomainKey-Status
+header, so that messages can be
+rejected later at delivery time, or in the mail reader. In that case you may set
+.B DKIMVERIFY
+or
+.B DKVERIFY
+to an empty string.
+.B dk-filter
+does not use any signing practice byd default. You can override this by setting the SIGN_PRACTICE to ssp or adsp (lowercase).
+
+.SH "EXIT CODES"
+0 for success, non-zero failure
+
+.SH "SEE ALSO"
+dknewkey(8),
+dktest(8),
+dkim(8),
+spawn-filter(8)
diff -Naur netqmail-1.06.org/dk-filter.sh netqmail-1.06/dk-filter.sh
--- netqmail-1.06.org/dk-filter.sh	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/dk-filter.sh	2018-04-03 17:28:43.659318457 +0530
@@ -0,0 +1,315 @@
+#
+# $Log: dk-filter.sh,v $
+# Revision 1.14  2011-02-10 22:47:01+05:30  Cprogrammer
+# fixed exit code of dk-filter when doing verification
+#
+# Revision 1.13  2011-02-08 22:02:29+05:30  Cprogrammer
+# use sender domain when replacing '%' in private key
+#
+# Revision 1.12  2010-05-04 08:37:42+05:30  Cprogrammer
+# do DK signing before DKIM signing to prevent DK_SYNTAX error
+#
+# Revision 1.11  2009-12-10 19:25:13+05:30  Cprogrammer
+# added RCS id
+#
+# Revision 1.10  2009-12-10 16:41:14+05:30  Cprogrammer
+# continue of message gives DK_SYNTAX_ERR
+#
+# Revision 1.9  2009-05-04 10:30:32+05:30  Cprogrammer
+# fixed argument expected error
+#
+# Revision 1.8  2009-04-21 20:42:44+05:30  Cprogrammer
+# added check for dktest, dkim executables
+#
+# Revision 1.7  2009-04-20 10:06:58+05:30  Cprogrammer
+# added DKSIGNOPTS
+#
+# Revision 1.6  2009-04-19 13:38:24+05:30  Cprogrammer
+# added full set of dkim options
+# replaced indimail/bin/echo with echo 1>&2
+#
+# Revision 1.5  2009-04-06 16:37:50+05:30  Cprogrammer
+# added SIGN_PRACTICE
+# use ietf standard insted of allman so that Yahoo verification does not fail
+#
+# Revision 1.4  2009-04-03 14:39:00+05:30  Cprogrammer
+# added return status
+#
+# Revision 1.3  2009-04-03 08:55:29+05:30  Cprogrammer
+# print error messages to stderr
+#
+# Revision 1.2  2009-04-02 20:36:25+05:30  Cprogrammer
+# added -h option to dktest
+# added -x - option to dkim
+#
+# Revision 1.1  2009-04-02 14:52:27+05:30  Cprogrammer
+# Initial revision
+#
+# $Id: dk-filter.sh,v 1.14 2011-02-10 22:47:01+05:30 Cprogrammer Stab mbhangui $
+#
+if [ -z "$QMAILREMOTE" -a -z "$QMAILLOCAL" ]; then
+	echo "dk-filter should be run by spawn-filter" 1>&2
+	exit 1
+fi
+dksign=0
+dkimsign=0
+dkverify=0
+dkimverify=0
+if [ -z "$DKSIGN" -a -z "$DKVERIFY" ] ; then
+	DKSIGN=QMAILHOME/control/domainkeys/%/default
+	dksign=2
+fi
+if [ -z "$DKIMSIGN" -a -z "$DKIMVERIFY" ] ; then
+	DKIMSIGN=QMAILHOME/control/domainkeys/%/default
+	dkimsign=2
+fi
+if [ ! -z "$DKSIGN" ] ; then
+	if [ ! -f QMAILHOME/bin/dktest ] ; then
+		echo "QMAILHOME/bin/dktest: No such file or directory" 1>&2
+		exit 1
+	fi
+	percent_found=0
+	echo $DKSIGN|grep "%" >/dev/null 2>&1
+	if [ $? -eq 0 ] ; then
+		percent_found=1
+	fi
+	if [ ! " $_SENDER" = " " ] ; then
+		# replace '%' in filename with domain
+		domain=`echo $_SENDER | cut -d@ -f2`
+		dkkeyfn=`echo $DKSIGN | sed s{%{$domain{g`
+	else
+		dkkeyfn=$DKSIGN
+	fi
+	if [ $dksign -eq 2 -a ! -f $dkkeyfn ] ; then
+		dkkeyfn=QMAILHOME/control/domainkeys/default
+	fi
+	if [ -f $dkkeyfn ] ; then
+		dksign=1
+	else
+		dksign=0
+	fi
+	if [ $dksign -eq 0 -a $percent_found -ne 1 ] ; then
+		exit 32
+	fi
+	dkselector=`basename $dkkeyfn`
+fi
+if [ ! -z "$DKIMSIGN" ] ; then
+	if [ ! -f QMAILHOME/bin/dkim ] ; then
+		echo "QMAILHOME/bin/dkim: No such file or directory" 1>&2
+		exit 1
+	fi
+	percent_found=0
+	echo $DKIMSIGN|grep "%" >/dev/null 2>&1
+	if [ $? -eq 0 ] ; then
+		percent_found=1
+	fi
+	if [ ! " $_SENDER" = " " ] ; then
+		# replace '%' in filename with domain
+		domain=`echo $_SENDER | cut -d@ -f2`
+		dkimkeyfn=`echo $DKIMSIGN | sed s{%{$domain{g`
+	else
+		dkimkeyfn=$DKIMSIGN
+	fi
+	if [ $dkimsign -eq 2 -a ! -f $dkimkeyfn ] ; then
+		dkimkeyfn=QMAILHOME/control/domainkeys/default
+	fi
+	if [ -f $dkimkeyfn ] ; then
+		dkimsign=1
+	else
+		dkimsign=0
+	fi
+	if [ $dkimsign -eq 0 -a $percent_found -ne 1 ] ; then
+		exit 32
+	fi
+	dkimselector=`basename $dkimkeyfn`
+fi
+if [ ! -z "$DKVERIFY" ] ; then
+	if [ ! -f QMAILHOME/bin/dktest ] ; then
+		echo "QMAILHOME/bin/dktest: No such file or directory" 1>&2
+		exit 1
+	fi
+	dkverify=1
+fi
+if [ ! -z "$DKIMVERIFY" ] ; then
+	if [ ! -f QMAILHOME/bin/dkim ] ; then
+		echo "QMAILHOME/bin/dkim: No such file or directory" 1>&2
+		exit 1
+	fi
+	dkimverify=1
+fi
+cat > /tmp/dk.$$
+if [ $dkimsign -eq 1 ] ; then
+	# DKIMSIGNOPTIONS="-z 1 -b 2 -x - -y $dkimselector -s $dkimkeyfn"
+	set -- `getopt lqthb:c:d:i:x:z:y:s: $DKIMSIGNOPTIONS`
+	bopt=0
+	xopt=0
+	zopt=0
+	yopt=0
+	sopt=0
+	dkimopts="QMAILHOME/bin/dkim"
+	while [ $1 != -- ]
+	do
+		case $1 in
+		-l)
+		dkimopts="$dkimopts -l"
+		;;
+		-q)
+		dkimopts="$dkimopts -q"
+		;;
+		-t)
+		dkimopts="$dkimopts -t"
+		;;
+		-h)
+		dkimopts="$dkimopts -h"
+		;;
+
+		-b)
+		bopt=1
+		dkimopts="$dkimopts -b $2"
+		shift
+		;;
+
+		-c)
+		dkimopts="$dkimopts -c $2"
+		shift
+		;;
+
+		-i)
+		dkimopts="$dkimopts -i $2"
+		shift
+		;;
+
+		-x)
+		xopt=1
+		dkimopts="$dkimopts -x $2"
+		shift
+		;;
+
+		-z)
+		zopt=1
+		dkimopts="$dkimopts -z $2"
+		shift
+		;;
+
+		-y)
+		yopt=1
+		dkimopts="$dkimopts -y $2"
+		shift
+		;;
+
+		-s)
+		sopt=1
+		dkimopts="$dkimopts -s $2"
+		shift
+		;;
+		esac
+		shift   # next flag
+	done
+	if [ $zopt -eq 0 ] ; then
+		dkimopts="$dkimopts -z 1"
+	fi
+	if [ $bopt -eq 0 ] ; then
+		dkimopts="$dkimopts -b 2"
+	fi
+	if [ $xopt -eq 0 ] ; then
+		dkimopts="$dkimopts -x -"
+	fi
+	if [ $yopt -eq 0 ] ; then
+		dkimopts="$dkimopts -y $dkimselector"
+	fi
+	if [ $sopt -eq 0 ] ; then
+		dkimopts="$dkimopts -s $dkimkeyfn"
+	fi
+	exec 0</tmp/dk.$$
+	eval $dkimopts
+	if [ $? -ne 0 ] ; then
+		/bin/rm -f /tmp/dk.$$
+		exit 1
+	fi
+fi
+if [ $dksign -eq 1 ] ; then
+	#dktest: [-f] [-b advice_length] [-c nofws|simple] [-v|-s selector] [-h] [-t#] [-r] [-T][-d dnsrecord]
+	# DKSIGNOPTIONS="-z 1 -b 2 -x - -y $dkimselector -s $dkimkeyfn"
+	set -- `getopt hrb:c:s: $DKSIGNOPTIONS`
+	dkopts="QMAILHOME/bin/dktest"
+	sopt=0
+	while [ $1 != -- ]
+	do
+		case $1 in
+		-h)
+		dkopts="$dkopts -h"
+		;;
+		-r)
+		dkopts="$dkopts -r"
+		;;
+
+		-b)
+		dkopts="$dkopts -b $2"
+		shift
+		;;
+
+		-c)
+		dkopts="$dkopts -c $2"
+		shift
+		;;
+
+		-s)
+		sopt=1
+		dkopts="$dkopts -s $2"
+		shift
+		;;
+		esac
+		shift   # next flag
+	done
+	if [ $sopt -eq 0 ] ; then
+		dkopts="$dkopts -s $dkkeyfn"
+	fi
+	exec 0</tmp/dk.$$
+	#QMAILHOME/bin/dktest -h -s $dkkeyfn
+	eval $dkopts
+	exit_val=$?
+	# allow error due to duplicate DomainKey-Header
+	if [ $exit_val -ne 0 -a $exit_val -ne 6 ] ; then
+		/bin/rm -f /tmp/dk.$$
+		exit $exit_val
+	fi
+fi
+if [ $dkimverify -eq 1 ] ; then
+	practice=$SIGN_PRACTICE
+	if [ " $practice" = " " ] ; then
+		practice=0
+	elif [ " $practice" = " ssp" ] ; then
+		practice=1
+	elif [ " $practice" = " adsp" ] ; then
+		practice=2
+	fi
+	exec 0</tmp/dk.$$
+	QMAILHOME/bin/dkim -p $practice -v
+	ret=$?
+	case $ret in
+		14)
+		/bin/rm -f /tmp/dk.$$
+		exit 100
+		;;
+		88)
+		/bin/rm -f /tmp/dk.$$
+		exit 111
+		;;
+	esac
+	if [ $ret -lt 0 ] ; then
+		/bin/rm -f /tmp/dk.$$
+		exit 1
+	fi
+fi
+if [ $dkverify -eq 1 ] ; then
+	exec 0</tmp/dk.$$
+	QMAILHOME/bin/dktest -v
+	if [ $? -ne 0 ] ; then
+		/bin/rm -f /tmp/dk.$$
+		exit 1
+	fi
+fi
+exec 0</tmp/dk.$$
+/bin/rm -f /tmp/dk.$$
+cat
+exit $?
diff -Naur netqmail-1.06.org/dkim.9 netqmail-1.06/dkim.9
--- netqmail-1.06.org/dkim.9	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/dkim.9	2018-04-03 17:28:43.659318457 +0530
@@ -0,0 +1,98 @@
+.TH dkim 8
+.SH NAME
+dkim \- exercise the domainkeys library
+.SH SYNOPSIS
+.B dkim
+.I opts
+
+.I opts
+is a series of getopt-style options.
+
+.SH DESCRIPTION
+.B dkim
+exercises the dkim library. Both signing and verification merely print out the DKIM header.
+They do not keep a copy of the input file. You will need to do something like this:
+
+.EX
+ (./dkim -s QMAILHOME/control/domainkeys/dog </tmp/testmsg; cat /tmp/testmsg)\
+ | ./dkim -v
+.EE
+
+.SH OPTIONS
+.TP
+-s \fIkey\fR
+.I key
+is a path to a file containing a PEM-format private key. The base name of
+the file is  used  as  the  selector. Reads the email message on stdin. Prints the
+.B DKIM-Signature
+header.
+
+.TP
+-v
+Verifies the email on stdin. Exits with a non-zero exit code and a message to
+stderr if there was a problem with the signature. Always prints a
+.B DKIM-Status:
+header to stdout. This option requires the \fBs\fR._domainkey.\fBd\fR txt record in
+dns (public key). Here \fBs\fR is the selector and \fBd\fR is the domain
+
+.EX
+DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
+d=gmail.com; s=gamma; h=DomainKey-Status:
+To:Subject:Message-Id:Date:From; bh=IarZI4AMTl/vy1jTbPphDcOl4YNS
+POk7Vn0tDdgkbV4=; b=VpIS6XNOLU2WWWlsYGeLB3wMbyFQwkg7F0hr7blu1W8f
+0RRtuyw9igFwY7q7FNaPVlfZ0cfLPh0mRrlExu4V7uQaTP8nnnHO2cAokYbncGS5
+ADU9NbAcpDh+E2YQwzCX
+.EE
+
+.TP
+-l
+include body length tag
+.TP
+-q
+include query method tag
+.TP
+-t
+include a timestamp tag
+.TP
+-f
+issue error if not all message's From headers are in signature
+.TP
+-h
+include Copied Headers
+.TP
+-p \fIssp\fR | \fIadsp\fR
+0 - disable practice (default), 1- SSP, or 2 - ADSP verification
+.TP
+-b \fIstandard\fR
+1 - allman, 2 - ietf or 3 - both
+.TP
+-c \fIcanonicalization\fR
+r for relaxed [DEFAULT], s - simple, t relaxed/simple, u - simple/relaxed
+-d \fIdomain\fR
+the domain tag, if not provided, determined from the sender/from header
+.TP
+-i \fIidentity\fR
+the identity, if not provided it will not be included
+.TP
+-x \fIexpire_time\fR
+the expire time in seconds since epoch ( DEFAULT = current time + 604800). If set to - then it will not be included
+.TP
+-z \fIhash\fR
+1 for sha1, 2 for sha256, 3 for both
+.TP
+-y \fIselector\fR
+the selector tag DEFAULT=private
+.TP
+-s \fIprivkeyfile\fR
+sign the message using the private key in privkeyfile
+.TP
+-H
+this help
+
+.SH "SEE ALSO"
+dktest(8),
+qmail-dk(8),
+qmail-dkim(8),
+dknewkey(8),
+rfc-4870(5),
+rfc-4871(5)
diff -Naur netqmail-1.06.org/dkimbase.cpp netqmail-1.06/dkimbase.cpp
--- netqmail-1.06.org/dkimbase.cpp	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/dkimbase.cpp	2018-04-03 17:28:43.660318478 +0530
@@ -0,0 +1,336 @@
+/*
+ * $Log: dkimbase.cpp,v $
+ * Revision 1.4  2017-09-05 10:58:26+05:30  Cprogrammer
+ * removed compiler warnings
+ *
+ * Revision 1.3  2009-03-26 15:10:32+05:30  Cprogrammer
+ * fixed indentation
+ *
+ * Revision 1.2  2009-03-25 08:37:27+05:30  Cprogrammer
+ * fixed indentation
+ *
+ * Revision 1.1  2009-03-21 08:43:08+05:30  Cprogrammer
+ * Initial revision
+ *
+ *
+ *  Copyright 2005 Alt-N Technologies, Ltd. 
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License"); 
+ *  you may not use this file except in compliance with the License. 
+ *  You may obtain a copy of the License at 
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0 
+ *
+ *  This code incorporates intellectual property owned by Yahoo! and licensed 
+ *  pursuant to the Yahoo! DomainKeys Patent License Agreement.
+ *
+ *  Unless required by applicable law or agreed to in writing, software 
+ *  distributed under the License is distributed on an "AS IS" BASIS, 
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ *  See the License for the specific language governing permissions and 
+ *  limitations under the License.
+ *
+ */
+
+#include "dkim.h"
+#include "dkimbase.h"
+#include <string.h>
+#include <algorithm>
+
+CDKIMBase::CDKIMBase()
+{
+	m_From = NULL;
+	m_Sender = NULL;
+	m_hTag = NULL;
+	m_hTagSize = 0;
+	m_hTagPos = 0;
+	m_Line = NULL;
+	m_LineSize = 0;
+	m_LinePos = 0;
+	m_InHeaders = true;
+}
+
+CDKIMBase::~CDKIMBase()
+{
+	Free(m_Line);
+	Free(m_From);
+	Free(m_Sender);
+	Free(m_hTag);
+}
+
+int
+CDKIMBase::Init(void)
+{
+	return DKIM_SUCCESS;
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// 
+// Alloc - allocate buffer
+//
+////////////////////////////////////////////////////////////////////////////////
+int CDKIMBase::Alloc(char *&szBuffer, int nRequiredSize)
+{
+	szBuffer = new char[nRequiredSize];
+
+	return (szBuffer == NULL) ? DKIM_OUT_OF_MEMORY : DKIM_SUCCESS;
+}
+
+
+////////////////////////////////////////////////////////////////////////////////
+// 
+// ReAlloc - extend buffer if necessary, leaving room for future expansion
+//
+////////////////////////////////////////////////////////////////////////////////
+int CDKIMBase::ReAlloc(char *&szBuffer, int &nBufferSize, int nRequiredSize)
+{
+	if (nRequiredSize > nBufferSize) {
+		char           *
+			newp;
+		int
+			nNewSize = nRequiredSize + BUFFER_ALLOC_INCREMENT;
+
+		if (Alloc(newp, nNewSize) == DKIM_SUCCESS) {
+			if (szBuffer != NULL && nBufferSize > 0) {
+				memcpy(newp, szBuffer, nBufferSize);
+				delete[]szBuffer;
+			}
+			szBuffer = newp;
+			nBufferSize = nNewSize;
+		} else {
+			return DKIM_OUT_OF_MEMORY;	// memory alloc error!
+		}
+	}
+	return DKIM_SUCCESS;
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// 
+// Process - split buffers into lines without any CRs or LFs at the end.
+//
+////////////////////////////////////////////////////////////////////////////////
+void CDKIMBase::Free(char *szBuffer)
+{
+	if (szBuffer)
+		delete[]szBuffer;
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// 
+// Process - split buffers into lines without any CRs or LFs at the end.
+//
+////////////////////////////////////////////////////////////////////////////////
+int CDKIMBase::Process(char *szBuffer, int nBufLength, bool bEOF)
+{
+	char           *p = szBuffer;
+	char           *e = szBuffer + nBufLength;
+
+	while (p < e) {
+		if (*p != '\n' && *p != '\r') {
+			if (m_LinePos >= m_LineSize) {
+				int nRet = ReAlloc(m_Line, m_LineSize, m_LinePos + 1);
+				if (nRet != DKIM_SUCCESS)
+							/*
+							 * How to distinguish between
+							 * DKIM_FINISHED_BODY & DKIM_OUT_OF_MEMORY
+							 */
+					return nRet;
+			}
+			m_Line[m_LinePos++] = *p;
+		} else {
+			if (*p == '\r' && p + 1 < e && *(p + 1) == '\n')
+				p++;
+			if (m_InHeaders) {
+			// process header line
+				if (m_LinePos == 0) {
+					m_InHeaders = false;
+					int Result = ProcessHeaders();
+					if (Result != DKIM_SUCCESS)
+						return Result;
+				} else {
+				// append the header to the headers list
+					if (m_Line[0] != ' ' && m_Line[0] != '\t') {
+						HeaderList.push_back(string(m_Line, m_LinePos));
+					} else {
+						if (!HeaderList.empty()) {
+							HeaderList.back().append("\r\n", 2).append(m_Line, m_LinePos);
+						} else {
+						// no header to append to...
+						}
+					}
+				}
+			} else {
+				// process body line
+				int Result = ProcessBody(m_Line, m_LinePos, bEOF);
+				if (Result != DKIM_SUCCESS) {
+					m_LinePos = 0;
+					return Result;
+				}
+			}
+			m_LinePos = 0;
+		}
+		p++;
+	}
+	return DKIM_SUCCESS;
+}
+
+
+////////////////////////////////////////////////////////////////////////////////
+// 
+// ProcessFinal - process leftovers if stopping before the body or mid-line
+//
+////////////////////////////////////////////////////////////////////////////////
+int CDKIMBase::ProcessFinal(void)
+{
+	if (m_LinePos > 0) {
+		Process((char *) "\r\n", 2, true);
+	}
+
+	if (m_InHeaders) {
+		m_InHeaders = false;
+		ProcessHeaders();
+		ProcessBody((char *) "", 0, true);
+	}
+
+	return DKIM_SUCCESS;
+}
+
+
+////////////////////////////////////////////////////////////////////////////////
+// 
+// ProcessHeaders - process the headers (to be implemented by derived class)
+//
+////////////////////////////////////////////////////////////////////////////////
+int CDKIMBase::ProcessHeaders()
+{
+	return DKIM_SUCCESS;
+}
+
+
+////////////////////////////////////////////////////////////////////////////////
+// 
+// ProcessBody - process body line (to be implemented by derived class)
+//
+////////////////////////////////////////////////////////////////////////////////
+int CDKIMBase::ProcessBody(char *szBuffer, int nBufLength, bool bEOF)
+{
+	return DKIM_SUCCESS;
+}
+
+
+////////////////////////////////////////////////////////////////////////////////
+// 
+// RemoveSWSP - remove streaming white space from buffer/string inline
+//
+////////////////////////////////////////////////////////////////////////////////
+
+struct isswsp {
+	bool
+	operator() (char ch) {
+		return (ch == ' ' || ch == '\t' || ch == '\r' || ch == '\n');
+	}
+};
+
+void CDKIMBase::RemoveSWSP(char *szBuffer)
+{
+	*remove_if(szBuffer, szBuffer + strlen(szBuffer), isswsp()) = '\0';
+}
+
+void CDKIMBase::RemoveSWSP(char *pBuffer, int &nBufLength)
+{
+	nBufLength = remove_if(pBuffer, pBuffer + nBufLength, isswsp()) - pBuffer;
+}
+
+void CDKIMBase::RemoveSWSP(string &sBuffer)
+{
+	sBuffer.erase(remove_if(sBuffer.begin(), sBuffer.end(), isswsp()), sBuffer.end());
+}
+
+
+//////////////////////////////////////////////////////////////////////////////////////////
+// 
+// CompressSWSP - compress streaming white space into single spaces from buffer/string inline
+//
+//////////////////////////////////////////////////////////////////////////////////////////
+
+void CDKIMBase::CompressSWSP(char *pBuffer, int &nBufLength)
+{
+	char           *pSrc = pBuffer;
+	char           *pDst = pBuffer;
+	char           *pEnd = pBuffer + nBufLength;
+
+	while (pSrc != pEnd) {
+		if (isswsp()(*pSrc)) {
+			do {
+				++pSrc;
+			} while (pSrc != pEnd && isswsp()(*pSrc));
+			if (pSrc == pEnd)
+				break;
+			*pDst++ = ' ';
+		}
+		*pDst++ = *pSrc++;
+	}
+	nBufLength = pDst - pBuffer;
+}
+
+void CDKIMBase::CompressSWSP(string &sBuffer)
+{
+	string::iterator iSrc = sBuffer.begin();
+	string::iterator iDst = sBuffer.begin();
+	string::iterator iEnd = sBuffer.end();
+
+	while (iSrc != iEnd) {
+		if (isswsp()(*iSrc)) {
+			do {
+				++iSrc;
+			} while (iSrc != iEnd && isswsp()(*iSrc));
+
+			if (iSrc == iEnd)
+				break;
+			*iDst++ = ' ';
+		}
+		*iDst++ = *iSrc++;
+	}
+	sBuffer.erase(iDst, iEnd);
+}
+
+//////////////////////////////////////////////////////////////////////////////////////////
+// 
+// RelaxHeader - relax a header field (lower case the name, remove swsp before and after :)
+//
+// modified 4/21/06 STB to remove white space before colon
+//
+//////////////////////////////////////////////////////////////////////////////////////////
+
+string CDKIMBase::RelaxHeader(const string &sHeader)
+{
+	string sTemp = sHeader;
+
+	CompressSWSP(sTemp);
+
+	int cpos = sTemp.find(':');
+	if (cpos == -1) {
+	// no colon?!
+	} else {
+	// lower case the header field name
+		for (int i = 0; i < cpos; i++) {
+			if (sTemp[i] >= 'A' && sTemp[i] <= 'Z')
+				sTemp[i] += 'a' - 'A';
+		}
+	// remove the space after the :
+		if ((unsigned int) (cpos + 1) < sTemp.length() && sTemp[cpos + 1] == ' ')
+			sTemp.erase(cpos + 1, 1);
+	// remove the space before the :
+		if (cpos > 0 && sTemp[cpos - 1] == ' ')
+			sTemp.erase(cpos - 1, 1);
+	}
+	return sTemp;
+}
+
+void
+getversion_dkimbase_cpp()
+{
+	static char    *x = (char *) "$Id: dkimbase.cpp,v 1.4 2017-09-05 10:58:26+05:30 Cprogrammer Exp mbhangui $";
+
+	x++;
+}
diff -Naur netqmail-1.06.org/dkimbase.h netqmail-1.06/dkimbase.h
--- netqmail-1.06.org/dkimbase.h	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/dkimbase.h	2018-04-03 17:28:43.660318478 +0530
@@ -0,0 +1,72 @@
+/*
+ * $Log: dkimbase.h,v $
+ * Revision 1.1  2009-03-21 08:50:18+05:30  Cprogrammer
+ * Initial revision
+ *
+ *
+ *  Copyright 2005 Alt-N Technologies, Ltd. 
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License"); 
+ *  you may not use this file except in compliance with the License. 
+ *  You may obtain a copy of the License at 
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0 
+ *
+ *  This code incorporates intellectual property owned by Yahoo! and licensed 
+ *  pursuant to the Yahoo! DomainKeys Patent License Agreement.
+ *
+ *  Unless required by applicable law or agreed to in writing, software 
+ *  distributed under the License is distributed on an "AS IS" BASIS, 
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ *  See the License for the specific language governing permissions and 
+ *  limitations under the License.
+ *
+ */
+
+#ifndef DKIMBASE_H
+#define DKIMBASE_H
+
+#include <openssl/evp.h>
+#include <openssl/pem.h>
+#include <openssl/err.h>
+
+#define BUFFER_ALLOC_INCREMENT	256
+
+#include <string>
+#include <list>
+
+using namespace std;
+class           CDKIMBase {
+public:
+
+	CDKIMBase();
+	~CDKIMBase();
+
+	int             Init(void);
+	int             Process(char *szBuffer, int nBufLength, bool bEOF);
+	int             ProcessFinal(void);
+	int             Alloc(char *&szBuffer, int nRequiredSize);
+	int             ReAlloc(char *&szBuffer, int &nBufferLength, int nRequiredSize);
+	void            Free(char *szBuffer);
+	static void     RemoveSWSP(char *szBuffer);
+	static void     RemoveSWSP(char *pBuffer, int &nBufLength);
+	static void     RemoveSWSP(string & sBuffer);
+	static void     CompressSWSP(char *pBuffer, int &nBufLength);
+	static void     CompressSWSP(string & sBuffer);
+	static string   RelaxHeader(const string & sHeader);
+	virtual int     ProcessHeaders(void);
+	virtual int     ProcessBody(char *szBuffer, int nBufLength, bool bEOF);
+
+protected:
+	char           *m_From;
+	char           *m_Sender;
+	char           *m_hTag;
+	int             m_hTagSize;
+	int             m_hTagPos;
+	char           *m_Line;
+	int             m_LineSize;
+	int             m_LinePos;
+	bool            m_InHeaders;
+	                list < string > HeaderList;
+};
+#endif	/*- DKIMBASE_H */
diff -Naur netqmail-1.06.org/dkim.c netqmail-1.06/dkim.c
--- netqmail-1.06.org/dkim.c	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/dkim.c	2018-08-25 18:14:26.530749295 +0530
@@ -0,0 +1,905 @@
+/*
+ * $Log: dkim.c,v $
+ * Revision 1.21  2018-08-08 23:57:02+05:30  Cprogrammer
+ * issue success if at lease one one good signature is found
+ *
+ * Revision 1.20  2018-05-22 10:03:26+05:30  Cprogrammer
+ * changed return type of writeHeader() to void
+ *
+ * Revision 1.19  2016-03-01 16:23:38+05:30  Cprogrammer
+ * added -S option to allow email with unsigned subject
+ *
+ * Revision 1.18  2016-02-01 10:53:32+05:30  Cprogrammer
+ * use basename of private key as the selector in absense of -y option
+ *
+ * Revision 1.17  2015-12-15 15:36:01+05:30  Cprogrammer
+ * added case 3 for 3rd party signature without SSP and ADSP
+ * increased buffer size for Apple mail with X-BrightMail-Tracker header issue
+ *
+ * Revision 1.16  2012-08-16 08:01:19+05:30  Cprogrammer
+ * do not skip X-Mailer headers
+ *
+ * Revision 1.15  2011-06-04 13:55:50+05:30  Cprogrammer
+ * set AllowUnsignedFromHeaders
+ *
+ * Revision 1.14  2011-06-04 09:36:36+05:30  Cprogrammer
+ * added AllowUnsignedFromHeaders option
+ *
+ * Revision 1.13  2011-02-07 22:05:23+05:30  Cprogrammer
+ * added case DKIM_3PS_SIGNATURE
+ *
+ * Revision 1.12  2010-05-04 14:00:13+05:30  Cprogrammer
+ * make option '-z' work on systems without SHA_256
+ *
+ * Revision 1.11  2009-04-20 08:35:45+05:30  Cprogrammer
+ * corrected usage()
+ *
+ * Revision 1.10  2009-04-15 21:30:32+05:30  Cprogrammer
+ * added DKIM-Signature to list of excluded headers
+ *
+ * Revision 1.9  2009-04-15 20:45:04+05:30  Cprogrammer
+ * corrected usage
+ *
+ * Revision 1.8  2009-04-05 19:04:44+05:30  Cprogrammer
+ * improved formating of usage
+ *
+ * Revision 1.7  2009-04-03 12:05:25+05:30  Cprogrammer
+ * minor changes on usage display
+ *
+ * Revision 1.6  2009-03-28 20:15:23+05:30  Cprogrammer
+ * invoke DKIMVerifyGetDetails()
+ *
+ * Revision 1.5  2009-03-27 20:43:48+05:30  Cprogrammer
+ * added HAVE_OPENSSL_EVP_H conditional
+ *
+ * Revision 1.4  2009-03-27 20:19:28+05:30  Cprogrammer
+ * added ADSP
+ *
+ * Revision 1.3  2009-03-26 15:10:53+05:30  Cprogrammer
+ * added ADSP
+ *
+ * Revision 1.2  2009-03-25 08:37:45+05:30  Cprogrammer
+ * added dkim_error
+ *
+ * Revision 1.1  2009-03-21 08:24:47+05:30  Cprogrammer
+ * Initial revision
+ *
+ *
+ * This code incorporates intellectual property owned by Yahoo! and licensed 
+ * pursuant to the Yahoo! DomainKeys Patent License Agreement.
+ *
+ * Unless required by applicable law or agreed to in writing, software 
+ * distributed under the License is distributed on an "AS IS" BASIS, 
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ * See the License for the specific language governing permissions and 
+ * limitations under the License.
+ */
+/*
+ * (cat /tmp/test.msg|./dkimtest -z 2 -b 1 -y private \
+ * -s /var/indimail/control/domainkeys/private ;cat /tmp/test.msg )|./dkimtest -v
+ */
+#ifndef __cplusplus
+#error A C++ compiler is required!
+#endif
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <stdio.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <unistd.h>
+#include <string.h>
+#include <time.h>
+#include <stdlib.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include "dkim.h"
+#include "dkimdns.h"
+
+#ifdef HAVE_OPENSSL_EVP_H
+#include <openssl/evp.h>
+#define DKIM_MALLOC(s)     OPENSSL_malloc(s)
+#define DKIM_MFREE(s)      OPENSSL_free(s); s = NULL;
+#else
+#define DKIM_MALLOC(s)     malloc(s)
+#define DKIM_MFREE(s)      free(s); s = NULL;
+#endif
+
+int DKIM_CALL
+SignThisHeader(const char *szHeader)
+{
+	if ((!strncasecmp(szHeader, "X-", 2) && strncasecmp(szHeader, "X-Mailer", 8))
+		|| !strncasecmp(szHeader, "Received:", 9)
+		|| !strncasecmp(szHeader, "DKIM-Signature:", 15)
+		|| !strncasecmp(szHeader, "Authentication-Results:", 23)
+		|| !strncasecmp(szHeader, "DomainKey-Signature", 19)
+		|| !strncasecmp(szHeader, "Return-Path:", 12)) 
+	{
+		return 0;
+	}
+	return 1;
+}
+
+char           *program;
+
+void
+usage()
+{
+#ifdef HAVE_EVP_SHA256
+	fprintf(stderr, "usage: %s [-lqthvH] [-p <0|1|2>] [-b <1|2|3>] [-c <r|s|t|u>]\n\t[-d domain] [-i you@domain] [-x expire_time] [-z hash] [-y selector] -s privkeyfile\n", program);
+#else
+	fprintf(stderr, "usage: %s [-lqthvH] [-p <0|1|2>] [-b <1|2|3>] [-c <r|s|t|u>]\n\t[-d domain] [-i you@domain] [-x expire_time] [-y selector] -s privkeyfile\n", program);
+#endif
+	fprintf(stderr, "l                    include body length tag\n");
+	fprintf(stderr, "q                    include query method tag\n");
+	fprintf(stderr, "t                    include a timestamp tag\n");
+	fprintf(stderr, "h                    include Copied Headers\n");
+	fprintf(stderr, "v                    verify the message\n");
+	fprintf(stderr, "p <ssp|adsp>         0 - disable practice (default), 1- SSP, or 2 - ADSP verification\n");
+	fprintf(stderr, "b <standard>         1 - allman, 2 - ietf or 3 - both\n");
+	fprintf(stderr, "c <canonicalization> r for relaxed [DEFAULT], s - simple, t relaxed/simple, u - simple/relaxed\n");
+	fprintf(stderr, "d <domain>           the domain tag, if not provided, determined from the sender/from header\n");
+	fprintf(stderr, "i <identity>         the identity, if not provided it will not be included\n");
+	fprintf(stderr, "x <expire_time>      the expire time in seconds since epoch ( DEFAULT = current time + 604800)\n");
+	fprintf(stderr, "                     if set to - then it will not be included\n");
+#ifdef HAVE_EVP_SHA256
+	fprintf(stderr, "z <hash>             1 for sha1, 2 for sha256, 3 for both\n");
+#endif
+	fprintf(stderr, "f                    0 = From headers not included in the signature are not allowed\n");
+	fprintf(stderr, "                     1 = allowed\n");
+	fprintf(stderr, "y <selector>         the selector tag DEFAULT=private\n");
+	fprintf(stderr, "s <privkeyfile>      sign the message using the private key in privkeyfile\n");
+	fprintf(stderr, "H                    this help\n");
+	exit(1);
+}
+
+unsigned int str_chr(char *s, int c)
+{
+	register char   ch;
+	register char  *t;
+
+	ch = c;
+	t = s;
+	for (;;)
+	{
+		if (!*t)
+			break;
+		if (*t == ch)
+			break;
+		++t;
+		if (!*t)
+			break;
+		if (*t == ch)
+			break;
+		++t;
+		if (!*t)
+			break;
+		if (*t == ch)
+			break;
+		++t;
+		if (!*t)
+			break;
+		if (*t == ch)
+			break;
+		++t;
+	}
+	return t - s;
+}
+
+void
+dkim_error(int e)
+{
+	switch (e)
+	{
+	case DKIM_OUT_OF_MEMORY:
+		fprintf(stderr, "memory allocation failed\n");
+		break;
+	case DKIM_INVALID_CONTEXT:
+		fprintf(stderr, "DKIMContext structure invalid for this operation\n");
+		break;
+	case DKIM_NO_SENDER:
+		fprintf(stderr, "Could not find From: or Sender: header in message\n");
+		break;
+	case DKIM_BAD_PRIVATE_KEY:
+		fprintf(stderr, "Could not parse private key\n");
+		break;
+	case DKIM_BUFFER_TOO_SMALL:
+		fprintf(stderr, "Buffer passed in is not large enough");
+		break;
+	}
+}
+
+/*
+ * Allows you to add the headers contain the results and DKIM ADSP
+ */
+void writeHeader(int ret, int resDKIMSSP, int resDKIMADSP, int useSSP, int useADSP )
+{
+	char           *dkimStatus, *sspStatus, *adspStatus;
+
+	dkimStatus = sspStatus = adspStatus = (char *) "";
+	switch (ret)
+	{
+	case DKIM_SUCCESS_BUT_EXTRA:/*- 4 signature result: signature verified but it did not include all of the body */
+		dkimStatus = (char *) "signature result: signature verified but it did not include all of the body";
+		break;
+	case DKIM_NEUTRAL:			/*- 3 verify result: no signatures verified but message is not suspicious */
+		dkimStatus = (char *) "verify result: no signatures verified but message is not suspicious";
+		break;
+	case DKIM_PARTIAL_SUCCESS:	/*- 2 verify result: at least one but not all signatures verified */
+		dkimStatus = (char *) "verify result: at least none but not all signatures verified";
+		break;
+	case DKIM_FINISHED_BODY:	/*- 1 process result: no more message body is needed */
+		dkimStatus = (char *) "process result: no more message body is needed";
+		break;
+	case DKIM_SUCCESS:
+		dkimStatus = (char *) "good        ";
+		break;
+	case DKIM_FAIL:
+		dkimStatus = (char *) "failed      ";
+		break;
+	case DKIM_BAD_SYNTAX:
+		dkimStatus = (char *) "signature error: DKIM-Signature could not parse or has bad tags/values";
+		break;
+	case DKIM_SIGNATURE_BAD:
+		dkimStatus = (char *) "signature error: RSA verify failed";
+		break;
+	case DKIM_SIGNATURE_BAD_BUT_TESTING:
+		dkimStatus = (char *) "signature error: RSA verify failed but testing";
+		break;
+	case DKIM_SIGNATURE_EXPIRED:
+		dkimStatus = (char *) "signature error: x= is old";
+		break;
+	case DKIM_SELECTOR_INVALID:
+		dkimStatus = (char *) "signature error: selector doesn't parse or contains invalid values";
+		break;
+	case DKIM_SELECTOR_GRANULARITY_MISMATCH:
+		dkimStatus = (char *) "signature error: selector g= doesn't match i=";
+		break;
+	case DKIM_SELECTOR_KEY_REVOKED:
+		dkimStatus = (char *) "signature error: selector p= empty";
+		break;
+	case DKIM_SELECTOR_DOMAIN_NAME_TOO_LONG:
+		dkimStatus = (char *) "signature error: selector domain name too long to request";
+		break;
+	case DKIM_SELECTOR_DNS_TEMP_FAILURE:
+		dkimStatus = (char *) "signature error: temporary dns failure requesting selector";
+		break;
+	case DKIM_SELECTOR_DNS_PERM_FAILURE:
+		dkimStatus = (char *) "signature error: permanent dns failure requesting selector";
+		break;
+	case DKIM_SELECTOR_PUBLIC_KEY_INVALID:
+		dkimStatus = (char *) "signature error: selector p= value invalid or wrong format";
+		break;
+	case DKIM_NO_SIGNATURES:
+		dkimStatus = (char *) "process error, no sigs";
+		break;
+	case DKIM_NO_VALID_SIGNATURES:
+		dkimStatus = (char *) "process error, no valid sigs";
+		break;
+	case DKIM_BODY_HASH_MISMATCH:
+		dkimStatus = (char *) "sigature verify error: message body does not hash to bh value";
+		break;
+	case DKIM_SELECTOR_ALGORITHM_MISMATCH:
+		dkimStatus = (char *) "signature error: selector h= doesn't match signature a=";
+		break;
+	case DKIM_STAT_INCOMPAT:
+		dkimStatus = (char *) "signature error: incompatible v=";
+		break;
+	default:
+		dkimStatus = (char *) "error";
+		break;
+	}
+	if (useSSP && resDKIMSSP != -1)
+	{
+		switch(resDKIMSSP)
+		{
+			case DKIM_SSP_ALL:
+				sspStatus = (char *) "all;";
+				break;
+			case DKIM_SSP_STRICT:
+				sspStatus = (char *) "strict;";
+				break;
+			case DKIM_SSP_SCOPE:
+				sspStatus = (char *) "out of scope;";
+				break;
+			case DKIM_SSP_TEMPFAIL:
+				sspStatus = (char *) "temporary failure;";
+				break;
+			case DKIM_SSP_UNKNOWN:
+			default:
+				sspStatus = (char *) "unknown;";
+				break;
+		}
+	}
+	if (useADSP && resDKIMADSP != -1)
+	{
+		switch(resDKIMADSP)
+		{
+			case DKIM_ADSP_ALL:
+				adspStatus = (char *) "all;";
+				break;
+			case DKIM_ADSP_DISCARDABLE:
+				adspStatus = (char *) "discardable;";
+				break;
+			case DKIM_ADSP_SCOPE:
+				adspStatus = (char *) "out of scope;";
+				break;
+			case DKIM_ADSP_TEMPFAIL:
+				adspStatus = (char *) "temporary failure;";
+				break;
+			case DKIM_ADSP_UNKNOWN:
+			default:
+				adspStatus = (char *) "unknown ;";
+				break;
+		}
+	}
+	printf("DKIM-Status: %s\n", dkimStatus);
+	if (useSSP && *sspStatus)
+		printf("X-DKIM-SSP: %s\n", sspStatus);
+	if (useADSP && *adspStatus)
+		printf("X-DKIM-ADSP: %s\n", adspStatus);
+}
+
+int
+ParseTagValues(char *list, char *letters[], char *values[])
+{
+	char           *tmp, *ptr, *key;
+	int             i;
+
+	/*- start with all args unset */
+	for (i = 0; letters[i]; i++)
+		values[i] = 0;
+	key = 0;
+	for(ptr = list;*ptr;)
+	{
+		if ((*ptr == ' ') || (*ptr == '\t') || (*ptr == '\r') || (*ptr == '\n')) /*- FWS */
+			*ptr++ = 0;
+		if (!key)
+			key = ptr;
+		if (*ptr == '=')
+		{
+			*ptr = 0;
+			for (i = 0;letters[i];i++)
+			{
+				if (!strcmp(letters[i], key))
+				{
+					ptr++;
+					for (;*ptr;)
+					{
+						if ((*ptr == ' ') || (*ptr == '\t') || (*ptr == '\r') || (*ptr == '\n'))
+						{
+							ptr++;
+							continue;
+						}
+						break;
+					}
+					values[i] = ptr;
+					for(;*ptr && *ptr != ';';ptr++);
+					tmp = ptr;
+					if (*ptr)
+						*ptr++ = 0;
+					for(;tmp != values[i];tmp--) /*- RFC 4871 3.2 */
+					{
+						if ((*tmp == ' ') || (*tmp == '\t') || (*tmp == '\r') || (*tmp == '\n'))
+						{
+							*tmp = 0;
+							continue;
+						}
+						break;
+					}
+					key = 0;
+					break;
+				}
+			}
+		} else
+			ptr++;
+	}
+	return (0);
+}
+
+int
+GetSSP(char *domain, int *bTesting)
+{
+	char           *query, *results;
+	char           *tags[] = { (char *) "dkim", (char *) "t", (char *) 0};
+	char           *values[2];
+	int             bIsParentSSP = 0, iSSP = DKIM_SSP_UNKNOWN;
+
+	*bTesting = 0;
+	if (!(query = (char *) DKIM_MALLOC(strlen("_ssp._domainkey.") + strlen(domain) + 1)))
+	{
+		fprintf(stderr, "malloc: %d: %s\n", strlen("_ssp._domainkey.") + strlen(domain) + 1,
+			strerror(errno));
+		exit(1);
+	}
+	sprintf(query, "_ssp._domainkey.%s", domain);
+	results = dns_text(query);
+	DKIM_MFREE(query);
+	if (!strcmp(results, "e=temp;"))
+	{
+		DKIM_MFREE(results);
+		return DKIM_SSP_TEMPFAIL;
+	} else
+	if (!strcmp(results, "e=perm;"))
+	{
+		DKIM_MFREE(results);
+		results = dns_text(domain);
+		if (!strcmp(results, "e=temp;"))
+		{
+			DKIM_MFREE(results);
+			return DKIM_SSP_TEMPFAIL;
+		} else
+		if (!strcmp(results, "e=perm;"))
+		{
+			DKIM_MFREE(results);
+			return DKIM_SSP_SCOPE;
+		}
+		bIsParentSSP = 1;
+	}
+	if (!ParseTagValues(results, tags, values))
+	{
+		DKIM_MFREE(results);
+		return DKIM_SSP_UNKNOWN;
+	}
+	DKIM_MFREE(results);
+	if (values[0] != NULL) {
+		if (strcasecmp(values[0], "all") == 0)
+			iSSP = DKIM_SSP_ALL;
+		else
+		if (strcasecmp(values[0], "strict") == 0)
+			iSSP = DKIM_SSP_STRICT;
+	}
+	// flags
+	if (values[1] != NULL) {
+		char           *s, *p;
+		for (p = values[1], s = values[1]; *p; p++)
+		{
+			if (*p == '|')
+				*p = 0;
+			else
+				continue;
+			if (!strcmp(s, "y"))
+				*bTesting = 1;
+			else
+			if (!strcmp(s, "s")) {
+				if (bIsParentSSP) {
+					/* 
+					 * this is a parent's SSP record that should not apply to subdomains
+					 * the message is non-suspicious
+					 */
+					*bTesting = 0;
+					return (DKIM_SSP_UNKNOWN);
+				}
+			}
+			s = p + 1;
+		}
+	}
+	return iSSP; /*- No ADSP Record */
+}
+
+int
+GetADSP(char *domain)
+{
+	char           *query, *results;
+	char           *tags[] = {(char *) "dkim", (char *) 0};
+	char           *values[1];
+
+	results = dns_text(domain);
+	if (!strcmp(results, "e=perm;"))
+	{
+		DKIM_MFREE(results);
+		return DKIM_ADSP_SCOPE;
+	} else
+	if (!strcmp(results, "e=temp;"))
+	{
+		DKIM_MFREE(results);
+		return DKIM_ADSP_TEMPFAIL;
+	}
+	if (!(query = (char *) DKIM_MALLOC(strlen((char *) "_adsp._domainkey.") + strlen(domain) + 1)))
+	{
+		fprintf(stderr, "malloc: %d: %s\n", strlen("_adsp._domainkey.") + strlen(domain) + 1,
+			strerror(errno));
+		exit(1);
+	}
+	sprintf(query, "_adsp._domainkey.%s", domain);
+	results = dns_text(query);
+	DKIM_MFREE(query);
+	if (!strcmp(results, "e=perm;"))
+	{
+		DKIM_MFREE(results);
+		return DKIM_ADSP_SCOPE;
+	} else
+	if (!strcmp(results, "e=temp;"))
+	{
+		DKIM_MFREE(results);
+		return DKIM_ADSP_TEMPFAIL;
+	}
+	if (!ParseTagValues(results, tags, values))
+	{
+		DKIM_MFREE(results);
+		return DKIM_ADSP_UNKNOWN;
+	}
+	DKIM_MFREE(results);
+	if (values[0] != NULL) {
+		if (strcasecmp(values[0], "all") == 0)
+			return (DKIM_ADSP_ALL);
+		else
+		if (strcasecmp(values[0], "discardable") == 0)
+			return (DKIM_ADSP_DISCARDABLE);
+	}
+	return DKIM_ADSP_UNKNOWN; /*- No ADSP Record */
+}
+
+int
+main(int argc, char **argv)
+{
+	char           *PrivKey, *PrivKeyFile = NULL, *pSig = NULL, *dkimverify;
+	int             i, ret, ch, nPrivKeyLen, PrivKeyFD, verbose = 0;
+	int             bSign = 1, nSigCount = 0, useSSP = 0, useADSP = 0, accept3ps = 0;
+	int             sCount = 0, sSize = 0, resDKIMSSP = -1, resDKIMADSP = -1;
+	int             nAllowUnsignedFromHeaders = 0;
+	int             nAllowUnsignedSubject = 1;
+	char            Buffer[4096], szPolicy[512];
+	time_t          t;
+	struct stat     statbuf;
+	DKIMContext     ctxt;
+	DKIMSignOptions opts = { 0 };
+	DKIMVerifyDetails *pDetails;
+	DKIMVerifyOptions vopts = { 0 };
+
+	if (!(program = strrchr(argv[0], '/')))
+		program = argv[0];
+	else
+		program++;
+	t = time(0);
+#ifdef HAVE_EVP_SHA256
+	opts.nHash = DKIM_HASH_SHA1_AND_256;
+#else
+	opts.nHash = DKIM_HASH_SHA1;
+#endif
+	opts.nCanon = DKIM_SIGN_RELAXED;
+	opts.nIncludeBodyLengthTag = 0;
+	opts.nIncludeQueryMethod = 0;
+	opts.nIncludeTimeStamp = 0;
+	opts.expireTime = t + 604800;	// expires in 1 week
+	opts.nIncludeCopiedHeaders = 0;
+	opts.nIncludeBodyHash = DKIM_BODYHASH_BOTH;
+	strcpy(opts.szRequiredHeaders, "NonExistent");
+	opts.pfnHeaderCallback = SignThisHeader;
+	while (1)
+	{
+		if ((ch = getopt(argc, argv, "lqtfhHSvVp:b:c:d:i:s:x:y:z:")) == -1)
+			break;
+		switch (ch)
+		{
+		case 'l': /*- body length tag */
+			opts.nIncludeBodyLengthTag = 1;
+			break;
+		case 'q': /*- query method tag */
+			opts.nIncludeQueryMethod = 1;
+			break;
+		case 'S':
+			nAllowUnsignedSubject = 0;
+			break;
+		case 'f':
+			nAllowUnsignedFromHeaders = 1;
+		case 't': /*- timestamp tag */
+			opts.nIncludeTimeStamp = 1;
+			break;
+		case 'h':
+			opts.nIncludeCopiedHeaders = 1;
+			break;
+		case 'H':
+			usage();
+			break;
+		case 'v': /*- verify */
+			bSign = 0;
+			break;
+		case 'V': /*- verbose */
+			verbose = 1;
+			break;
+		case 'p':
+			switch(*optarg)
+			{
+			case '1':
+				accept3ps = 1;
+				useSSP = 1;
+				useADSP = 0;
+				break;
+			case '2':
+				accept3ps = 1;
+				useSSP = 0;
+				useADSP = 1;
+				break;
+			case '3':
+				accept3ps = 1;
+				useSSP = 0;
+				useADSP = 0;
+				break;
+			case '0':
+				accept3ps = 0;
+				useSSP = 0;
+				useADSP = 0;
+				break;
+			default:
+				fprintf(stderr, "%s: unrecognized practice %c.\n", program, *optarg);
+				return (1);
+			}
+			break;
+		case 'b': /*- allman or ietf draft 1 or both */
+			switch (*optarg)
+			{
+			case '1':
+				opts.nIncludeBodyHash = DKIM_BODYHASH_ALLMAN_1;
+				break;
+			case '2':
+				opts.nIncludeBodyHash = DKIM_BODYHASH_IETF_1;
+				break;
+			case '3':
+				opts.nIncludeBodyHash = DKIM_BODYHASH_BOTH;
+				break;
+			default:
+				fprintf(stderr, "%s: unrecognized standard %c.\n", program, *optarg);
+				return (1);
+			}
+			break;
+		case 'c':
+			switch (*optarg)
+			{
+			case 'r':
+				opts.nCanon = DKIM_SIGN_RELAXED;
+				break;
+			case 's':
+				opts.nCanon = DKIM_SIGN_SIMPLE;
+				break;
+			case 't':
+				opts.nCanon = DKIM_SIGN_RELAXED_SIMPLE;
+				break;
+			case 'u':
+				opts.nCanon = DKIM_SIGN_SIMPLE_RELAXED;
+				break;
+			default:
+				fprintf(stderr, "%s: unrecognized canonicalization.\n", program);
+				return (1);
+			}
+			break;
+		case 'd':
+			strncpy(opts.szDomain, optarg, sizeof (opts.szDomain) - 1);
+			break;
+		case 'i':	/*- identity */
+			if (*optarg == '-')
+				opts.szIdentity[0] = '\0';
+			else
+				strncpy(opts.szIdentity, optarg, sizeof (opts.szIdentity) - 1);
+			break;
+		case 's': /*- sign */
+			bSign = 1;
+			PrivKeyFile = optarg;
+			break;
+		case 'x': /*- expire time */
+			if (*optarg == '-')
+				opts.expireTime = 0;
+			else
+				opts.expireTime = t + atoi(optarg);
+			break;
+		case 'y':
+			strncpy(opts.szSelector, optarg, sizeof (opts.szSelector) - 1);
+			break;
+		case 'z': /*- sign w/ sha1, sha256 or both */
+#ifdef HAVE_EVP_SHA256
+			switch (*optarg)
+			{
+			case '1':
+				opts.nHash = DKIM_HASH_SHA1;
+				break;
+			case '2':
+				opts.nHash = DKIM_HASH_SHA256;
+				break;
+			case '3':
+				opts.nHash = DKIM_HASH_SHA1_AND_256;
+				break;
+			default:
+				fprintf(stderr, "%s: unrecognized hash.\n", program);
+				return (1);
+			}
+#else
+			opts.nHash = DKIM_HASH_SHA1;
+#endif
+			break;
+		} /*- switch (ch) */
+	}
+	if (bSign) { /*- sign */
+		if (!PrivKeyFile)
+		{
+			fprintf(stderr, "Private Key not provided\n");
+			usage();
+			return (1);
+		}
+		if (!opts.szSelector[0]) {
+			if ((pSig = strrchr(PrivKeyFile, '/'))) {
+				pSig++;
+				strcpy(opts.szSelector, pSig);
+			} else
+				strcpy(opts.szSelector, "private");
+		}
+		if ((PrivKeyFD = open(PrivKeyFile, O_RDONLY)) == -1) {
+			fprintf(stderr, "%s: %s\n", PrivKeyFile, strerror(errno));
+			return (1);
+		}
+		if (fstat(PrivKeyFD, &statbuf) == -1)
+		{
+			fprintf(stderr, "fstat: %s: %s\n", PrivKeyFile, strerror(errno));
+			return (1);
+		}
+		if (!(PrivKey = (char *) DKIM_MALLOC(sizeof(char) * ((nPrivKeyLen = statbuf.st_size) + 1))))
+		{
+			fprintf(stderr, "malloc: %ld bytes: %s\n", statbuf.st_size + 1, strerror(errno));
+			return (1);
+		}
+		if (read(PrivKeyFD, PrivKey, nPrivKeyLen) != nPrivKeyLen)
+		{
+			fprintf(stderr, "%s: read: %s\n", strerror(errno), program);
+			return (1);
+		}
+		close(PrivKeyFD);
+		PrivKey[nPrivKeyLen] = '\0';
+		if (DKIMSignInit(&ctxt, &opts) != DKIM_SUCCESS)
+		{
+			fprintf(stderr, "DKIMSignInit: failed to initialize signature %s\n", PrivKeyFile);
+			return (1);
+		}
+		for (;;)
+		{
+			if ((ret = read(0, Buffer, sizeof(Buffer) - 1)) == -1)
+			{
+				fprintf(stderr, "read: %s\n", strerror(errno));
+				DKIMSignFree(&ctxt);
+				return (1);
+			} else
+			if (!ret)
+				break;
+			if (DKIMSignProcess(&ctxt, Buffer, ret) == DKIM_INVALID_CONTEXT)
+			{
+				fprintf(stderr, "DKIMSignProcess: DKIMContext structure invalid for this operation\n");
+				DKIMSignFree(&ctxt);
+				return (1);
+			}
+		}
+		if (DKIMSignGetSig2(&ctxt, PrivKey, &pSig) == DKIM_INVALID_CONTEXT)
+		{
+			fprintf(stderr, "DKIMSignProcess: DKIMContext structure invalid for this operation\n");
+			DKIMSignFree(&ctxt);
+			return (1);
+		}
+		if (pSig)
+		{
+			fwrite(pSig, 1, strlen(pSig), stdout);
+			fwrite("\n", 1, 1, stdout);
+		}
+		DKIMSignFree(&ctxt);
+		return 0;
+	} else { /*- verify */
+		if (useADSP)
+			vopts.nCheckPractices = useADSP;
+		else
+		if (useSSP)
+			vopts.nCheckPractices = useSSP;
+		else
+			vopts.nCheckPractices = 0;
+		vopts.nAccept3ps = accept3ps;
+		vopts.pfnSelectorCallback = NULL;	/*- SelectorCallback; */
+		vopts.nAllowUnsignedFromHeaders = nAllowUnsignedFromHeaders;
+		vopts.nSubjectRequired = nAllowUnsignedSubject;
+		DKIMVerifyInit(&ctxt, &vopts);		/*- this is always successful */
+		for (;;)
+		{
+			if ((i = read(0, Buffer, sizeof(Buffer) - 1)) == -1)
+			{
+				fprintf(stderr, "read: %s\n", strerror(errno));
+				DKIMVerifyFree(&ctxt);
+				return (1);
+			} else
+			if (!i)
+				break;
+			ret = DKIMVerifyProcess(&ctxt, Buffer, i);
+			dkim_error(ret);
+			if (ret > 0 && ret < DKIM_FINISHED_BODY)
+				ret = DKIM_FAIL;
+			if (ret)
+				break;
+		}
+		if (!ret)
+		{
+			ret = DKIMVerifyResults(&ctxt, &sCount, &sSize);
+			if (ret != DKIM_SUCCESS && ret != DKIM_3PS_SIGNATURE && ret != DKIM_NEUTRAL)
+				dkim_error(ret);
+			if ((ret = DKIMVerifyGetDetails(&ctxt, &nSigCount, &pDetails, szPolicy)) != DKIM_SUCCESS)
+				dkim_error(ret);
+			else {
+				for (ret = DKIM_FAIL, i = 0; i < nSigCount; i++) {
+					if (verbose)
+						printf("Signature # %02d: ", i + 1);
+					if (pDetails[i].nResult >= 0) {
+						ret = 0;
+						if (verbose)
+							printf("Success\n");
+						continue;
+					} else {
+						if (ret == DKIM_FAIL)
+							ret = pDetails[i].nResult;
+						if (verbose)
+							printf("Failure %d\n", pDetails[i].nResult);
+					}
+				}
+				if (!nSigCount)
+					ret = DKIM_NO_SIGNATURES;
+			}
+		} 
+		if (ret < 0 || ret == DKIM_3PS_SIGNATURE) {
+			if (useADSP)
+			{
+				char           *domain;
+	
+				if ((domain = DKIMVerifyGetDomain(&ctxt)))
+					resDKIMADSP = GetADSP(domain);
+				if (sCount > 0) {
+					if (resDKIMADSP == DKIM_ADSP_UNKNOWN || resDKIMADSP == DKIM_ADSP_ALL)
+						ret = (sCount == sSize ? DKIM_SUCCESS : DKIM_PARTIAL_SUCCESS);
+				} 
+				/* if the message should be signed, return fail */
+				if (resDKIMADSP == DKIM_ADSP_DISCARDABLE)
+					ret = DKIM_FAIL;
+				ret = DKIM_NEUTRAL;
+			} else
+			if (useSSP)
+			{
+				int             bTestingPractices = 0;
+				char           *domain;
+
+				if ((domain = DKIMVerifyGetDomain(&ctxt)))
+					resDKIMSSP = GetSSP(domain, &bTestingPractices);
+				if (sCount > 0) {
+					if ((resDKIMSSP == DKIM_SSP_UNKNOWN || resDKIMSSP == DKIM_SSP_ALL))
+						ret = (sCount == sSize ? DKIM_SUCCESS : DKIM_PARTIAL_SUCCESS);
+				}
+				// if the SSP is testing, return neutral
+				if (bTestingPractices)
+					return(DKIM_NEUTRAL);
+				/* if the message should be signed, return fail */
+				if (resDKIMSSP == DKIM_SSP_ALL || resDKIMSSP == DKIM_SSP_STRICT)
+					return(DKIM_FAIL);
+				ret = DKIM_NEUTRAL;
+			}
+		}
+		DKIMVerifyFree(&ctxt);
+		writeHeader(ret, resDKIMSSP, resDKIMADSP, useSSP, useADSP);
+		if ((dkimverify = getenv("DKIMVERIFY")))
+		{
+			if (ret < 0)
+			{
+				if (dkimverify[str_chr(dkimverify, 'F' - ret)])
+					ret = 14; /*- return permanent error */
+				if (dkimverify[str_chr(dkimverify, 'f' - ret)])
+					ret = 88; /*- return temporary error */
+			} else
+			{
+				if (dkimverify[str_chr(dkimverify, 'A' + ret)])
+					ret = 14; /*- return permanent error */
+				if (dkimverify[str_chr(dkimverify, 'a' + ret)])
+					ret = 88; /*- return temporary error */
+			}
+		}
+		return (ret);
+	}
+	/*- Not Reached */
+	_exit(0);
+}
+
+void
+getversion_dkim_c()
+{
+	static char    *x = (char *) "$Id: dkim.c,v 1.21 2018-08-08 23:57:02+05:30 Cprogrammer Exp mbhangui $";
+
+	x++;
+}
diff -Naur netqmail-1.06.org/dkimdns.cpp netqmail-1.06/dkimdns.cpp
--- netqmail-1.06.org/dkimdns.cpp	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/dkimdns.cpp	2019-05-21 22:29:59.635191948 +0530
@@ -0,0 +1,329 @@
+/*
+ * $Log: dns.cpp,v $
+ * Revision 1.10  2017-09-05 11:01:06+05:30  Cprogrammer
+ * removed unused variables
+ *
+ * Revision 1.9  2017-09-01 12:46:27+05:30  Cprogrammer
+ * fixed double free() of dnresult
+ *
+ * Revision 1.8  2017-08-09 22:06:33+05:30  Cprogrammer
+ * fixed resolve() function
+ *
+ * Revision 1.7  2017-05-16 12:40:23+05:30  Cprogrammer
+ * refactored dns_text() function
+ *
+ * Revision 1.6  2017-05-10 14:58:06+05:30  Cprogrammer
+ * increase responselen to 1024 for long text records
+ *
+ * Revision 1.5  2017-05-10 12:27:49+05:30  Cprogrammer
+ * use packetsize > 512 to avoid dkim failures for sites having long txt records (hotmail.com)
+ *
+ * Revision 1.4  2009-06-11 13:58:39+05:30  Cprogrammer
+ * port for DARWIN
+ *
+ * Revision 1.3  2009-03-27 19:22:45+05:30  Cprogrammer
+ * dns functions
+ *
+ */
+#include <netdb.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <sys/types.h>
+#include <netinet/in.h>
+#ifdef DARWIN
+#include <nameser8_compat.h>
+#endif
+#include <arpa/nameser.h>
+#include <resolv.h>
+#include <string.h>
+#include "dkimdns.h"
+
+static unsigned short
+getshort(unsigned char *cp)
+{
+	return (cp[0] << 8) | cp[1];
+}
+
+static struct
+{
+	unsigned char  *buf;
+} response;
+static int      responsebuflen = 0;
+static int      responselen;
+static unsigned char *responseend;
+static unsigned char *responsepos;
+static u_long   saveresoptions;
+static int      numanswers;
+static char     name[MAXDNAME];
+
+static int
+resolve(char *domain, int type)
+{
+	int             n, i;
+	unsigned char  *ptr;
+
+	errno = 0;
+	if (!responsebuflen) {
+		if ((response.buf = (unsigned char *) malloc(PACKETSZ + 1)))
+			responsebuflen = PACKETSZ + 1;
+		else
+			return DNS_MEM;
+	}
+	responselen = res_query(domain, C_IN, type, response.buf, responsebuflen);
+	if ((responselen >= responsebuflen) || (responselen > 0 && (((HEADER *) response.buf)->tc))) {
+		if (responsebuflen < 65536) {
+			if ((ptr = (unsigned char *) realloc((void *) response.buf, 65536))) {
+				response.buf = ptr;
+				responsebuflen = 65536;
+			} else {
+				free(response.buf);
+				responsebuflen = 0;
+				return DNS_MEM;
+			}
+		}
+		saveresoptions = _res.options;
+		_res.options |= RES_USEVC;
+		responselen = res_query(domain, C_IN, type, response.buf, responsebuflen);
+		_res.options = saveresoptions;
+	}
+	if (responselen <= 0) {
+		if (errno == ECONNREFUSED)
+			return DNS_SOFT;
+		if (h_errno == TRY_AGAIN)
+			return DNS_SOFT;
+		return DNS_HARD;
+	}
+	responseend = response.buf + responselen;
+	responsepos = response.buf + sizeof(HEADER);
+	n = ntohs(((HEADER *) response.buf)->qdcount);
+	while (n-- > 0) {
+		if ((i = dn_expand(response.buf, responseend, responsepos, name, MAXDNAME)) < 0)
+			return DNS_SOFT;
+		responsepos += i;
+		i = responseend - responsepos;
+		if (i < QFIXEDSZ)
+			return DNS_SOFT;
+		responsepos += QFIXEDSZ;
+	}
+	numanswers = ntohs(((HEADER *) response.buf)->ancount);
+	return 0;
+}
+
+void
+byte_copy(register char *to, register unsigned int n, register char *from)
+{
+	for (;;) {
+		if (!n)
+			return;
+		*to++ = *from++;
+		--n;
+		if (!n)
+			return;
+		*to++ = *from++;
+		--n;
+		if (!n)
+			return;
+		*to++ = *from++;
+		--n;
+		if (!n)
+			return;
+		*to++ = *from++;
+		--n;
+	}
+}
+
+static char     *txt;
+static int      txtlen;
+
+static int
+findtxt(int wanttype, int *txt_strlen)
+{
+	unsigned short  rrtype, rrdlen;
+	char           *ptr;
+	int             i;
+
+	if (numanswers <= 0)
+		return 2;
+	--numanswers;
+	if (responsepos == responseend)
+		return DNS_SOFT;
+
+	if ((i = dn_expand(response.buf, responseend, responsepos, name, MAXDNAME)) < 0)
+		return DNS_SOFT;
+	responsepos += i;
+
+	if ((i = responseend - responsepos) < 4 + 3 * 3)
+		return DNS_SOFT;
+
+	rrtype = getshort(responsepos);
+	rrdlen = getshort(responsepos + 8);
+	responsepos += 10;
+
+	*txt_strlen = 0;
+	if (!txtlen) {
+		if (!(txt = (char *) malloc(PACKETSZ * 2 * sizeof(char))))
+			return DNS_MEM;
+		txtlen = PACKETSZ * 2;
+	}
+	if (rrtype == wanttype) {
+		unsigned short  txtpos;
+		unsigned char   n;
+
+		*txt = 0;
+		for (txtpos = 0; txtpos < rrdlen; txtpos += n) {
+			n = responsepos[txtpos++];
+			if (n > rrdlen - txtpos)
+				n = rrdlen - txtpos;
+			if ((*txt_strlen + n + 1) > txtlen) {
+				if (!(ptr = (char *) realloc(txt, (*txt_strlen + n) * 2))) {
+					free(txt);
+					txtlen = 0;
+					*txt_strlen = 0;
+					return DNS_MEM;
+				}
+				txt = ptr;
+				txtlen = (*txt_strlen + n) * 2;
+			}
+			byte_copy(txt + *txt_strlen, n, (char *) &responsepos[txtpos]);
+			*txt_strlen += n;
+		}
+		responsepos += rrdlen;
+		txt[*txt_strlen] = 0;
+		return 1;
+	}
+	responsepos += rrdlen;
+	return 0;
+}
+
+static char    *dnresult;
+static int      dnresultlen;
+
+static int
+dns_txtplus(char *domain)
+{
+	int             r, len, total;
+	char           *ptr;
+
+	switch (resolve(domain, T_TXT))
+	{
+	case DNS_MEM:
+		return DNS_MEM;
+	case DNS_SOFT:
+		return DNS_SOFT;
+	case DNS_HARD:
+		return DNS_HARD;
+	}
+	total = 0;
+	if (!dnresultlen) {
+		if (!(dnresult = (char *) malloc((2 * PACKETSZ) * sizeof(char))))
+			return DNS_MEM;
+		dnresultlen = 2 * PACKETSZ;
+	}
+	while ((r = findtxt(T_TXT, &len)) != 2) {
+		if (r == DNS_SOFT) {
+			if (txtlen) {
+				txtlen = 0;
+				free(txt);
+			}
+			return DNS_SOFT;
+		}
+		if (r == 1) {
+			if ((total + len + 1) >= dnresultlen) {
+				if (!(ptr = (char *) realloc(dnresult, (total + len) * 2))) {
+					free(dnresult);
+					dnresultlen = 0;
+					if (txtlen) {
+						txtlen = 0;
+						free(txt);
+					}
+					return DNS_MEM;
+				}
+				dnresult = ptr;
+				dnresultlen = (total + len) * 2;
+			}
+			byte_copy(dnresult + total, len, txt);
+			total += len;
+		}
+	}
+	if (txtlen) {
+		txtlen = 0;
+		free(txt);
+	}
+	if (total) {
+		dnresult[total] = 0;
+		return (0);
+	}
+	return DNS_HARD;
+}
+
+/*
+ * we always return a null-terminated string which has been malloc'ed.  The string
+ * is always in the tag=value form.  If a temporary or permanent error occurs,
+ * the string will be exactly "e=perm;" or "e=temp;".
+ * Note that it never returns NULL.
+ */
+char           *
+dns_text(char *dn)
+{
+	int             r;
+	
+	switch (r = dns_txtplus(dn))
+	{
+	case DNS_MEM:
+	case DNS_SOFT:
+		if (responsebuflen) {
+			free(response.buf);
+			responsebuflen = 0;
+		}
+		return strdup("e=temp;");
+	case DNS_HARD:
+		if (responsebuflen) {
+			free(response.buf);
+			responsebuflen = 0;
+		}
+		return strdup("e=perm;");
+	}
+	if (responsebuflen) {
+		free(response.buf);
+		responsebuflen = 0;
+	}
+	return dnresult;
+}
+
+
+int
+DNSGetTXT(const char *domain, char *buffer, int maxlen)
+{
+	char           *results;
+	int             len;
+
+	results = dns_text((char *) domain);
+	if (!strcmp(results, "e=perm;")) {
+		free(results);
+		dnresultlen = 0;
+		return DNSRESP_PERM_FAIL;
+	} else
+	if (!strcmp(results, "e=temp;")) {
+		free(results);
+		dnresultlen = 0;
+		return DNSRESP_TEMP_FAIL;
+	}
+	if ((len = strlen(results)) > maxlen - 1) {
+		free(results);
+		dnresultlen = 0;
+		return DNSRESP_DOMAIN_NAME_TOO_LONG;
+	}
+	byte_copy(buffer, len, results);
+	buffer[len] = 0;
+	free(results);
+	dnresultlen = 0;
+	return DNSRESP_SUCCESS;
+}
+
+void
+getversion_dkimdns_cpp()
+{
+	static char    *x = (char *) "$Id: dns.cpp,v 1.10 2017-09-05 11:01:06+05:30 Cprogrammer Exp mbhangui $";
+
+	x++;
+}
diff -Naur netqmail-1.06.org/dkimdns.h netqmail-1.06/dkimdns.h
--- netqmail-1.06.org/dkimdns.h	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/dkimdns.h	2018-04-03 17:28:43.661318498 +0530
@@ -0,0 +1,54 @@
+/*
+ * $Log: dns.h,v $
+ * Revision 1.4  2017-05-16 12:40:39+05:30  Cprogrammer
+ * define DNS_SOFT, DNS_HARD and DNS_MEM
+ *
+ * Revision 1.3  2009-03-27 20:40:16+05:30  Cprogrammer
+ * removed windows definitions
+ *
+ * Revision 1.2  2009-03-27 19:23:01+05:30  Cprogrammer
+ * added dns_text()
+ *
+ * Revision 1.1  2009-03-21 08:50:24+05:30  Cprogrammer
+ * Initial revision
+ *
+ *  Copyright 2005 Alt-N Technologies, Ltd. 
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License"); 
+ *  you may not use this file except in compliance with the License. 
+ *  You may obtain a copy of the License at 
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0 
+ *
+ *  This code incorporates intellectual property owned by Yahoo! and licensed 
+ *  pursuant to the Yahoo! DomainKeys Patent License Agreement.
+ *
+ *  Unless required by applicable law or agreed to in writing, software 
+ *  distributed under the License is distributed on an "AS IS" BASIS, 
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ *  See the License for the specific language governing permissions and 
+ *  limitations under the License.
+ *
+ */
+
+// These DNS resolution routines are encapsulated by the API below
+
+// return values for DNS functions:
+
+
+#define MAX_DOMAIN			254
+
+#define DNSRESP_SUCCESS					0	// DNS lookup returned sought after records
+#define DNSRESP_TEMP_FAIL				1	// No response from DNS server
+#define DNSRESP_PERM_FAIL				2	// DNS server returned error or no records
+#define DNSRESP_DOMAIN_NAME_TOO_LONG	3	// Domain name too long
+#define DNSRESP_NXDOMAIN				4	// DNS server returned Name Error
+#define DNSRESP_EMPTY					5	// DNS server returned successful response but no records
+
+#define DNS_SOFT -1
+#define DNS_HARD -2
+#define DNS_MEM  -3
+
+// Pass in the FQDN to get the TXT record
+int             DNSGetTXT(const char *szFQDN, char *Buffer, int nBufLen);
+char           *dns_text(char *szFQDN);
diff -Naur netqmail-1.06.org/dkimfuncs.cpp netqmail-1.06/dkimfuncs.cpp
--- netqmail-1.06.org/dkimfuncs.cpp	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/dkimfuncs.cpp	2018-08-25 18:13:32.839247873 +0530
@@ -0,0 +1,236 @@
+/*
+ * $Log: dkimfuncs.cpp,v $
+ * Revision 1.4  2011-06-04 10:06:33+05:30  Cprogrammer
+ * unified error strings for signing & verification
+ *
+ * Revision 1.3  2009-04-15 20:45:29+05:30  Cprogrammer
+ * code beautified
+ *
+ * Revision 1.2  2009-03-26 15:11:12+05:30  Cprogrammer
+ * added GetDomain(), ADSP
+ *
+ * Revision 1.1  2009-03-21 08:43:10+05:30  Cprogrammer
+ * Initial revision
+ *
+ *
+ *  Copyright 2005 Alt-N Technologies, Ltd. 
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License"); 
+ *  you may not use this file except in compliance with the License. 
+ *  You may obtain a copy of the License at 
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0 
+ *
+ *  This code incorporates intellectual property owned by Yahoo! and licensed 
+ *  pursuant to the Yahoo! DomainKeys Patent License Agreement.
+ *
+ *  Unless required by applicable law or agreed to in writing, software 
+ *  distributed under the License is distributed on an "AS IS" BASIS, 
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ *  See the License for the specific language governing permissions and 
+ *  limitations under the License.
+ *
+ */
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+#include "dkim.h"
+#include "dkimsign.h"
+#include "dkimverify.h"
+#include <string.h>
+
+#define DKIMID ('D' | 'K'<<8 | 'I'<<16 | 'M'<<24)
+
+static void
+InitContext(DKIMContext *pContext, bool bSign, void *pObject)
+{
+	pContext->reserved1 = DKIMID;
+	pContext->reserved2 = bSign ? 1 : 0;
+	pContext->reserved3 = pObject;
+}
+
+static void    *
+ValidateContext(DKIMContext *pContext, bool bSign)
+{
+	if (pContext->reserved1 != DKIMID)
+		return NULL;
+	if (pContext->reserved2 != (unsigned int) (bSign ? 1 : 0))
+		return NULL;
+	return pContext->reserved3;
+}
+
+int             DKIM_CALL
+DKIMSignInit(DKIMContext *pSignContext, DKIMSignOptions *pOptions)
+{
+	int             nRet = DKIM_OUT_OF_MEMORY;
+	CDKIMSign      *pSign = new CDKIMSign;
+
+	if (pSign) {
+		nRet = pSign->Init(pOptions);
+		if (nRet != DKIM_SUCCESS)
+			delete          pSign;
+	}
+	if (nRet == DKIM_SUCCESS)
+		InitContext(pSignContext, true, pSign);
+	return nRet;
+}
+
+int             DKIM_CALL
+DKIMSignProcess(DKIMContext *pSignContext, char *szBuffer, int nBufLength)
+{
+	CDKIMSign      *pSign = (CDKIMSign *) ValidateContext(pSignContext, true);
+	if (pSign)
+		return pSign->Process(szBuffer, nBufLength, false);
+	return DKIM_INVALID_CONTEXT;
+}
+
+int             DKIM_CALL
+DKIMSignGetSig(DKIMContext *pSignContext, char *szPrivKey, char *szSignature, int nSigLength)
+{
+	CDKIMSign      *pSign = (CDKIMSign *) ValidateContext(pSignContext, true);
+	if (pSign)
+		return pSign->GetSig(szPrivKey, szSignature, nSigLength);
+	return DKIM_INVALID_CONTEXT;
+}
+
+int             DKIM_CALL
+DKIMSignGetSig2(DKIMContext *pSignContext, char *szPrivKey, char **pszSignature)
+{
+	CDKIMSign      *pSign = (CDKIMSign *) ValidateContext(pSignContext, true);
+	if (pSign)
+		return pSign->GetSig2(szPrivKey, pszSignature);
+	return DKIM_INVALID_CONTEXT;
+}
+
+char           *DKIM_CALL
+DKIMSignGetDomain(DKIMContext *pSignContext)
+{
+	CDKIMSign      *pSign = (CDKIMSign *) ValidateContext(pSignContext, true);
+	if (pSign)
+		return pSign->GetDomain();
+	return ((char *) 0);
+}
+
+void            DKIM_CALL
+DKIMSignFree(DKIMContext *pSignContext)
+{
+	CDKIMSign      *pSign = (CDKIMSign *) ValidateContext(pSignContext, true);
+	if (pSign) {
+		delete          pSign;
+		pSignContext->reserved3 = NULL;
+	}
+}
+
+int             DKIM_CALL
+DKIMVerifyInit(DKIMContext *pVerifyContext, DKIMVerifyOptions *pOptions)
+{
+	int             nRet = DKIM_OUT_OF_MEMORY;
+	CDKIMVerify    *pVerify = new CDKIMVerify;
+	if (pVerify) {
+		nRet = pVerify->Init(pOptions);
+		if (nRet != DKIM_SUCCESS)
+			delete          pVerify;
+	}
+	if (nRet == DKIM_SUCCESS)
+		InitContext(pVerifyContext, false, pVerify);
+	return nRet;
+}
+
+int             DKIM_CALL
+DKIMVerifyProcess(DKIMContext *pVerifyContext, char *szBuffer, int nBufLength)
+{
+	CDKIMVerify    *pVerify = (CDKIMVerify *) ValidateContext(pVerifyContext, false);
+	if (pVerify)
+		return pVerify->Process(szBuffer, nBufLength, false);
+	return DKIM_INVALID_CONTEXT;
+}
+
+int             DKIM_CALL
+DKIMVerifyResults( DKIMContext *pVerifyContext , int *sCount, int *sSize)
+{
+	CDKIMVerify    *pVerify = (CDKIMVerify *) ValidateContext(pVerifyContext, false);
+	if (pVerify)
+		return pVerify->GetResults(sCount, sSize);
+	return DKIM_INVALID_CONTEXT;
+}
+
+int             DKIM_CALL
+DKIMVerifyGetDetails(DKIMContext *pVerifyContext, int *nSigCount, DKIMVerifyDetails **pDetails, char *szPractices)
+{
+	szPractices[0] = '\0';
+	CDKIMVerify    *pVerify = (CDKIMVerify *) ValidateContext(pVerifyContext, false);
+	if (pVerify) {
+		strcpy(szPractices, pVerify->GetPractices());
+		return pVerify->GetDetails(nSigCount, pDetails);
+	}
+	return DKIM_INVALID_CONTEXT;
+}
+
+void            DKIM_CALL
+DKIMVerifyFree(DKIMContext *pVerifyContext)
+{
+	CDKIMVerify    *pVerify = (CDKIMVerify *) ValidateContext(pVerifyContext, false);
+	if (pVerify) {
+		delete          pVerify;
+		pVerifyContext->reserved3 = NULL;
+	}
+}
+
+char           *DKIM_CALL
+DKIMVerifyGetDomain(DKIMContext *pVerifyContext)
+{
+	CDKIMVerify    *pVerify = (CDKIMVerify *) ValidateContext(pVerifyContext, false);
+	if (pVerify)
+		return pVerify->GetDomain();
+	return ((char *) 0);
+}
+
+char           *DKIM_CALL
+DKIMVersion()
+{
+	return (char *) "1.5";
+}
+
+static char    *DKIMErrorStrings[-1 - DKIM_MAX_ERROR] = {
+	(char *) "DKIM_FAIL",
+	(char *) "DKIM_BAD_SYNTAX",
+	(char *) "DKIM_SIGNATURE_BAD",
+	(char *) "DKIM_SIGNATURE_BAD_BUT_TESTING",
+	(char *) "DKIM_SIGNATURE_EXPIRED",
+	(char *) "DKIM_SELECTOR_INVALID",
+	(char *) "DKIM_SELECTOR_GRANULARITY_MISMATCH",
+	(char *) "DKIM_SELECTOR_KEY_REVOKED",
+	(char *) "DKIM_SELECTOR_DOMAIN_NAME_TOO_LONG",
+	(char *) "DKIM_SELECTOR_DNS_TEMP_FAILURE",
+	(char *) "DKIM_SELECTOR_DNS_PERM_FAILURE",
+	(char *) "DKIM_SELECTOR_PUBLIC_KEY_INVALID",
+	(char *) "DKIM_NO_SIGNATURES",
+	(char *) "DKIM_NO_VALID_SIGNATURES",
+	(char *) "DKIM_BODY_HASH_MISMATCH",
+	(char *) "DKIM_SELECTOR_ALGORITHM_MISMATCH",
+	(char *) "DKIM_STAT_INCOMPAT",
+	(char *) "DKIM_UNSIGNED_FROM",
+	(char *) "DKIM_OUT_OF_MEMORY",
+	(char *) "DKIM_INVALID_CONTEXT",
+	(char *) "DKIM_NO_SENDER",
+	(char *) "DKIM_BAD_PRIVATE_KEY",
+	(char *) "DKIM_BUFFER_TOO_SMALL"
+};
+
+char           *DKIM_CALL
+DKIMGetErrorString(int ErrorCode)
+{
+	if (ErrorCode >= 0 || ErrorCode <= DKIM_MAX_ERROR)
+		return (char *) "Unknown";
+
+	else
+		return DKIMErrorStrings[-1 - ErrorCode];
+}
+
+void
+getversion_dkimfuncs_cpp()
+{
+	static char    *x = (char *) "$Id: dkimfuncs.cpp,v 1.4 2011-06-04 10:06:33+05:30 Cprogrammer Exp mbhangui $";
+
+	x++;
+}
diff -Naur netqmail-1.06.org/dkim.h netqmail-1.06/dkim.h
--- netqmail-1.06.org/dkim.h	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/dkim.h	2018-04-03 17:28:43.661318498 +0530
@@ -0,0 +1,193 @@
+/*
+ * $Log: dkim.h,v $
+ * Revision 1.8  2015-12-15 16:03:18+05:30  Cprogrammer
+ * use time_t for expireTime
+ *
+ * Revision 1.7  2011-06-04 13:56:06+05:30  Cprogrammer
+ * corrected return codes
+ *
+ * Revision 1.6  2011-06-04 10:04:00+05:30  Cprogrammer
+ * unified error code for signing & verifcation
+ * added signature and identity domain information to
+ *     DKIMVerifyDetails structure
+ *
+ * Revision 1.5  2009-03-27 20:19:05+05:30  Cprogrammer
+ * major changes made for incorporating ADSP
+ *
+ * Revision 1.4  2009-03-26 19:28:15+05:30  Cprogrammer
+ * removed DKIM_3PS_PARTIAL_SUCCESS
+ *
+ * Revision 1.3  2009-03-26 15:11:33+05:30  Cprogrammer
+ * added ADSP
+ *
+ * Revision 1.2  2009-03-25 08:37:58+05:30  Cprogrammer
+ * changed definitions of constants to avoid clash between error and success
+ *
+ * Revision 1.1  2009-03-21 08:50:19+05:30  Cprogrammer
+ * Initial revision
+ *
+ *
+ *  Copyright 2005 Alt-N Technologies, Ltd. 
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License"); 
+ *  you may not use this file except in compliance with the License. 
+ *  You may obtain a copy of the License at 
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0 
+ *
+ *  This code incorporates intellectual property owned by Yahoo! and licensed 
+ *  pursuant to the Yahoo! DomainKeys Patent License Agreement.
+ *
+ *  Unless required by applicable law or agreed to in writing, software 
+ *  distributed under the License is distributed on an "AS IS" BASIS, 
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ *  See the License for the specific language governing permissions and 
+ *  limitations under the License.
+ *
+ */
+
+#define DKIM_CALL
+#define MAKELONG(a,b) ((long)(((unsigned)(a) & 0xffff) | (((unsigned)(b) & 0xffff) << 16)))
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+#include <time.h>
+// DKIM Body hash versions
+#define DKIM_BODYHASH_ALLMAN_1	1
+#define DKIM_BODYHASH_IETF_1	2
+#define DKIM_BODYHASH_BOTH		DKIM_BODYHASH_ALLMAN_1 | DKIM_BODYHASH_IETF_1
+
+// DKIM hash algorithms
+#define DKIM_HASH_SHA1			1
+#define DKIM_HASH_SHA256		2
+#define DKIM_HASH_SHA1_AND_256  DKIM_HASH_SHA1 | DKIM_HASH_SHA256
+
+// DKIM canonicalization methods
+#define DKIM_CANON_SIMPLE		1
+#define DKIM_CANON_NOWSP		2
+#define DKIM_CANON_RELAXED		3
+
+#define DKIM_SIGN_SIMPLE			MAKELONG(DKIM_CANON_SIMPLE,DKIM_CANON_SIMPLE)
+#define DKIM_SIGN_SIMPLE_RELAXED	MAKELONG(DKIM_CANON_RELAXED,DKIM_CANON_SIMPLE)
+#define DKIM_SIGN_RELAXED			MAKELONG(DKIM_CANON_RELAXED,DKIM_CANON_RELAXED)
+#define DKIM_SIGN_RELAXED_SIMPLE	MAKELONG(DKIM_CANON_SIMPLE,DKIM_CANON_RELAXED)
+
+// DKIM_SUCCESS                                 // verify result: all signatures verified
+// signature result: signature verified
+#define DKIM_SUCCESS						 0	// operation successful
+#define DKIM_FINISHED_BODY					 1	// process result: no more message body is needed
+#define DKIM_PARTIAL_SUCCESS				 2	// verify result: at least one but not all signatures verified
+#define DKIM_NEUTRAL						 3	// verify result: no signatures verified but message is not suspicous
+#define DKIM_SUCCESS_BUT_EXTRA				 4	// signature result: signature verified but it did not include all of the body
+#define DKIM_3PS_SIGNATURE					 5	// 3rd-party signature
+
+// DKIM Error codes
+#define DKIM_FAIL							-1	// verify error: message is suspicious
+#define DKIM_BAD_SYNTAX						-2	// signature error: DKIM-Signature could not parse or has bad tags/values
+#define DKIM_SIGNATURE_BAD					-3	// signature error: RSA verify failed
+#define DKIM_SIGNATURE_BAD_BUT_TESTING		-4	// signature error: RSA verify failed but testing
+#define DKIM_SIGNATURE_EXPIRED				-5	// signature error: x= is old
+#define DKIM_SELECTOR_INVALID				-6	// signature error: selector doesn't parse or contains invalid values
+#define DKIM_SELECTOR_GRANULARITY_MISMATCH	-7	// signature error: selector g= doesn't match i=
+#define DKIM_SELECTOR_KEY_REVOKED			-8	// signature error: selector p= empty
+#define DKIM_SELECTOR_DOMAIN_NAME_TOO_LONG	-9	// signature error: selector domain name too long to request
+#define DKIM_SELECTOR_DNS_TEMP_FAILURE		-10	// signature error: temporary dns failure requesting selector
+#define DKIM_SELECTOR_DNS_PERM_FAILURE		-11	// signature error: permanent dns failure requesting selector
+#define DKIM_SELECTOR_PUBLIC_KEY_INVALID	-12	// signature error: selector p= value invalid or wrong format
+#define DKIM_NO_SIGNATURES					-13	// process error, no sigs
+#define DKIM_NO_VALID_SIGNATURES			-14	// process error, no valid sigs
+#define DKIM_BODY_HASH_MISMATCH				-15	// sigature verify error: message body does not hash to bh value
+#define DKIM_SELECTOR_ALGORITHM_MISMATCH	-16	// signature error: selector h= doesn't match signature a=
+#define DKIM_STAT_INCOMPAT					-17	// signature error: incompatible v=
+#define DKIM_UNSIGNED_FROM                  -18 // signature error: not all message's From headers in signature
+#define DKIM_OUT_OF_MEMORY                  -19 // memory allocation failed
+#define DKIM_INVALID_CONTEXT                -20 // DKIMContext structure invalid for this operation
+#define DKIM_NO_SENDER                      -21 // signing error: Could not find From: or Sender: header in message
+#define DKIM_BAD_PRIVATE_KEY                -22 // signing error: Could not parse private key
+#define DKIM_BUFFER_TOO_SMALL               -23 // signing error: Buffer passed in is not large enough
+#define DKIM_MAX_ERROR                      -24 // set this to 1 greater than the highest error code (but negative)
+
+#define DKIM_SSP_UNKNOWN			 1 /*- some messages may be signed */
+#define DKIM_SSP_ALL				 2 /*- all messages are signed, 3rd party allowed */
+#define DKIM_SSP_STRICT				 3 /*- all messages are signed, no 3rd party allowed */
+#define DKIM_SSP_SCOPE				 4 /*- the domain should be considered invalid */
+#define DKIM_SSP_TEMPFAIL			 5 /*- Temporary Error */
+
+#define DKIM_ADSP_UNKNOWN			 1 /*- some messages may be signed */
+#define DKIM_ADSP_ALL				 2 /*- All message are signed with author signature */
+#define DKIM_ADSP_DISCARDABLE		 3 /*- messages which fail verification are Discardable */
+#define DKIM_ADSP_SCOPE				 4 /*- domain is out of scope */
+#define DKIM_ADSP_TEMPFAIL			 5 /*- Temporary Error */
+
+
+// This function is called once for each header in the message
+// return 1 to include this header in the signature and 0 to exclude.
+typedef int     (DKIM_CALL * DKIMHEADERCALLBACK) (const char *szHeader);
+
+// This function is called to retrieve a TXT record from DNS
+typedef int     (DKIM_CALL * DKIMDNSCALLBACK) (const char *szFQDN, char *szBuffer, int nBufLen);
+
+typedef struct DKIMContext_t {
+	unsigned int    reserved1;
+	unsigned int    reserved2;
+	void           *reserved3;
+} DKIMContext;
+
+typedef struct DKIMSignOptions_t {
+	int             nCanon;	// canonization 
+	int             nIncludeBodyLengthTag;	// 0 = don't include l= tag, 1 = include l= tag
+	int             nIncludeTimeStamp;	// 0 = don't include t= tag, 1 = include t= tag
+	int             nIncludeQueryMethod;	// 0 = don't include q= tag, 1 = include q= tag
+	char            szSelector[80];	// selector - required
+	char            szDomain[256];	// domain - optional - if empty, domain is computed from sender
+	char            szIdentity[256];	// for i= tag, if empty tag will not be included in sig
+	time_t          expireTime;	// for x= tag, if 0 tag will not be included in sig
+	DKIMHEADERCALLBACK pfnHeaderCallback;	// header callback
+	char            szRequiredHeaders[256];	// colon-separated list of headers that must be signed
+	int             nHash;	// use one of the DKIM_HASH_xx constants here
+	// even if not present in the message
+	int             nIncludeCopiedHeaders;	// 0 = don't include z= tag, 1 = include z= tag
+	int             nIncludeBodyHash;	// use one of the DKIM_BODYHASH_xx constants here
+} DKIMSignOptions;
+
+typedef struct DKIMVerifyOptions_t {
+	DKIMDNSCALLBACK pfnSelectorCallback;	// selector record callback
+	DKIMDNSCALLBACK pfnPracticesCallback;	// SSP record callback
+	int             nHonorBodyLengthTag;	// 0 = ignore l= tag, 1 = use l= tag to limit the amount of body verified
+	int             nCheckPractices;		// 0 = use default (unknown) practices, 1 = request and use sender's signing practices
+	int             nSubjectRequired;		// 0 = subject is required to be signed, 1 = not required
+	int             nSaveCanonicalizedData;	// 0 = canonicalized data is not saved, 1 = canonicalized data is saved
+	int             nAllowUnsignedFromHeaders;	// 0 = From headers not included in the signature are not allowed, 1 = allowed
+	int             nAccept3ps;				// 0 = don't check 3rd party signature(s), 1 = check 3rd party signature(s)
+} DKIMVerifyOptions;
+
+typedef struct DKIMVerifyDetails_t {
+	char           *szSignature;
+	char           *DNS;
+	char           *szSignatureDomain;
+	char           *szIdentityDomain;
+	char           *szCanonicalizedData;
+	int             nResult;
+} DKIMVerifyDetails;
+
+int DKIM_CALL   DKIMSignInit(DKIMContext *pSignContext, DKIMSignOptions * pOptions);
+int DKIM_CALL   DKIMSignProcess(DKIMContext *pSignContext, char *szBuffer, int nBufLength);
+int DKIM_CALL   DKIMSignGetSig(DKIMContext *pSignContext, char *szPrivKey, char *szSignature, int nSigLength);
+int DKIM_CALL   DKIMSignGetSig2(DKIMContext *pSignContext, char *szPrivKey, char **pszSignature);
+void DKIM_CALL  DKIMSignFree(DKIMContext *pSignContext);
+char           *DKIM_CALL DKIMSignGetDomain(DKIMContext *pSignContext);
+
+int DKIM_CALL   DKIMVerifyInit(DKIMContext *pVerifyContext, DKIMVerifyOptions * pOptions);
+int DKIM_CALL   DKIMVerifyProcess(DKIMContext *pVerifyContext, char *szBuffer, int nBufLength);
+int DKIM_CALL   DKIMVerifyResults(DKIMContext *pVerifyContext , int *sCount, int *sSize);
+int DKIM_CALL   DKIMVerifyGetDetails(DKIMContext *pVerifyContext, int *nSigCount, DKIMVerifyDetails **pDetails, char *szPractices);
+char           *DKIM_CALL DKIMVerifyGetDomain(DKIMContext *pVerifyContext);
+void DKIM_CALL  DKIMVerifyFree(DKIMContext *pVerifyContext);
+char           *DKIM_CALL DKIMVersion();
+char           *DKIM_CALL DKIMGetErrorString(int ErrorCode);
+#include "macros.h"
+#ifdef __cplusplus
+}
+#endif
diff -Naur netqmail-1.06.org/dkimsign.cpp netqmail-1.06/dkimsign.cpp
--- netqmail-1.06.org/dkimsign.cpp	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/dkimsign.cpp	2018-08-25 18:02:56.233916922 +0530
@@ -0,0 +1,1008 @@
+/*
+ * $Log: dkimsign.cpp,v $
+ * Revision 1.13  2018-08-25 18:01:59+05:30  Cprogrammer
+ * fixed dkim signing for From address containing company name
+ *
+ * Revision 1.12  2018-05-23 13:07:58+05:30  Cprogrammer
+ * fixed compiler warnings
+ *
+ * Revision 1.11  2017-09-05 10:59:03+05:30  Cprogrammer
+ * removed compiler warnings
+ *
+ * Revision 1.10  2017-08-09 22:02:13+05:30  Cprogrammer
+ * replaced EVP_MD_CTX_free() with EVP_MD_CTX_reset()
+ *
+ * Revision 1.9  2017-08-08 23:50:19+05:30  Cprogrammer
+ * openssl 1.1.0 port
+ *
+ * Revision 1.8  2013-07-16 20:18:03+05:30  Cprogrammer
+ * replace '%' with domain name in selector
+ *
+ * Revision 1.7  2013-06-11 00:02:39+05:30  Cprogrammer
+ * removed header iostream
+ *
+ * Revision 1.6  2013-06-09 16:41:28+05:30  Cprogrammer
+ * parse address properly from From and Sender header
+ *
+ * Revision 1.5  2009-04-16 10:32:38+05:30  Cprogrammer
+ * added DKIMDOMAIN env variable
+ *
+ * Revision 1.4  2009-04-15 21:32:12+05:30  Cprogrammer
+ * added DKIM-Signature, Received to list of excluded headers
+ *
+ * Revision 1.3  2009-03-26 15:11:46+05:30  Cprogrammer
+ * added GetDomain
+ *
+ * Revision 1.2  2009-03-21 11:57:19+05:30  Cprogrammer
+ * fixed indentation
+ *
+ * Revision 1.1  2009-03-21 08:43:11+05:30  Cprogrammer
+ * Initial revision
+ *
+ *
+ *  Copyright 2005 Alt-N Technologies, Ltd. 
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License"); 
+ *  you may not use this file except in compliance with the License. 
+ *  You may obtain a copy of the License at 
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0 
+ *
+ *  This code incorporates intellectual property owned by Yahoo! and licensed 
+ *  pursuant to the Yahoo! DomainKeys Patent License Agreement.
+ *
+ *  Unless required by applicable law or agreed to in writing, software 
+ *  distributed under the License is distributed on an "AS IS" BASIS, 
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ *  See the License for the specific language governing permissions and 
+ *  limitations under the License.
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+#define _strnicmp strncasecmp
+#define _stricmp strcasecmp
+#define LOWORD(l) ((unsigned)(l) & 0xffff)
+#define HIWORD(l) ((unsigned)(l) >> 16)
+
+#include <string.h>
+#include <map>
+#include "dkim.h"
+#include "dkimsign.h"
+
+CDKIMSign::CDKIMSign()
+{
+	m_EmptyLineCount = 0;
+	m_pfnHdrCallback = NULL;
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+	if (!m_allman_sha1ctx)
+		m_allman_sha1ctx = EVP_MD_CTX_new();
+	EVP_SignInit(m_allman_sha1ctx, EVP_sha1());
+	if (!m_Hdr_ietf_sha1ctx)
+		m_Hdr_ietf_sha1ctx = EVP_MD_CTX_new();
+	EVP_SignInit(m_Hdr_ietf_sha1ctx, EVP_sha1());
+	if (!m_Bdy_ietf_sha1ctx)
+		m_Bdy_ietf_sha1ctx = EVP_MD_CTX_new();
+	EVP_DigestInit(m_Bdy_ietf_sha1ctx, EVP_sha1());
+#ifdef HAVE_EVP_SHA256
+	if (!m_Hdr_ietf_sha256ctx)
+		m_Hdr_ietf_sha256ctx = EVP_MD_CTX_new();
+	EVP_SignInit(m_Hdr_ietf_sha256ctx, EVP_sha256());
+	if (!m_Bdy_ietf_sha256ctx)
+		m_Bdy_ietf_sha256ctx = EVP_MD_CTX_new();
+	EVP_DigestInit(m_Bdy_ietf_sha256ctx, EVP_sha256());
+#endif
+#else
+	EVP_SignInit(&m_allman_sha1ctx, EVP_sha1());
+	EVP_SignInit(&m_Hdr_ietf_sha1ctx, EVP_sha1());
+	EVP_DigestInit(&m_Bdy_ietf_sha1ctx, EVP_sha1());
+#ifdef HAVE_EVP_SHA256
+	EVP_SignInit(&m_Hdr_ietf_sha256ctx, EVP_sha256());
+	EVP_DigestInit(&m_Bdy_ietf_sha256ctx, EVP_sha256());
+#endif
+#endif
+}
+
+CDKIMSign::~CDKIMSign()
+{
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+	EVP_MD_CTX_reset(m_allman_sha1ctx);
+	EVP_MD_CTX_reset(m_Hdr_ietf_sha1ctx);
+	EVP_MD_CTX_reset(m_Bdy_ietf_sha1ctx);
+#ifdef HAVE_EVP_SHA256
+	EVP_MD_CTX_reset(m_Hdr_ietf_sha256ctx);
+	EVP_MD_CTX_reset(m_Bdy_ietf_sha256ctx);
+#endif
+#else
+	EVP_MD_CTX_cleanup(&m_allman_sha1ctx);
+	EVP_MD_CTX_cleanup(&m_Hdr_ietf_sha1ctx);
+	EVP_MD_CTX_cleanup(&m_Bdy_ietf_sha1ctx);
+#ifdef HAVE_EVP_SHA256
+	EVP_MD_CTX_cleanup(&m_Hdr_ietf_sha256ctx);
+	EVP_MD_CTX_cleanup(&m_Bdy_ietf_sha256ctx);
+#endif
+#endif
+}
+
+
+////////////////////////////////////////////////////////////////////////////////
+// 
+// Init - save the options
+//
+////////////////////////////////////////////////////////////////////////////////
+int
+CDKIMSign::Init(DKIMSignOptions * pOptions)
+{
+	int             nRet = CDKIMBase::Init();
+	m_Canon = pOptions->nCanon;
+
+// as of draft 01, these are the only allowed signing types:
+	if ((m_Canon != DKIM_SIGN_SIMPLE_RELAXED) && (m_Canon != DKIM_SIGN_RELAXED) && (m_Canon != DKIM_SIGN_RELAXED_SIMPLE)) {
+		m_Canon = DKIM_SIGN_SIMPLE;
+	}
+	sSelector.assign(pOptions->szSelector);
+	m_pfnHdrCallback = pOptions->pfnHeaderCallback;
+	sDomain.assign(pOptions->szDomain);
+	m_IncludeBodyLengthTag = (pOptions->nIncludeBodyLengthTag != 0);
+	m_nBodyLength = 0;
+	m_ExpireTime = pOptions->expireTime;
+	sIdentity.assign(pOptions->szIdentity);
+	m_nIncludeTimeStamp = pOptions->nIncludeTimeStamp;
+	m_nIncludeQueryMethod = pOptions->nIncludeQueryMethod;
+	m_nIncludeCopiedHeaders = pOptions->nIncludeCopiedHeaders;
+	m_nIncludeBodyHash = pOptions->nIncludeBodyHash;
+
+// NOTE: the following line is not backwards compatible with MD 8.0.3
+// because the szRequiredHeaders member was added after the release
+//sRequiredHeaders.assign( pOptions->szRequiredHeaders );
+
+//make sure there is a colon after the last header in the list
+	if ((sRequiredHeaders.size() > 0) && sRequiredHeaders.at(sRequiredHeaders.size() - 1) != ':')
+		sRequiredHeaders.append(":");
+	m_nHash = pOptions->nHash;
+	m_bReturnedSigAssembled = false;
+	m_sCopiedHeaders.erase();
+	return nRet;
+}
+
+
+// Hash - update the hash
+void
+CDKIMSign::Hash(const char *szBuffer, int nBufLength, bool bHdr, bool bAllmanOnly)
+{
+	EVP_MD_CTX     *p1, *p2, *p3, *p4, *p5;
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+	p1 = m_allman_sha1ctx;
+	p2 = m_Hdr_ietf_sha1ctx;
+	p3 = m_Hdr_ietf_sha256ctx;
+	p4 = m_Bdy_ietf_sha1ctx;
+	p5 = m_Bdy_ietf_sha256ctx;
+#else
+	p1 = &m_allman_sha1ctx;
+	p2 = &m_Hdr_ietf_sha1ctx;
+	p3 = &m_Hdr_ietf_sha256ctx;
+	p4 = &m_Bdy_ietf_sha1ctx;
+	p5 = &m_Bdy_ietf_sha256ctx;
+#endif
+	if (bAllmanOnly) {
+		if (m_nIncludeBodyHash & DKIM_BODYHASH_ALLMAN_1)
+			EVP_SignUpdate(p1, szBuffer, nBufLength);
+	} else {
+		if (m_nIncludeBodyHash < DKIM_BODYHASH_IETF_1)
+			EVP_SignUpdate(p1, szBuffer, nBufLength);
+		else
+		if (m_nIncludeBodyHash & DKIM_BODYHASH_IETF_1) {
+			if (m_nIncludeBodyHash & DKIM_BODYHASH_ALLMAN_1)
+				EVP_SignUpdate(p1, szBuffer, nBufLength);
+#ifdef HAVE_EVP_SHA256
+			if (m_nHash & DKIM_HASH_SHA256) {
+				if (bHdr)
+					EVP_SignUpdate(p3, szBuffer, nBufLength);
+				else
+					EVP_DigestUpdate(p5, szBuffer, nBufLength);
+			}
+			if (m_nHash != DKIM_HASH_SHA256) {
+				if (bHdr)
+					EVP_SignUpdate(p2, szBuffer, nBufLength);
+				else
+					EVP_DigestUpdate(p4, szBuffer, nBufLength);
+			}
+#else
+			if (bHdr)
+				EVP_SignUpdate(p2, szBuffer, nBufLength);
+			else
+				EVP_DigestUpdate(p4, szBuffer, nBufLength);
+#endif
+		}
+	}
+}
+
+
+////////////////////////////////////////////////////////////////////////////////
+// 
+// SignThisTag - return boolean whether or not to sign this tag
+//
+////////////////////////////////////////////////////////////////////////////////
+bool CDKIMSign::SignThisTag(const string &sTag)
+{
+	bool            bRet = true;
+
+	if (_strnicmp(sTag.c_str(), "X-", 2) == 0
+		|| _stricmp(sTag.c_str(), "Authentication-Results:") == 0
+		|| _stricmp(sTag.c_str(), "DKIM-Signature:") == 0
+		|| _stricmp(sTag.c_str(), "Received:") == 0
+		|| _stricmp(sTag.c_str(), "Return-Path:") == 0)
+	{
+		bRet = false;
+	}
+	return bRet;
+}
+
+bool
+ConvertHeaderToQuotedPrintable(const char *source, char *dest)
+{
+	bool            bConvert = false;
+
+// do quoted printable
+	static unsigned char hexchars[16] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };
+	unsigned char  *d = (unsigned char *) dest;
+	for (const unsigned char *s = (const unsigned char *)source; *s != '\0'; s++) {
+		if (*s >= 33 && *s <= 126 && *s != '=' && *s != ':' && *s != ';' && *s != '|') {
+			*d++ = *s;
+		}
+
+		else {
+			bConvert = true;
+			*d++ = '=';
+			*d++ = hexchars[*s >> 4];
+			*d++ = hexchars[*s & 15];
+		}
+	}
+	*d = '\0';
+	return bConvert;
+}
+
+
+////////////////////////////////////////////////////////////////////////////////
+// 
+// GetHeaderParams - Extract any needed header parameters
+//
+////////////////////////////////////////////////////////////////////////////////
+void
+CDKIMSign::GetHeaderParams(const string & sHdr)
+{
+	if (_strnicmp(sHdr.c_str(), "X", 1) == 0)
+		return;
+	if (_strnicmp(sHdr.c_str(), "From:", 5) == 0)
+		sFrom.assign(sHdr.c_str() + 5);
+	if (_strnicmp(sHdr.c_str(), "Sender:", 7) == 0)
+		sSender.assign(sHdr.c_str() + 7);
+	if (_strnicmp(sHdr.c_str(), "Return-Path:", 12) == 0)
+		sReturnPath.assign(sHdr.c_str() + 12);
+	if (m_nIncludeCopiedHeaders) {
+		string::size_type pos = sHdr.find(':');
+		if (pos != string::npos) {
+			string          sTag, sValue;
+			char           *workBuffer = new char[sHdr.size() * 3 + 1];
+			sTag.assign(sHdr.substr(0, pos));
+			sValue.assign(sHdr.substr(pos + 1, string::npos));
+			ConvertHeaderToQuotedPrintable(sTag.c_str(), workBuffer);
+			if (!m_sCopiedHeaders.empty()) {
+				m_sCopiedHeaders.append("|");
+			}
+			m_sCopiedHeaders.append(workBuffer);
+			m_sCopiedHeaders.append(":");
+			ConvertHeaderToQuotedPrintable(sValue.c_str(), workBuffer);
+			m_sCopiedHeaders.append(workBuffer);
+			delete[]workBuffer;
+		}
+	}
+}
+
+// ProcessHeaders - sign headers and save needed parameters
+int
+CDKIMSign::ProcessHeaders(void)
+{
+	map <string, list <string>::reverse_iterator> IterMap;
+	map <string, list <string>::reverse_iterator>::iterator IterMapIter;
+	list <string>::reverse_iterator riter;
+	list <string>::iterator iter;
+	string          sTag;
+	bool            bFromHeaderFound = false;
+
+	// walk the header list
+	for (iter = HeaderList.begin(); iter != HeaderList.end(); iter++) {
+		sTag.assign(*iter);
+		// look for a colon
+		string::size_type pos = sTag.find(':');
+		if (pos != string::npos) {
+			int             nSignThisTag = 1;
+			// hack off anything past the colon
+			sTag.erase(pos + 1, string::npos);
+			// is this the From: header?
+			if (_stricmp(sTag.c_str(), "From:") == 0) {
+				bFromHeaderFound = true;
+				nSignThisTag = 1;
+				IsRequiredHeader(sTag);	// remove from required header list
+			} 
+			// is this in the list of headers that must be signed?
+			else
+			if (IsRequiredHeader(sTag))
+				nSignThisTag = 1;
+			else {
+				if (m_pfnHdrCallback)
+					nSignThisTag = m_pfnHdrCallback(iter->c_str());
+				else
+					nSignThisTag = SignThisTag(sTag) ? 1 : 0;
+			}
+			// save header parameters
+			GetHeaderParams(*iter);
+			if (nSignThisTag > 0) {
+				// add this tag to h=
+				hParam.append(sTag);
+				IterMapIter = IterMap.find(sTag);
+				riter = (IterMapIter == IterMap.end())? HeaderList.rbegin() : IterMapIter->second;
+				// walk the list in reverse looking for the last instance of this header
+				while (riter != HeaderList.rend()) {
+					if (_strnicmp(riter->c_str(), sTag.c_str(), sTag.size()) == 0) {
+						ProcessHeader(*riter);
+						// save the reverse iterator position for this tag
+						riter++;
+						IterMap[sTag] = riter;
+						break;
+					}
+					riter++;
+				}
+			}
+		}
+	}
+	Hash("\r\n", 2, true, true);	// only for Allman sig
+	if (!bFromHeaderFound) {
+		string sFrom("From:");
+		hParam.append(sFrom);
+		IsRequiredHeader(sFrom);	// remove from required header list
+	}
+	hParam.append(sRequiredHeaders);
+	if (hParam.at(hParam.size() - 1) == ':')
+		hParam.erase(hParam.size() - 1, string::npos);
+	return DKIM_SUCCESS;
+}
+
+char           *DKIM_CALL
+CDKIMSign::GetDomain(void)
+{
+	if (ParseFromAddress() == false)
+		return ((char *) 0);
+	return ((char *) sDomain.c_str());
+}
+
+void
+CDKIMSign::ProcessHeader(const string & sHdr)
+{
+	switch (HIWORD(m_Canon)) {
+	case DKIM_CANON_SIMPLE:
+		Hash(sHdr.c_str(), sHdr.size(), true);
+		Hash("\r\n", 2, true);
+		break;
+	case DKIM_CANON_NOWSP:
+		{
+		string sTemp = sHdr;
+		RemoveSWSP(sTemp);
+		// convert characters before ':' to lower case
+		for (char *s = (char *)sTemp.c_str(); *s != '\0' && *s != ':'; s++) {
+			if (*s >= 'A' && *s <= 'Z')
+				*s += 'a' - 'A';
+		}
+		Hash(sTemp.c_str(), sTemp.size(), true);
+		Hash("\r\n", 2, true);
+		}
+		break;
+	case DKIM_CANON_RELAXED:
+		{
+		string sTemp = RelaxHeader(sHdr);
+		Hash(sTemp.c_str(), sTemp.length(), true);
+		Hash("\r\n", 2, true);
+		}
+		break;
+	}
+}
+
+int CDKIMSign::ProcessBody(char *szBuffer, int nBufLength, bool bEOF)
+{
+	switch (LOWORD(m_Canon)) {
+	case DKIM_CANON_SIMPLE:
+		if (nBufLength > 0) {
+			while (m_EmptyLineCount > 0) {
+				Hash("\r\n", 2, false);
+				m_nBodyLength += 2;
+				m_EmptyLineCount--;
+			}
+			Hash(szBuffer, nBufLength, false);
+			Hash("\r\n", 2, false);
+			m_nBodyLength += nBufLength + 2;
+		} else {
+			m_EmptyLineCount++;
+			if (bEOF) {
+				Hash("\r\n", 2, false);
+				m_nBodyLength += 2;
+			}
+		}
+		break;
+	case DKIM_CANON_NOWSP:
+		RemoveSWSP(szBuffer, nBufLength);
+		if (nBufLength > 0) {
+			Hash(szBuffer, nBufLength, false);
+			m_nBodyLength += nBufLength;
+		}
+		break;
+	case DKIM_CANON_RELAXED:
+		CompressSWSP(szBuffer, nBufLength);
+		if (nBufLength > 0) {
+			while (m_EmptyLineCount > 0) {
+				Hash("\r\n", 2, false);
+				m_nBodyLength += 2;
+				m_EmptyLineCount--;
+			}
+			Hash(szBuffer, nBufLength, false);
+			m_nBodyLength += nBufLength;
+			if (!bEOF) {
+				Hash("\r\n", 2, false);
+				m_nBodyLength += 2;
+			}
+		} else
+			m_EmptyLineCount++;
+		break;
+	}
+	return DKIM_SUCCESS;
+}
+
+bool CDKIMSign::ParseFromAddress(void)
+{
+	string::size_type pos;
+	string          sAddress;
+	char           *p, *at;
+
+	/* thanks to fred */
+	if (!sReturnPath.empty())
+		sAddress.assign(sReturnPath);
+	else
+	if (!sSender.empty())
+		sAddress.assign(sSender);
+	else
+	if (!sFrom.empty())
+		sAddress.assign(sFrom);
+	else
+		return false;
+	// simple for now, beef it up later
+	// remove '<' and anything before it
+	pos = sAddress.find('<');
+	if (pos != string::npos)
+		sAddress.erase(0, pos);
+	// remove '>' and anything after it
+	pos = sAddress.find('>');
+	if (pos != string::npos)
+		sAddress.erase(pos, string::npos);
+	// look for '@' symbol
+	pos = sAddress.find('@');
+	if (pos == string::npos)
+		return false;
+	if (sDomain.empty()) {
+		p = getenv("DKIMDOMAIN");
+		if (p && *p)
+		{
+			if (!(at = strchr(p, '@')))
+				at = p;
+			else
+				at++;
+			sDomain.assign(at);
+		} else
+			sDomain.assign(sAddress.c_str() + pos + 1);
+		RemoveSWSP(sDomain);
+	}
+	return true;
+}
+
+
+////////////////////////////////////////////////////////////////////////////////
+// 
+// InitSig - initialize signature folding algorithm
+//
+////////////////////////////////////////////////////////////////////////////////
+void
+CDKIMSign::InitSig(void)
+{
+	m_sSig.reserve(1024);
+	m_sSig.assign("DKIM-Signature:");
+	m_nSigPos = m_sSig.size();
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// 
+// AddTagToSig - add tag and value to signature folding if necessary
+//               if bFold, fold at cbrk char
+//
+////////////////////////////////////////////////////////////////////////////////
+void CDKIMSign::AddTagToSig(char *Tag, const string & sValue, char cbrk, bool bFold)
+{
+	int
+	                nTagLen = strlen(Tag);
+	AddInterTagSpace((!bFold) ? sValue.size() + nTagLen + 2 : nTagLen + 2);
+	m_sSig.append(Tag);
+	m_sSig.append("=");
+	m_nSigPos += 1 + nTagLen;
+	if (!bFold) {
+		m_sSig.append(sValue);
+		m_nSigPos += sValue.size();
+	}
+
+	else {
+		AddFoldedValueToSig(sValue, cbrk);
+	}
+	m_sSig.append(";");
+	m_nSigPos++;
+}
+
+
+////////////////////////////////////////////////////////////////////////////////
+// 
+// AddTagToSig - add tag and numeric value to signature folding if necessary
+//
+////////////////////////////////////////////////////////////////////////////////
+void CDKIMSign::AddTagToSig(char *Tag, unsigned long nValue)
+{
+	char            szValue[64];
+	sprintf(szValue, "%lu", nValue);
+	AddTagToSig(Tag, szValue, 0, false);
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// 
+// AddInterTagSpace - add space or fold here
+//
+////////////////////////////////////////////////////////////////////////////////
+void CDKIMSign::AddInterTagSpace(int nSizeOfNextTag)
+{
+	if (m_nSigPos + nSizeOfNextTag + 1 > OptimalHeaderLineLength) {
+		m_sSig.append("\n\t");
+		m_nSigPos = 1;
+	}
+
+	else {
+		m_sSig.append(" ");
+		m_nSigPos++;
+	}
+}
+
+
+////////////////////////////////////////////////////////////////////////////////
+// 
+// AddTagToSig - add value to signature folding if necessary
+//               if cbrk == 0 fold anywhere, otherwise fold only at cbrk
+//
+////////////////////////////////////////////////////////////////////////////////
+void CDKIMSign::AddFoldedValueToSig(const string & sValue, char cbrk)
+{
+	string::size_type pos = 0;
+	if (cbrk == 0) {
+
+	// fold anywhere
+		while (pos < sValue.size()) {
+			string::size_type len = OptimalHeaderLineLength - m_nSigPos;
+			if (len > sValue.size() - pos)
+				len = sValue.size() - pos;
+			m_sSig.append(sValue.substr(pos, len));
+			m_nSigPos += len;
+			pos += len;
+			if (pos < sValue.size()) {
+				m_sSig.append("\n\t");
+				m_nSigPos = 1;
+			}
+		}
+	}
+
+	else {
+
+	// fold only at cbrk
+		while (pos < sValue.size()) {
+			string::size_type len = OptimalHeaderLineLength - m_nSigPos;
+			string::size_type brkpos;
+			if (sValue.size() - pos < len) {
+				brkpos = sValue.size() - 1;
+			}
+
+			else {
+				brkpos = sValue.rfind(cbrk, pos + len);
+			}
+			if (brkpos == string::npos || brkpos < pos) {
+				brkpos = sValue.find(cbrk, pos);
+				if (brkpos == string::npos) {
+					brkpos = sValue.size();
+				}
+			}
+			len = brkpos - pos + 1;
+			m_sSig.append(sValue.substr(pos, len));
+			m_nSigPos += len;
+			pos += len;
+			if (pos < sValue.size()) {
+
+			//m_sSig.append( "\r\n\t" );
+				m_sSig.append("\n\t");
+				m_nSigPos = 1;
+			}
+		}
+	}
+}
+
+
+////////////////////////////////////////////////////////////////////////////////
+// 
+// GetSig - compute hash and return signature header in szSignature
+//
+////////////////////////////////////////////////////////////////////////////////
+int CDKIMSign::GetSig(char *szPrivKey, char *szSignature, unsigned int nSigLength)
+{
+	if (szPrivKey == NULL) {
+		return DKIM_BAD_PRIVATE_KEY;
+	}
+	if (szSignature == NULL) {
+		return DKIM_BUFFER_TOO_SMALL;
+	}
+	int             nRet = AssembleReturnedSig(szPrivKey);
+	if (nRet != DKIM_SUCCESS)
+		return nRet;
+	if (m_sReturnedSig.size() + 1 < nSigLength)
+		strcpy(szSignature, m_sReturnedSig.c_str());
+	else 
+		return DKIM_BUFFER_TOO_SMALL;
+	return DKIM_SUCCESS;
+}
+
+
+////////////////////////////////////////////////////////////////////////////////
+// 
+// GetSig - compute hash and return signature header in szSignature
+//
+////////////////////////////////////////////////////////////////////////////////
+int CDKIMSign::GetSig2(char *szPrivKey, char **pszSignature)
+{
+	if (szPrivKey == NULL) {
+		return DKIM_BAD_PRIVATE_KEY;
+	}
+	if (pszSignature == NULL) {
+		return DKIM_BUFFER_TOO_SMALL;
+	}
+	int             nRet = AssembleReturnedSig(szPrivKey);
+	if (nRet != DKIM_SUCCESS)
+		return nRet;
+	*pszSignature = (char *) m_sReturnedSig.c_str();
+	return DKIM_SUCCESS;
+}
+
+
+////////////////////////////////////////////////////////////////////////////////
+// 
+// IsRequiredHeader - Check if header in required list. If so, delete
+//                    header from list.
+//
+////////////////////////////////////////////////////////////////////////////////
+bool CDKIMSign::IsRequiredHeader(const string & sTag)
+{
+	string::size_type start = 0;
+	string::size_type end = sRequiredHeaders.find(':');
+	while (end != string::npos) {
+
+	// check for a zero-length header
+		if (start == end) {
+			sRequiredHeaders.erase(start, 1);
+		}
+
+		else {
+			if (_stricmp(sTag.c_str(), sRequiredHeaders.substr(start, end - start + 1).c_str()) == 0) {
+				sRequiredHeaders.erase(start, end - start + 1);
+				return true;
+			}
+
+			else {
+				start = end + 1;
+			}
+		}
+		end = sRequiredHeaders.find(':', start);
+	}
+	return false;
+}
+
+int CDKIMSign::ConstructSignature(char *szPrivKey, bool bUseIetfBodyHash, bool bUseSha256)
+{
+	string          sSignedSig;
+	unsigned char  *sig;
+	EVP_PKEY       *pkey;
+	BIO            *bio, *b64;
+	unsigned int    siglen;
+	int             size, len;
+	char           *buf, *cptr; 
+	const char     *ptr, *dptr, *sptr;
+	EVP_MD_CTX     *p1, *p2, *p3, *p4, *p5;
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+	p1 = m_allman_sha1ctx;
+	p2 = m_Hdr_ietf_sha1ctx;
+	p3 = m_Hdr_ietf_sha256ctx;
+	p4 = m_Bdy_ietf_sha1ctx;
+	p5 = m_Bdy_ietf_sha256ctx;
+#else
+	p1 = &m_allman_sha1ctx;
+	p2 = &m_Hdr_ietf_sha1ctx;
+	p3 = &m_Hdr_ietf_sha256ctx;
+	p4 = &m_Bdy_ietf_sha1ctx;
+	p5 = &m_Bdy_ietf_sha256ctx;
+#endif
+
+// construct the DKIM-Signature: header and add to hash
+	InitSig();
+	if (bUseIetfBodyHash) {
+		AddTagToSig((char *) "v", (char *) "1", 0, false);
+	}
+#ifdef HAVE_EVP_SHA256
+	AddTagToSig((char *) "a", bUseSha256 ? "rsa-sha256" : "rsa-sha1", 0, false);
+#else
+	AddTagToSig((char *) "a", "rsa-sha1", 0, false);
+#endif
+	switch (m_Canon) {
+	case DKIM_SIGN_SIMPLE:
+		AddTagToSig((char *) "c", "simple", 0, false);
+		break;
+	case DKIM_SIGN_SIMPLE_RELAXED:
+		AddTagToSig((char *) "c", "simple/relaxed", 0, false);
+		break;
+	case DKIM_SIGN_RELAXED:
+		AddTagToSig((char *) "c", "relaxed/relaxed", 0, false);
+		break;
+	case DKIM_SIGN_RELAXED_SIMPLE:
+		AddTagToSig((char *) "c", "relaxed", 0, false);
+		break;
+	}
+	AddTagToSig((char *) "d", sDomain, 0, false);
+	/*- replace % with domain name */
+	ptr = sSelector.c_str();
+	if ((sptr = strchr(ptr, '%'))) {
+		dptr = sDomain.c_str();
+		for (sptr = ptr, len = 0;*sptr;sptr++) {
+			if (*sptr == '%')
+				len += (int) strlen(dptr) + 1;
+			else
+				len++;
+		}
+		if (!(buf = new char[len]))
+			return DKIM_OUT_OF_MEMORY;
+		for (cptr = buf, sptr = ptr; *sptr; sptr++) {
+			if (*sptr == '%') {
+				memcpy(cptr, dptr, (len = strlen(dptr)));
+				cptr += len;
+			} else
+				*cptr++ = *sptr;
+		}
+		*cptr = 0;
+		sSelector.assign(buf);
+		delete[]buf;
+	}
+	AddTagToSig((char *) "s", sSelector, 0, false);
+	if (m_IncludeBodyLengthTag) {
+		AddTagToSig((char *) "l", m_nBodyLength);
+	}
+	if (m_nIncludeTimeStamp != 0) {
+		time_t t;
+		time(&t);
+		AddTagToSig((char *) "t", t);
+	}
+	if (m_ExpireTime != 0) {
+		AddTagToSig((char *) "x", m_ExpireTime);
+	}
+	if (!sIdentity.empty()) {
+		AddTagToSig((char *) "i", sIdentity, 0, false);
+	}
+	if (m_nIncludeQueryMethod) {
+		AddTagToSig((char *) "q", bUseIetfBodyHash ? "dns/txt" : "dns", 0, false);
+	}
+	AddTagToSig((char *) "h", hParam, ':', true);
+	if (m_nIncludeCopiedHeaders) {
+		AddTagToSig((char *) "z", m_sCopiedHeaders, 0, true);
+	}
+	if (bUseIetfBodyHash) {
+		unsigned char Hash[EVP_MAX_MD_SIZE];
+		unsigned int nHashLen = 0;
+#ifdef HAVE_EVP_SHA256
+		EVP_DigestFinal(bUseSha256 ? p5 : p4, Hash, &nHashLen);
+#else
+		EVP_DigestFinal(p4, Hash, &nHashLen);
+#endif
+		bio = BIO_new(BIO_s_mem());
+		if (!bio) {
+			return DKIM_OUT_OF_MEMORY;
+		}
+		b64 = BIO_new(BIO_f_base64());
+		if (!b64) {
+			BIO_free(bio);
+			return DKIM_OUT_OF_MEMORY;
+		}
+		BIO_set_flags(b64, BIO_FLAGS_BASE64_NO_NL);
+		BIO_push(b64, bio);
+		if (BIO_write(b64, Hash, nHashLen) < (int) nHashLen) {
+			BIO_free_all(b64);
+			return DKIM_OUT_OF_MEMORY;
+		}
+		BIO_flush(b64);
+		len = nHashLen * 2;
+		buf = new char[len];
+		if (buf == NULL) {
+			BIO_free_all(b64);
+			return DKIM_OUT_OF_MEMORY;
+		}
+		size = BIO_read(bio, buf, len);
+		BIO_free_all(b64);
+		// this should never happen
+		if (size >= len) {
+			delete[]buf;
+			return DKIM_OUT_OF_MEMORY;
+		}
+		buf[size] = '\0';
+		AddTagToSig((char *) "bh", buf, 0, true);
+		delete[]buf;
+	}
+	AddInterTagSpace(3);
+	m_sSig.append("b=");
+	m_nSigPos += 2;
+	// Force a full copy - no reference copies please
+	sSignedSig.assign(m_sSig.c_str());
+	// note that since we're not calling hash here, need to dump this
+	// to the debug file if you want the full canonical form
+	string          sTemp;
+	if (HIWORD(m_Canon) == DKIM_CANON_RELAXED)
+		sTemp = RelaxHeader(sSignedSig);
+	else
+		sTemp = sSignedSig.c_str();
+	if (bUseIetfBodyHash) {
+#ifdef HAVE_EVP_SHA256
+		EVP_SignUpdate(bUseSha256 ? p3 : p2, sTemp.c_str(), sTemp.size());
+#else
+		EVP_SignUpdate(p2, sTemp.c_str(), sTemp.size());
+#endif
+	} else
+		EVP_SignUpdate(p1, sTemp.c_str(), sTemp.size());
+	if (!(bio = BIO_new_mem_buf(szPrivKey, -1)))
+		return DKIM_OUT_OF_MEMORY;
+	pkey = PEM_read_bio_PrivateKey(bio, NULL, NULL, NULL);
+	BIO_free(bio);
+	if (!pkey) {
+		return DKIM_BAD_PRIVATE_KEY;
+	}
+	siglen = EVP_PKEY_size(pkey);
+	int             nSignRet;
+	sig = (unsigned char *) OPENSSL_malloc(siglen);
+	if (sig == NULL) {
+		EVP_PKEY_free(pkey);
+		return DKIM_OUT_OF_MEMORY;
+	}
+	if (bUseIetfBodyHash) {
+#ifdef HAVE_EVP_SHA256
+		nSignRet = EVP_SignFinal(bUseSha256 ? p3 : p2, sig, &siglen, pkey);
+#else
+		nSignRet = EVP_SignFinal(p2, sig, &siglen, pkey);
+#endif
+	} else
+		nSignRet = EVP_SignFinal(p1, sig, &siglen, pkey);
+	EVP_PKEY_free(pkey);
+	if (!nSignRet) {
+		OPENSSL_free(sig);
+		return DKIM_BAD_PRIVATE_KEY;	// key too small
+	}
+	bio = BIO_new(BIO_s_mem());
+	if (!bio) {
+		return DKIM_OUT_OF_MEMORY;
+	}
+	b64 = BIO_new(BIO_f_base64());
+	if (!b64) {
+		BIO_free(bio);
+		return DKIM_OUT_OF_MEMORY;
+	}
+	BIO_set_flags(b64, BIO_FLAGS_BASE64_NO_NL);
+	BIO_push(b64, bio);
+	if (BIO_write(b64, sig, siglen) < (int) siglen) {
+		OPENSSL_free(sig);
+		BIO_free_all(b64);
+		return DKIM_OUT_OF_MEMORY;
+	}
+	BIO_flush(b64);
+	OPENSSL_free(sig);
+	len = siglen * 2;
+	buf = new char[len];
+	if (buf == NULL) {
+		BIO_free_all(b64);
+		return DKIM_OUT_OF_MEMORY;
+	}
+	size = BIO_read(bio, buf, len);
+	BIO_free_all(b64);
+	// this should never happen
+	if (size >= len) {
+		delete[]buf;
+		return DKIM_OUT_OF_MEMORY;
+	}
+	buf[size] = '\0';
+	AddFoldedValueToSig(buf, 0);
+	delete[]buf;
+	return DKIM_SUCCESS;
+}
+
+int CDKIMSign::AssembleReturnedSig(char *szPrivKey)
+{
+	int             nRet;
+	if (m_bReturnedSigAssembled)
+		return DKIM_SUCCESS;
+	ProcessFinal();
+	if (ParseFromAddress() == false) {
+		//return DKIM_NO_SENDER;
+	}
+	Hash("\r\n", 2, true, true);	// only for Allman sig
+	string allmansha1sig,
+#ifdef HAVE_EVP_SHA256
+		ietfsha256Sig,
+#endif
+		ietfsha1Sig;
+	if (m_nIncludeBodyHash < DKIM_BODYHASH_IETF_1) {
+		nRet = ConstructSignature(szPrivKey, false, false);
+		if (nRet == DKIM_SUCCESS)
+			allmansha1sig.assign(m_sSig);
+		else
+			return nRet;
+	} else
+	if (m_nIncludeBodyHash & DKIM_BODYHASH_IETF_1) {
+		if (m_nIncludeBodyHash & DKIM_BODYHASH_ALLMAN_1) {
+			if ((nRet = ConstructSignature(szPrivKey, false, false)) == DKIM_SUCCESS)
+				allmansha1sig.assign(m_sSig);
+			else
+				return nRet;
+		}
+#ifdef HAVE_EVP_SHA256
+		if (m_nHash & DKIM_HASH_SHA256) {
+			if ((nRet = ConstructSignature(szPrivKey, true, true)) == DKIM_SUCCESS)
+				ietfsha256Sig.assign(m_sSig);
+			else
+				return nRet;
+		}
+		if (m_nHash != DKIM_HASH_SHA256) {
+			if ((nRet = ConstructSignature(szPrivKey, true, false)) == DKIM_SUCCESS)
+				ietfsha1Sig.assign(m_sSig);
+			else
+				return nRet;
+		}
+#else
+		if ((nRet = ConstructSignature(szPrivKey, true, false)) == DKIM_SUCCESS)
+			ietfsha1Sig.assign(m_sSig);
+		else
+			return nRet;
+#endif
+	}
+	m_sReturnedSig.assign(allmansha1sig);
+	if (!ietfsha1Sig.empty()) {
+		if (!m_sReturnedSig.empty())
+			m_sReturnedSig.append("\n");
+		m_sReturnedSig.append(ietfsha1Sig);
+	}
+#ifdef HAVE_EVP_SHA256
+	if (!ietfsha256Sig.empty()) {
+		if (!m_sReturnedSig.empty())
+			m_sReturnedSig.append("\n");
+		m_sReturnedSig.append(ietfsha256Sig);
+	}
+#endif
+	m_bReturnedSigAssembled = true;
+	return DKIM_SUCCESS;
+}
+
+void
+getversion_dkimsign_cpp()
+{
+	static char    *x = (char *) "$Id: dkimsign.cpp,v 1.13 2018-08-25 18:01:59+05:30 Cprogrammer Exp mbhangui $";
+
+	x++;
+}
diff -Naur netqmail-1.06.org/dkimsign.h netqmail-1.06/dkimsign.h
--- netqmail-1.06.org/dkimsign.h	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/dkimsign.h	2018-08-25 18:09:39.632958650 +0530
@@ -0,0 +1,111 @@
+/*
+ * $Log: dkimsign.h,v $
+ * Revision 1.4  2017-09-05 10:59:20+05:30  Cprogrammer
+ * removed compiler warnings
+ *
+ * Revision 1.3  2017-08-09 22:03:09+05:30  Cprogrammer
+ * initialized EVP_MD_CTX variables
+ *
+ * Revision 1.2  2017-08-08 23:50:33+05:30  Cprogrammer
+ * openssl 1.1.0 port
+ *
+ * Revision 1.1  2009-04-16 10:34:02+05:30  Cprogrammer
+ * Initial revision
+ *
+ *
+ *  Copyright 2005 Alt-N Technologies, Ltd. 
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License"); 
+ *  you may not use this file except in compliance with the License. 
+ *  You may obtain a copy of the License at 
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0 
+ *
+ *  This code incorporates intellectual property owned by Yahoo! and licensed 
+ *  pursuant to the Yahoo! DomainKeys Patent License Agreement.
+ *
+ *  Unless required by applicable law or agreed to in writing, software 
+ *  distributed under the License is distributed on an "AS IS" BASIS, 
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ *  See the License for the specific language governing permissions and 
+ *  limitations under the License.
+ *
+ */
+
+#ifndef DKIMSIGN_H
+#define DKIMSIGN_H
+
+#include "dkimbase.h"
+
+class           CDKIMSign:public CDKIMBase {
+public:
+
+	CDKIMSign();
+	~CDKIMSign();
+	int             Init(DKIMSignOptions * pOptions);
+	int             GetSig(char *szPrivKey, char *szSignature, unsigned int nSigLength);
+	int             GetSig2(char *szPrivKey, char **pszSignature);
+	virtual int     ProcessHeaders(void);
+	virtual int     ProcessBody(char *szBuffer, int nBufLength, bool bEOF);
+	enum CKDKIMConstants { OptimalHeaderLineLength = 65 };
+	char           *DKIM_CALL GetDomain(void);
+
+protected:
+	void            Hash(const char *szBuffer, int nBufLength, bool bHdr, bool bAllmanOnly = false);
+	bool            SignThisTag(const string & sTag);
+	void            GetHeaderParams(const string & sHdr);
+	void            ProcessHeader(const string & sHdr);
+	bool            ParseFromAddress(void);
+	void            InitSig(void);
+	void            AddTagToSig(char *Tag, const string & sValue, char cbrk, bool bFold);
+	void            AddTagToSig(char *Tag, unsigned long nValue);
+	void            AddInterTagSpace(int nSizeOfNextTag);
+	void            AddFoldedValueToSig(const string & sValue, char cbrk);
+	bool            IsRequiredHeader(const string & sTag);
+	int             ConstructSignature(char *szPrivKey, bool bUseIetfBodyHash, bool bUseSha256);
+	int             AssembleReturnedSig(char *szPrivKey);
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+	EVP_MD_CTX     *m_Hdr_ietf_sha1ctx = NULL;	/* the header hash for ietf sha1  */
+	EVP_MD_CTX     *m_Bdy_ietf_sha1ctx = NULL;	/* the body hash for ietf sha1  */
+#ifdef HAVE_EVP_SHA256
+	EVP_MD_CTX     *m_Hdr_ietf_sha256ctx = NULL;	/* the header hash for ietf sha256 */
+	EVP_MD_CTX     *m_Bdy_ietf_sha256ctx = NULL;	/* the body hash for ietf sha256 */
+#endif
+	EVP_MD_CTX     *m_allman_sha1ctx = NULL;	/* the hash for allman sha1  */
+#else
+	EVP_MD_CTX      m_Hdr_ietf_sha1ctx;	/* the header hash for ietf sha1  */
+	EVP_MD_CTX      m_Bdy_ietf_sha1ctx;	/* the body hash for ietf sha1  */
+#ifdef HAVE_EVP_SHA256
+	EVP_MD_CTX      m_Hdr_ietf_sha256ctx;	/* the header hash for ietf sha256 */
+	EVP_MD_CTX      m_Bdy_ietf_sha256ctx;	/* the body hash for ietf sha256 */
+#endif
+	EVP_MD_CTX      m_allman_sha1ctx;	/* the hash for allman sha1  */
+#endif
+	int             m_Canon;	// canonization method
+	int             m_EmptyLineCount;
+	string          hParam;
+	string          sFrom;
+	string          sSender;
+	string          sSelector;
+	string          sReturnPath;
+	string          sDomain;
+	string          sIdentity;	// for i= tag, if empty tag will not be included in sig
+	string          sRequiredHeaders;
+	bool            m_IncludeBodyLengthTag;
+	int             m_nBodyLength;
+	time_t          m_ExpireTime;
+	int             m_nIncludeTimeStamp;	// 0 = don't include t= tag, 1 = include t= tag
+	int             m_nIncludeQueryMethod;	// 0 = don't include q= tag, 1 = include q= tag
+	int             m_nHash;	// use one of the DKIM_HASH_xx constants here
+	int             m_nIncludeCopiedHeaders;	// 0 = don't include z= tag, 1 = include z= tag
+	int             m_nIncludeBodyHash;	// 0 = calculate sig using draft 0, 1 = include bh= tag and 
+	// use new signature computation algorithm
+	DKIMHEADERCALLBACK m_pfnHdrCallback;
+	string          m_sSig;
+	int             m_nSigPos;
+	string          m_sReturnedSig;
+	bool            m_bReturnedSigAssembled;
+	string          m_sCopiedHeaders;
+};
+
+#endif	/*- DKIMSIGN_H */
diff -Naur netqmail-1.06.org/dkimverify.cpp netqmail-1.06/dkimverify.cpp
--- netqmail-1.06.org/dkimverify.cpp	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/dkimverify.cpp	2019-05-22 09:38:48.155578093 +0530
@@ -0,0 +1,1300 @@
+/*
+ * $Log: dkimverify.cpp,v $
+ * Revision 1.18  2017-09-05 11:00:33+05:30  Cprogrammer
+ * removed extra whitespace
+ *
+ * Revision 1.17  2017-09-03 14:02:04+05:30  Cprogrammer
+ * call EVP_MD_CTX_init() only once
+ *
+ * Revision 1.16  2017-09-01 12:46:05+05:30  Cprogrammer
+ * removed dkimd2i_PUBKEY function
+ *
+ * Revision 1.15  2017-08-31 17:04:34+05:30  Cprogrammer
+ * replaced d2i_PUBKEY() with dkimd2i_PUBKEY() to avoid SIGSEGV on X509_PUBKEY_free()
+ *
+ * Revision 1.14  2017-08-09 21:59:39+05:30  Cprogrammer
+ * fixed segmentation fault. Use EVP_MD_CTX_reset() instead of EVP_MD_CTX_free()
+ *
+ * Revision 1.13  2017-08-08 23:50:41+05:30  Cprogrammer
+ * openssl 1.1.0 port
+ *
+ * Revision 1.12  2017-05-23 09:23:45+05:30  Cprogrammer
+ * use strtok_r instead of strtok() for thread safe operation
+ *
+ * Revision 1.11  2016-03-01 16:24:00+05:30  Cprogrammer
+ * reverse value of m_SubjectIsRequired
+ *
+ * Revision 1.10  2015-12-15 16:05:00+05:30  Cprogrammer
+ * fixed issue with time comparision. Use time_t for time variables
+ *
+ * Revision 1.9  2011-06-04 10:05:01+05:30  Cprogrammer
+ * added signature and identity domain information to
+ *     DKIMVerifyDetails structure
+ *
+ * Revision 1.8  2011-06-04 09:37:13+05:30  Cprogrammer
+ * added AllowUnsignedFromHeaders
+ *
+ * Revision 1.7  2009-06-11 13:58:34+05:30  Cprogrammer
+ * port for DARWIN
+ *
+ * Revision 1.6  2009-05-31 21:09:29+05:30  Cprogrammer
+ * changed cast
+ *
+ * Revision 1.5  2009-03-27 20:19:58+05:30  Cprogrammer
+ * added ADSP code
+ *
+ * Revision 1.4  2009-03-26 15:12:05+05:30  Cprogrammer
+ * added ADSP code
+ *
+ * Revision 1.3  2009-03-25 08:38:20+05:30  Cprogrammer
+ * fixed indentation
+ *
+ * Revision 1.2  2009-03-21 11:57:40+05:30  Cprogrammer
+ * fixed indentation
+ *
+ * Revision 1.1  2009-03-21 08:43:13+05:30  Cprogrammer
+ * Initial revision
+ *
+ *
+ *  Copyright 2005 Alt-N Technologies, Ltd. 
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License"); 
+ *  you may not use this file except in compliance with the License. 
+ *  You may obtain a copy of the License at 
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0 
+ *
+ *  This code incorporates intellectual property owned by Yahoo! and licensed 
+ *  pursuant to the Yahoo! DomainKeys Patent License Agreement.
+ *
+ *  Unless required by applicable law or agreed to in writing, software 
+ *  distributed under the License is distributed on an "AS IS" BASIS, 
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ *  See the License for the specific language governing permissions and 
+ *  limitations under the License.
+ *
+ */
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+#include "time_t_size.h"
+#define _strnicmp strncasecmp
+#define _stricmp strcasecmp
+#include <string.h>
+#include <ctype.h>
+#include <assert.h>
+#include <vector>
+#include <algorithm>
+#include "dkim.h"
+#include "dkimverify.h"
+#include "dkimdns.h"
+
+#define MAX_SIGNATURES	10		// maximum number of DKIM signatures to process in a message
+
+SignatureInfo::SignatureInfo(bool s)
+{
+	VerifiedBodyCount = 0;
+	UnverifiedBodyCount = 0;
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+	if (m_Hdr_ctx)
+		EVP_MD_CTX_init(m_Hdr_ctx);
+	else
+		m_Hdr_ctx = EVP_MD_CTX_new();
+	if (m_Bdy_ctx)
+		EVP_MD_CTX_init(m_Bdy_ctx);
+	else
+		m_Bdy_ctx = EVP_MD_CTX_new();
+#else
+	EVP_MD_CTX_init(&m_Hdr_ctx);
+	EVP_MD_CTX_init(&m_Bdy_ctx);
+#endif
+	m_pSelector = NULL;
+	Status = DKIM_SUCCESS;
+	m_nHash = 0;
+	EmptyLineCount = 0;
+	m_SaveCanonicalizedData = s;
+}
+
+SignatureInfo::~SignatureInfo()
+{
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+	if (m_Hdr_ctx)
+		EVP_MD_CTX_reset(m_Hdr_ctx);
+	if (m_Bdy_ctx)
+		EVP_MD_CTX_reset(m_Bdy_ctx);
+#else
+	EVP_MD_CTX_cleanup(&m_Hdr_ctx);
+	EVP_MD_CTX_cleanup(&m_Bdy_ctx);
+#endif
+}
+
+inline          bool
+isswsp(char ch)
+{
+	return (ch == ' ' || ch == '\t' || ch == '\r' || ch == '\n');
+}
+
+
+////////////////////////////////////////////////////////////////////////////////
+// 
+// Parse a DKIM tag-list.  Returns true for success
+//
+////////////////////////////////////////////////////////////////////////////////
+bool
+ParseTagValueList(char *tagvaluelist, const char *wanted[], char *values[])
+{
+	char           *s = tagvaluelist;
+
+	for (;;) {
+		// skip whitespace
+		while (isswsp(*s))
+			s++;
+		// if at the end of the string, return success.  note: this allows a list with no entries
+		if (*s == '\0')
+			return true;
+		// get tag name
+		if (!isalpha(*s))
+			return false;
+		char           *tag = s;
+		do {
+			s++;
+		} while (isalnum(*s) || *s == '-');
+		char           *endtag = s;
+		// skip whitespace before equals
+		while (isswsp(*s))
+			s++;
+		// next character must be equals
+		if (*s != '=')
+			return false;
+		s++;
+		// null-terminate tag name
+		*endtag = '\0';
+		// skip whitespace after equals
+		while (isswsp(*s))
+			s++;
+		// get tag value
+		char           *value = s;
+		while (*s != ';' && ((*s == '\t' || *s == '\r' || *s == '\n') || (*s >= ' ' && *s <= '~')))
+			s++;
+		char           *e = s;
+		// make sure the next character is the null terminator (which means we're done) or a semicolon (not done)
+		bool            done = false;
+		if (*s == '\0')
+			done = true;
+		else {
+			if (*s != ';')
+				return false;
+			s++;
+		}
+		// skip backwards past any trailing whitespace
+		while (e > value && isswsp(e[-1]))
+			e--;
+		// null-terminate tag value
+		*e = '\0';
+		// check to see if we want this tag
+		for (unsigned i = 0; wanted[i] != NULL; i++) {
+			if (strcmp(wanted[i], tag) == 0) {
+				// return failure if we already have a value for this tag (duplicates not allowed)
+				if (values[i] != NULL)
+					return false;
+				values[i] = value;
+				break;
+			}
+		}
+		if (done)
+			return true;
+	}
+}
+
+// Convert hex char to value (0-15)
+char
+tohex(char ch)
+{
+	if (ch >= '0' && ch <= '9')
+		return (ch - '0');
+	else
+	if (ch >= 'A' && ch <= 'F')
+		return (ch - 'A' + 10);
+	else
+	if (ch >= 'a' && ch <= 'f')
+		return (ch - 'a' + 10);
+	else {
+		assert(0);
+		return 0;
+	}
+}
+
+
+////////////////////////////////////////////////////////////////////////////////
+// 
+// Decode quoted printable string in-place
+//
+////////////////////////////////////////////////////////////////////////////////
+void
+DecodeQuotedPrintable(char *ptr)
+{
+	char           *s = ptr;
+	while (*s != '\0' && *s != '=')
+		s++;
+	if (*s == '\0')
+		return;
+	char           *d = s;
+	do {
+		if (*s == '=' && isxdigit(s[1]) && isxdigit(s[2])) {
+			*d++ = (tohex(s[1]) << 4) | tohex(s[2]);
+			s += 3;
+		} else {
+			*d++ = *s++;
+		}
+	} while (*s != '\0');
+	*d = '\0';
+}
+
+
+////////////////////////////////////////////////////////////////////////////////
+// 
+// Decode base64 string in-place, returns number of bytes output
+//
+////////////////////////////////////////////////////////////////////////////////
+unsigned
+DecodeBase64(char *ptr)
+{
+	static const char base64_table[256] =
+		{ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1,
+		-1, -1,
+		-1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1,
+		-1, -1,
+		26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1,
+		-1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
+	};
+	unsigned char  *s = (unsigned char *) ptr;
+	unsigned char  *d = (unsigned char *) ptr;
+	unsigned        b64accum = 0;
+	unsigned char   b64shift = 0;
+	while (*s != '\0') {
+		unsigned char value = base64_table[*s++];
+		if ((signed char) value >= 0) {
+			b64accum = (b64accum << 6) | value;
+			b64shift += 6;
+			if (b64shift >= 8) {
+				b64shift -= 8;
+				*d++ = (b64accum >> b64shift);
+			}
+		}
+	}
+	return (char *) d - ptr;
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// 
+// Match a string with a pattern (used for g= value)
+// Supports a single, optional "*" wildcard character.
+//
+////////////////////////////////////////////////////////////////////////////////
+bool
+WildcardMatch(const char *p, const char *s)
+{
+	// special case: An empty "g=" value never matches any addresses
+	if (*p == '\0')
+		return false;
+	const char     *wildcard = strchr(p, '*');
+	if (wildcard == NULL)
+		return strcmp(s, p) == 0;
+	else {
+		unsigned beforewildcardlen = wildcard - p;
+		unsigned afterwildcardlen = strlen(wildcard + 1);
+		unsigned slen = strlen(s);
+		return (slen >= beforewildcardlen + afterwildcardlen) && (strncmp(s, p, beforewildcardlen) == 0)
+			&& strcmp(s + slen - afterwildcardlen, wildcard + 1) == 0;
+	}
+}
+
+
+////////////////////////////////////////////////////////////////////////////////
+// 
+// Parse addresses from a string.  Returns true if at least one address found
+//
+////////////////////////////////////////////////////////////////////////////////
+bool
+ParseAddresses(string str, vector < string > &Addresses)
+{
+	char           *s = (char *) str.c_str();
+	while (*s != '\0') {
+		char           *start = s;
+		char           *from = s;
+		char           *to = s;
+		char           *lt = NULL;	// pointer to less than character (<) which starts the address if found
+		while (*from != '\0') {
+			if (*from == '(') {
+				// skip over comment
+				from++;
+				for (int depth = 1; depth != 0; from++) {
+					if (*from == '\0')
+						break;
+					else
+					if (*from == '(')
+						depth++;
+					else
+					if (*from == ')')
+						depth--;
+					else
+					if (*from == '\\' && from[1] != '\0')
+						from++;
+				}
+			}
+			else
+			if (*from == ')') {
+				// ignore closing parenthesis outside of comment
+				from++;
+			}
+
+			else
+			if (*from == ',' || *from == ';') {
+				// comma/selicolon ends the address
+				from++;
+				break;
+			}
+			else
+			if (*from == ' ' || *from == '\t' || *from == '\r' || *from == '\n') {
+				// ignore whitespace
+				from++;
+			}
+			else
+			if (*from == '"') {
+				// copy the contents of a quoted string
+				from++;
+				while (*from != '\0') {
+					if (*from == '"') {
+						from++;
+						break;
+					}
+					else
+					if (*from == '\\' && from[1] != '\0')
+						*to++ = *from++;
+					*to++ = *from++;
+				}
+			}
+			else
+			if (*from == '\\' && from[1] != '\0') {
+				// copy quoted-pair
+				*to++ = *from++;
+				*to++ = *from++;
+			} else {
+				// copy any other char
+				*to = *from++;
+				// save pointer to '<' for later...
+				if (*to == '<')
+					lt = to;
+				to++;
+			}
+		}
+		*to = '\0';
+		// if there's < > get what's inside
+		if (lt != NULL) {
+			start = lt + 1;
+			char           *gt = strchr(start, '>');
+			if (gt != NULL)
+				*gt = '\0';
+		} else {
+			// look for and strip group name
+			char           *colon = strchr(start, ':');
+			if (colon != NULL) {
+				char           *at = strchr(start, '@');
+				if (at == NULL || colon < at)
+					start = colon + 1;
+			}
+		}
+		if (*start != '\0' && strchr(start, '@') != NULL)
+			Addresses.push_back(start);
+		s = from;
+	}
+	return !Addresses.empty();
+}
+
+CDKIMVerify::CDKIMVerify()
+{
+	m_pfnSelectorCallback = NULL;
+	m_pfnPracticesCallback = NULL;
+	m_HonorBodyLengthTag = false;
+	m_CheckPractices = false;
+	m_Accept3ps = false;
+	m_SubjectIsRequired = true;
+	m_SaveCanonicalizedData = false;
+	m_AllowUnsignedFromHeaders = false;
+}
+
+CDKIMVerify::~CDKIMVerify()
+{
+}
+
+// Init - save the options
+int
+CDKIMVerify::Init(DKIMVerifyOptions *pOptions)
+{
+	int             nRet = CDKIMBase::Init();
+	m_pfnSelectorCallback = pOptions->pfnSelectorCallback;
+	m_pfnPracticesCallback = pOptions->pfnPracticesCallback;
+
+	m_HonorBodyLengthTag = pOptions->nHonorBodyLengthTag != 0;
+	m_CheckPractices = pOptions->nCheckPractices != 0;
+	m_SubjectIsRequired = pOptions->nSubjectRequired != 0;
+	m_Accept3ps = pOptions->nAccept3ps != 0;		//TBS(Luc)
+	m_SaveCanonicalizedData = pOptions->nSaveCanonicalizedData != 0;
+	m_AllowUnsignedFromHeaders = pOptions->nAllowUnsignedFromHeaders != 0;
+	return nRet;
+}
+
+// GetResults - return the pass/fail/neutral verification result
+int
+CDKIMVerify::GetResults(int *sCount, int *sSize)
+{
+	ProcessFinal();
+	unsigned int    SuccessCount = 0;
+	int             TestingFailures = 0;
+	int             RealFailures = 0;
+	list <string>   SuccessfulDomains;	// can contain duplicates
+	/* get the From address's domain if we might need it */
+	string          sFromDomain;
+
+	for (list < SignatureInfo >::iterator i = Signatures.begin(); i != Signatures.end(); ++i) {
+		if (i->Status == DKIM_SUCCESS) {
+			if (!i->BodyHashData.empty()) {
+				// check the body hash
+				unsigned char   md[EVP_MAX_MD_SIZE];
+				unsigned        len = 0;
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+				int             res = EVP_DigestFinal(i->m_Bdy_ctx, md, &len);
+#else
+				int             res = EVP_DigestFinal(&i->m_Bdy_ctx, md, &len);
+#endif
+				if (!res || len != i->BodyHashData.length() || memcmp(i->BodyHashData.data(), md, len) != 0) {
+					// body hash mismatch
+					// if the selector is in testing mode...
+					if (i->m_pSelector->Testing) {
+						i->Status = DKIM_SIGNATURE_BAD_BUT_TESTING;	// todo: make a new error code for this?
+						TestingFailures++;
+					} else {
+						i->Status = DKIM_BODY_HASH_MISMATCH;
+						RealFailures++;
+					}
+					continue;
+				}
+			} else {
+				// hash CRLF separating the body from the signature
+				i->Hash("\r\n", 2);
+			}
+			// check the header hash
+			string          sSignedSig = i->Header;
+			string          sSigValue = sSignedSig.substr(sSignedSig.find(':') + 1);
+			static const char *tags[] = { "b", NULL };
+			char           *values[sizeof (tags) / sizeof (tags[0])] = { NULL };
+			char           *pSigValue = (char *) sSigValue.c_str();
+			if (ParseTagValueList(pSigValue, tags, values) && values[0] != NULL) {
+				sSignedSig.erase(15 + values[0] - pSigValue, strlen(values[0]));
+			}
+			if (i->HeaderCanonicalization == DKIM_CANON_RELAXED) {
+				sSignedSig = RelaxHeader(sSignedSig);
+			} else
+			if (i->HeaderCanonicalization == DKIM_CANON_NOWSP) {
+				RemoveSWSP(sSignedSig);
+				// convert "DKIM-Signature" to lower case
+				sSignedSig.replace(0, 14, "dkim-signature", 14);
+			}
+			i->Hash(sSignedSig.c_str(), sSignedSig.length());
+			assert(i->m_pSelector != NULL);
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+			int             res = EVP_VerifyFinal(i->m_Hdr_ctx, (unsigned char *) i->SignatureData.data(),
+							i->SignatureData.length(), i->m_pSelector->PublicKey);
+#else
+			int             res = EVP_VerifyFinal(&i->m_Hdr_ctx, (unsigned char *) i->SignatureData.data(),
+							i->SignatureData.length(), i->m_pSelector->PublicKey);
+#endif
+			if (res == 1) {
+				if (i->UnverifiedBodyCount == 0)
+					i->Status = DKIM_SUCCESS;
+				else
+					i->Status = DKIM_SUCCESS_BUT_EXTRA;
+				SuccessCount++;
+				SuccessfulDomains.push_back(i->Domain);
+			} else {
+				// if the selector is in testing mode...
+				if (i->m_pSelector->Testing) {
+					i->Status = DKIM_SIGNATURE_BAD_BUT_TESTING;
+					TestingFailures++;
+				} else {
+					i->Status = DKIM_SIGNATURE_BAD;
+					RealFailures++;
+				}
+			}
+		} else
+		if (i->Status == DKIM_SELECTOR_GRANULARITY_MISMATCH 
+			|| i->Status == DKIM_SELECTOR_ALGORITHM_MISMATCH
+			|| i->Status == DKIM_SELECTOR_KEY_REVOKED) {
+			// treat these as failures
+			// todo: maybe see if the selector is in testing mode?
+			RealFailures++;
+		}
+	}
+	if (SuccessCount > 0 || m_CheckPractices) {
+		for (list < string >::iterator i = HeaderList.begin(); i != HeaderList.end(); ++i) {
+			if (_strnicmp(i->c_str(), "From", 4) == 0) {
+				// skip over whitespace between the header name and :
+				const char     *s = i->c_str() + 4;
+				while (*s == ' ' || *s == '\t')
+					s++;
+				if (*s == ':') {
+					vector <string> Addresses;
+					if (ParseAddresses(s + 1, Addresses)) {
+						unsigned atpos = Addresses[0].find('@');
+						sFromDomain = Addresses[0].substr(atpos + 1);
+						break;
+					}
+				}
+			}
+		}
+	}
+	// if a signature from the From domain verified successfully, return success now
+	// without checking the sender signing practices
+	if (SuccessCount > 0 && !sFromDomain.empty()) {
+		for (list < string >::iterator i = SuccessfulDomains.begin(); i != SuccessfulDomains.end(); ++i) {
+			// see if the successful domain is the same as or a parent of the From domain
+			if (i->length() > sFromDomain.length())
+				continue;
+			if (_stricmp(i->c_str(), sFromDomain.c_str() + sFromDomain.length() - i->length()) != 0)
+				continue;
+			if (i->length() == sFromDomain.length() || sFromDomain.c_str()[sFromDomain.length() - i->length() - 1] == '.')
+				return ((SuccessCount == Signatures.size()) ? DKIM_SUCCESS : DKIM_PARTIAL_SUCCESS);
+		}
+	}
+	if (!m_Accept3ps)
+		return DKIM_NEUTRAL;
+	*sCount = SuccessCount;
+	*sSize = Signatures.size();
+	return DKIM_3PS_SIGNATURE;
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// 
+// Hash - update the hash
+//
+////////////////////////////////////////////////////////////////////////////////
+void
+SignatureInfo::Hash(const char *szBuffer, unsigned nBufLength, bool IsBody)
+{
+
+	if (IsBody && BodyLength != -1) {
+		VerifiedBodyCount += nBufLength;
+		if (VerifiedBodyCount > BodyLength) {
+			nBufLength = BodyLength - (VerifiedBodyCount - nBufLength);
+			UnverifiedBodyCount += VerifiedBodyCount - BodyLength;
+			VerifiedBodyCount = BodyLength;
+			if (nBufLength == 0)
+				return;
+		}
+	}
+	if (IsBody && !BodyHashData.empty()) {
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+		EVP_DigestUpdate(m_Bdy_ctx, szBuffer, nBufLength);
+#else
+		EVP_DigestUpdate(&m_Bdy_ctx, szBuffer, nBufLength);
+#endif
+	} else {
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+		EVP_VerifyUpdate(m_Hdr_ctx, szBuffer, nBufLength);
+#else
+		EVP_VerifyUpdate(&m_Hdr_ctx, szBuffer, nBufLength);
+#endif
+	}
+	if (m_SaveCanonicalizedData) {
+		CanonicalizedData.append(szBuffer, nBufLength);
+	}
+}
+
+
+// ProcessHeaders - Look for DKIM-Signatures and start processing them
+int
+CDKIMVerify::ProcessHeaders(void)
+{
+
+	// look for DKIM-Signature header(s)
+	for (list < string >::iterator i = HeaderList.begin(); i != HeaderList.end(); ++i) {
+		if (_strnicmp(i->c_str(), "DKIM-Signature", 14) == 0) {
+			// skip over whitespace between the header name and :
+			const char     *s = i->c_str() + 14;
+			while (*s == ' ' || *s == '\t')
+				s++;
+			if (*s == ':') {
+				// found
+				SignatureInfo   sig(m_SaveCanonicalizedData);
+				sig.Status = ParseDKIMSignature(*i, sig);
+				Signatures.push_back(sig);
+				if (Signatures.size() >= MAX_SIGNATURES)
+					break;
+			}
+		}
+	}
+	if (Signatures.empty())
+		return DKIM_NO_SIGNATURES;
+	bool            ValidSigFound = false;
+	for (list < SignatureInfo >::iterator s = Signatures.begin(); s != Signatures.end(); ++s) {
+		SignatureInfo &sig = *s;
+		if (sig.Status != DKIM_SUCCESS)
+			continue;
+		SelectorInfo &sel = GetSelector(sig.Selector, sig.Domain);
+		sig.m_pSelector = &sel;
+		if (sel.Status != DKIM_SUCCESS) {
+			sig.Status = sel.Status;
+			return (sig.Status);
+		} else {
+			// check the granularity
+			if (!WildcardMatch(sel.Granularity.c_str(), sig.IdentityLocalPart.c_str()))
+				sig.Status = DKIM_SELECTOR_GRANULARITY_MISMATCH;	// this error causes the signature to fail
+			// check the hash algorithm
+#ifdef HAVE_EVP_SHA256
+			if ((sig.m_nHash == DKIM_HASH_SHA1 && !sel.AllowSHA1) || (sig.m_nHash == DKIM_HASH_SHA256 && !sel.AllowSHA256))
+#else
+			if ((sig.m_nHash == DKIM_HASH_SHA1 && !sel.AllowSHA1))
+#endif
+				sig.Status = DKIM_SELECTOR_ALGORITHM_MISMATCH;	// causes signature to fail
+			// check for same domain
+			if (sel.SameDomain && _stricmp(sig.Domain.c_str(), sig.IdentityDomain.c_str()) != 0)
+				sig.Status = DKIM_BAD_SYNTAX;
+		}
+		if (sig.Status != DKIM_SUCCESS)
+			continue;
+		// initialize the hashes
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+#ifdef HAVE_EVP_SHA256
+		if (sig.m_nHash == DKIM_HASH_SHA256) {
+			EVP_VerifyInit(sig.m_Hdr_ctx, EVP_sha256());
+			EVP_DigestInit(sig.m_Bdy_ctx, EVP_sha256());
+		} else {
+			EVP_VerifyInit(sig.m_Hdr_ctx, EVP_sha1());
+			EVP_DigestInit(sig.m_Bdy_ctx, EVP_sha1());
+		}
+#else
+		EVP_VerifyInit(sig.m_Hdr_ctx, EVP_sha1());
+		EVP_DigestInit(sig.m_Bdy_ctx, EVP_sha1());
+#endif
+#else
+#ifdef HAVE_EVP_SHA256
+		if (sig.m_nHash == DKIM_HASH_SHA256) {
+			EVP_VerifyInit(&sig.m_Hdr_ctx, EVP_sha256());
+			EVP_DigestInit(&sig.m_Bdy_ctx, EVP_sha256());
+		} else {
+			EVP_VerifyInit(&sig.m_Hdr_ctx, EVP_sha1());
+			EVP_DigestInit(&sig.m_Bdy_ctx, EVP_sha1());
+		}
+#else
+		EVP_VerifyInit(&sig.m_Hdr_ctx, EVP_sha1());
+		EVP_DigestInit(&sig.m_Bdy_ctx, EVP_sha1());
+#endif
+#endif
+		// compute the hash of the header
+		vector < list < string >::reverse_iterator > used;
+		for (vector < string >::iterator x = sig.SignedHeaders.begin(); x != sig.SignedHeaders.end(); ++x) {
+			list < string >::reverse_iterator i;
+			for (i = HeaderList.rbegin(); i != HeaderList.rend(); ++i) {
+				if (_strnicmp(i->c_str(), x->c_str(), x->length()) == 0) {
+					// skip over whitespace between the header name and :
+					const char     *s = i->c_str() + x->length();
+					while (*s == ' ' || *s == '\t')
+						s++;
+					if (*s == ':' && find(used.begin(), used.end(), i) == used.end())
+						break;
+				}
+			}
+			if (i != HeaderList.rend()) {
+				used.push_back(i);
+				// hash this header
+				if (sig.HeaderCanonicalization == DKIM_CANON_SIMPLE)
+					sig.Hash(i->c_str(), i->length());
+				else
+				if (sig.HeaderCanonicalization == DKIM_CANON_RELAXED) {
+					string          sTemp = RelaxHeader(*i);
+					sig.Hash(sTemp.c_str(), sTemp.length());
+				} else
+				if (sig.HeaderCanonicalization == DKIM_CANON_NOWSP) {
+					string          sTemp = *i;
+					RemoveSWSP(sTemp);
+					// convert characters before ':' to lower case
+					for (char *s = (char *)sTemp.c_str(); *s != '\0' && *s != ':'; s++) {
+						if (*s >= 'A' && *s <= 'Z')
+							*s += 'a' - 'A';
+					}
+					sig.Hash(sTemp.c_str(), sTemp.length());
+				}
+				sig.Hash("\r\n", 2);
+			}
+		}
+		if (sig.BodyHashData.empty()) {
+			// hash CRLF separating headers from body
+			sig.Hash("\r\n", 2);
+		}
+		if (!m_AllowUnsignedFromHeaders) {
+			// make sure the message has no unsigned From headers
+			list<string>::reverse_iterator i;
+			for( i = HeaderList.rbegin(); i != HeaderList.rend(); ++i ) {
+				if( _strnicmp(i->c_str(), "From", 4 ) == 0 ) {
+					// skip over whitespace between the header name and :
+					const char *s = i->c_str()+4;
+					while (*s == ' ' || *s == '\t')
+						s++;
+					if (*s == ':') {
+						if (find(used.begin(), used.end(), i) == used.end()) {
+							// this From header was not signed
+							break;
+						}
+					}
+				}
+			}
+			if (i != HeaderList.rend()) {
+				// treat signature as invalid
+				sig.Status = DKIM_UNSIGNED_FROM;
+				continue;
+			}
+		}
+		ValidSigFound = true;
+	} /*- for (list < SignatureInfo >::iterator s = Signatures.begin(); s != Signatures.end(); ++s) { */
+	if (!ValidSigFound)
+		return DKIM_NO_VALID_SIGNATURES;
+	return DKIM_SUCCESS;
+}
+
+
+////////////////////////////////////////////////////////////////////////////////
+// 
+// Strictly parse an unsigned integer.  Don't allow spaces, negative sign,
+// 0x prefix, etc.  Values greater than 2^32-1 are capped at 2^32-1
+//
+////////////////////////////////////////////////////////////////////////////////
+bool
+ParseUnsigned(const char *s, unsigned long *result)
+{
+	unsigned        temp = 0, last = 0;
+	bool            overflowed = false;
+
+	do {
+		if (*s < '0' || *s > '9')
+			return false;		// returns false for an initial '\0'
+		temp = temp * 10 + (*s - '0');
+		if (temp < last)
+			overflowed = true;
+		last = temp;
+		s++;
+	} while (*s != '\0');
+	if (overflowed)
+		*result = -1;
+	else
+		*result = temp;
+	return true;
+}
+
+
+// ParseDKIMSignature - Parse a DKIM-Signature header field
+int
+CDKIMVerify::ParseDKIMSignature(const string &sHeader, SignatureInfo &sig)
+{
+
+	// save header for later
+	sig.Header = sHeader;
+	string          sValue = sHeader.substr(sHeader.find(':') + 1);
+	static const char *tags[] = { "v", "a", "b", "d", "h", "s", "c", "i", "l", "q", "t", "x", "bh", NULL };
+	char           *values[sizeof (tags) / sizeof (tags[0])] = { NULL };
+	char           *saveptr;
+
+	if (!ParseTagValueList((char *) sValue.c_str(), tags, values))
+		return DKIM_BAD_SYNTAX;
+	// check signature version
+	if (values[0] != NULL) {
+		if (strcmp(values[0], "1") == 0 || strcmp(values[0], "0.5") == 0 || strcmp(values[0], "0.4") == 0
+			|| strcmp(values[0], "0.3") == 0 || strcmp(values[0], "0.2") == 0) {
+			sig.Version = DKIM_SIG_VERSION_02_PLUS;
+		} else {
+		// unknown version
+			return DKIM_STAT_INCOMPAT;
+		}
+	} else {
+		// Note:  DKIM Interop 1 pointed out that v= is now required, but we do
+		// not enforce that in order to verify signatures made by older drafts.
+
+		// prior to 0.2, there MUST NOT have been a v=
+		// (optionally) support these signatures, for backwards compatibility
+		if (true) {
+			sig.Version = DKIM_SIG_VERSION_PRE_02;
+		} else {
+			return DKIM_BAD_SYNTAX;
+		}
+	}
+	// signature MUST have a=, b=, d=, h=, s=
+	if (values[1] == NULL || values[2] == NULL || values[3] == NULL || values[4] == NULL || values[5] == NULL)
+		return DKIM_BAD_SYNTAX;
+	// algorithm can be "rsa-sha1" or "rsa-sha256"
+	if (strcmp(values[1], "rsa-sha1") == 0) {
+		sig.m_nHash = DKIM_HASH_SHA1;
+	}
+#ifdef HAVE_EVP_SHA256
+	else if (strcmp(values[1], "rsa-sha256") == 0) {
+		sig.m_nHash = DKIM_HASH_SHA256;
+	}
+#endif
+	else {
+		return DKIM_BAD_SYNTAX;	// todo: maybe create a new error code for unknown algorithm
+	}
+	// make sure the signature data is not empty
+	unsigned SigDataLen = DecodeBase64(values[2]);
+	if (SigDataLen == 0)
+		return DKIM_BAD_SYNTAX;
+	sig.SignatureData.assign(values[2], SigDataLen);
+	// check for body hash
+	if (values[12] == NULL) {
+		// use the old single hash way for backwards compatibility
+		if (sig.Version != DKIM_SIG_VERSION_PRE_02)
+			return DKIM_BAD_SYNTAX;
+	} else {
+		unsigned BodyHashLen = DecodeBase64(values[12]);
+		if (BodyHashLen == 0)
+			return DKIM_BAD_SYNTAX;
+		sig.BodyHashData.assign(values[12], BodyHashLen);
+	}
+	// domain must not be empty
+	if (*values[3] == '\0')
+		return DKIM_BAD_SYNTAX;
+	sig.Domain = values[3];
+	// signed headers must not be empty (more verification is done later)
+	if (*values[4] == '\0')
+		return DKIM_BAD_SYNTAX;
+	// selector must not be empty
+	if (*values[5] == '\0')
+		return DKIM_BAD_SYNTAX;
+	sig.Selector = values[5];
+	// canonicalization
+	if (values[6] == NULL) {
+		sig.HeaderCanonicalization = sig.BodyCanonicalization = DKIM_CANON_SIMPLE;
+	}
+	else
+	if (sig.Version == DKIM_SIG_VERSION_PRE_02 && strcmp(values[6], "nowsp") == 0) {
+	// for backwards compatibility
+		sig.HeaderCanonicalization = sig.BodyCanonicalization = DKIM_CANON_NOWSP;
+	} else {
+		char           *slash = strchr(values[6], '/');
+		if (slash != NULL)
+			*slash = '\0';
+		if (strcmp(values[6], "simple") == 0)
+			sig.HeaderCanonicalization = DKIM_CANON_SIMPLE;
+		else
+		if (strcmp(values[6], "relaxed") == 0)
+			sig.HeaderCanonicalization = DKIM_CANON_RELAXED;
+		else
+			return DKIM_BAD_SYNTAX;
+		if (slash == NULL || strcmp(slash + 1, "simple") == 0)
+			sig.BodyCanonicalization = DKIM_CANON_SIMPLE;
+		else
+		if (strcmp(slash + 1, "relaxed") == 0)
+			sig.BodyCanonicalization = DKIM_CANON_RELAXED;
+		else
+			return DKIM_BAD_SYNTAX;
+	}
+	// identity
+	if (values[7] == NULL) {
+		sig.IdentityLocalPart.erase();
+		sig.IdentityDomain = sig.Domain;
+	} else {
+		// quoted-printable decode the value
+		DecodeQuotedPrintable(values[7]);
+		// must have a '@' separating the local part from the domain
+		char           *at = strchr(values[7], '@');
+		if (at == NULL)
+			return DKIM_BAD_SYNTAX;
+		*at = '\0';
+		char           *ilocalpart = values[7];
+		char           *idomain = at + 1;
+		// i= domain must be the same as or a subdomain of the d= domain
+		int idomainlen = strlen(idomain);
+		int ddomainlen = strlen(values[3]);
+
+		// todo: maybe create a new error code for invalid identity domain
+		if (idomainlen < ddomainlen)
+			return DKIM_BAD_SYNTAX;
+		if (_stricmp(idomain + idomainlen - ddomainlen, values[3]) != 0)
+			return DKIM_BAD_SYNTAX;
+		if (idomainlen > ddomainlen && idomain[idomainlen - ddomainlen - 1] != '.')
+			return DKIM_BAD_SYNTAX;
+		sig.IdentityLocalPart = ilocalpart;
+		sig.IdentityDomain = idomain;
+	}
+	// body count
+	if (values[8] == NULL || !m_HonorBodyLengthTag) {
+		sig.BodyLength = -1;
+	} else {
+		if (!ParseUnsigned(values[8], (unsigned long *) &sig.BodyLength))
+			return DKIM_BAD_SYNTAX;
+	}
+	// query methods
+	if (values[9] != NULL) {
+
+		// make sure "dns" is in the list
+		bool            HasDNS = false;
+		char           *s = strtok_r(values[9], ":", &saveptr);
+		while (s != NULL) {
+			if (strncmp(s, "dns", 3) == 0 && (s[3] == '\0' || s[3] == '/')) {
+				HasDNS = true;
+				break;
+			}
+			s = strtok_r(NULL, ": \t", &saveptr);
+		}
+		if (!HasDNS)
+			return DKIM_BAD_SYNTAX;	// todo: maybe create a new error code for unknown query method
+	}
+	// signature time
+#if SIZEOF_TIME_T  == 8
+	time_t          SignedTime = -1;
+#else
+	long long       SignedTime = -1;
+#endif
+	if (values[10] != NULL) {
+		if (!ParseUnsigned(values[10], (unsigned long *) &SignedTime))
+			return DKIM_BAD_SYNTAX;
+	}
+	// expiration time
+	if (values[11] == NULL) {
+		sig.ExpireTime = -1;
+	} else {
+		if (!ParseUnsigned(values[11], (unsigned long *) &sig.ExpireTime))
+			return DKIM_BAD_SYNTAX;
+		if (sig.ExpireTime != -1) {
+			// the value of x= MUST be greater than the value of t= if both are present
+#if SIZEOF_TIME_T  == 8
+			if (SignedTime != -1 && sig.ExpireTime <= SignedTime)
+				return DKIM_BAD_SYNTAX;
+#else
+			if (SignedTime != -1 && sig.ExpireTime <= SignedTime)
+				return DKIM_BAD_SYNTAX;
+#endif
+			// todo: if possible, use the received date/time instead of the current time
+			time_t curtime = time(NULL);
+#if SIZEOF_TIME_T  == 8
+			if (curtime > sig.ExpireTime)
+				return DKIM_SIGNATURE_EXPIRED;
+#else
+			if (curtime < 2147483647 && curtime > sig.ExpireTime)
+				return DKIM_SIGNATURE_EXPIRED;
+#endif
+		}
+	}
+	// parse the signed headers list
+	bool            HasFrom = false, HasSubject = false;
+	RemoveSWSP(values[4]);		// header names shouldn't have spaces in them so this should be ok...
+	char           *s = strtok_r(values[4], ":", &saveptr);
+	while (s != NULL) {
+		if (_stricmp(s, "From") == 0)
+			HasFrom = true;
+		else 
+		if (_stricmp(s, "Subject") == 0)
+			HasSubject = true;
+		sig.SignedHeaders.push_back(s);
+		s = strtok_r(NULL, ":", &saveptr);
+	}
+	if (!HasFrom)
+		return DKIM_BAD_SYNTAX;	// todo: maybe create a new error code for h= missing From
+	if (m_SubjectIsRequired && !HasSubject)
+		return DKIM_BAD_SYNTAX;	// todo: maybe create a new error code for h= missing Subject
+	return DKIM_SUCCESS;
+}
+
+
+// ProcessBody - Process message body data
+int
+CDKIMVerify::ProcessBody(char *szBuffer, int nBufLength, bool bEOF)
+{
+	bool            MoreBodyNeeded = false;
+
+	for (list < SignatureInfo >::iterator i = Signatures.begin(); i != Signatures.end(); ++i) {
+		if (i->Status == DKIM_SUCCESS) {
+			if (i->BodyCanonicalization == DKIM_CANON_SIMPLE) {
+				if (nBufLength > 0) {
+					while (i->EmptyLineCount > 0) {
+						i->Hash("\r\n", 2, true);
+						i->EmptyLineCount--;
+					}
+					i->Hash(szBuffer, nBufLength, true);
+					i->Hash("\r\n", 2, true);
+				} else {
+					i->EmptyLineCount++;
+					if (bEOF)
+						i->Hash("\r\n", 2, true);
+				}
+			} else
+			if (i->BodyCanonicalization == DKIM_CANON_RELAXED) {
+				CompressSWSP(szBuffer, nBufLength);
+				if (nBufLength > 0) {
+					while (i->EmptyLineCount > 0) {
+						i->Hash("\r\n", 2, true);
+						i->EmptyLineCount--;
+					}
+					i->Hash(szBuffer, nBufLength, true);
+					if (!bEOF)
+						i->Hash("\r\n", 2, true);
+				} else
+					i->EmptyLineCount++;
+			} else
+			if (i->BodyCanonicalization == DKIM_CANON_NOWSP) {
+				RemoveSWSP(szBuffer, nBufLength);
+				i->Hash(szBuffer, nBufLength, true);
+			}
+			if (i->UnverifiedBodyCount == 0)
+				MoreBodyNeeded = true;
+		}
+	}
+	if (!MoreBodyNeeded)
+		return DKIM_FINISHED_BODY;
+	return DKIM_SUCCESS;
+}
+
+SelectorInfo::SelectorInfo(const string &sSelector, const string &sDomain):Selector(sSelector), Domain(sDomain)
+{
+	AllowSHA1 = true;
+#ifdef HAVE_EVP_SHA256
+	AllowSHA256 = true;
+#else
+	AllowSHA256 = false;
+#endif
+	PublicKey = NULL;
+	Testing = false;
+	SameDomain = false;
+	Status = DKIM_SUCCESS;
+} SelectorInfo::~SelectorInfo()
+{
+	if (PublicKey != NULL) {
+		EVP_PKEY_free(PublicKey);
+	}
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// 
+// Parse - Parse a DKIM selector
+//
+////////////////////////////////////////////////////////////////////////////////
+int
+SelectorInfo::Parse(char *Buffer)
+{
+	static const char *tags[] = { "v", "g", "h", "k", "p", "s", "t", "n", NULL };
+	char           *values[sizeof (tags) / sizeof (tags[0])] = { NULL };
+	char           *saveptr;
+
+	if (!ParseTagValueList(Buffer, tags, values))
+		return DKIM_SELECTOR_INVALID;
+	if (values[0] != NULL) {
+
+		// make sure the version is "DKIM1"
+		if (strcmp(values[0], "DKIM1") != 0)
+			return DKIM_SELECTOR_INVALID;	// todo: maybe create a new error code for unsupported selector version
+		// make sure v= is the first tag in the response    // todo: maybe don't enforce this, it seems unnecessary
+		for (unsigned int j = 1; j < sizeof (values) / sizeof (values[0]); j++) {
+			if (values[j] != NULL && values[j] < values[0]) {
+				return DKIM_SELECTOR_INVALID;
+			}
+		}
+	}
+	// selector MUST have p= tag
+	if (values[4] == NULL)
+		return DKIM_SELECTOR_INVALID;
+	// granularity
+	if (values[1] == NULL)
+		Granularity = "*";
+
+	else
+		Granularity = values[1];
+	// hash algorithm
+	if (values[2] == NULL) {
+		AllowSHA1 = true;
+#ifdef HAVE_EVP_SHA256
+		AllowSHA256 = true;
+#else
+		AllowSHA256 = false;
+#endif
+	} else {
+		// MUST include "sha1" or "sha256"
+		char           *s = strtok_r(values[2], ":", &saveptr);
+		while (s != NULL) {
+			if (strcmp(s, "sha1") == 0)
+				AllowSHA1 = true;
+#ifdef HAVE_EVP_SHA256
+			else if (strcmp(s, "sha256") == 0)
+				AllowSHA256 = true;
+#endif
+			s = strtok_r(NULL, ":", &saveptr);
+		}
+#ifdef HAVE_EVP_SHA256
+		if (!(AllowSHA1 || AllowSHA256))
+#else
+		if (!AllowSHA1)
+#endif
+			return DKIM_SELECTOR_INVALID;	// todo: maybe create a new error code for unsupported hash algorithm
+	}
+	// key type
+	if (values[3] != NULL) {
+		// key type MUST be "rsa"
+		if (strcmp(values[3], "rsa") != 0)
+			return DKIM_SELECTOR_INVALID;
+	}
+	// service type
+	if (values[5] != NULL) {
+		// make sure "*" or "email" is in the list
+		bool            ServiceTypeMatch = false;
+		char           *s = strtok_r(values[5], ":", &saveptr);
+		while (s != NULL) {
+			if (strcmp(s, "*") == 0 || strcmp(s, "email") == 0) {
+				ServiceTypeMatch = true;
+				break;
+			}
+			s = strtok_r(NULL, ":", &saveptr);
+		}
+		if (!ServiceTypeMatch)
+			return DKIM_SELECTOR_INVALID;
+	}
+	// flags
+	if (values[6] != NULL) {
+		char           *s = strtok_r(values[6], ":", &saveptr);
+		while (s != NULL) {
+			if (strcmp(s, "y") == 0) {
+				Testing = true;
+			} else
+			if (strcmp(s, "s") == 0) {
+				SameDomain = true;
+			}
+			s = strtok_r(NULL, ":", &saveptr);
+		}
+	}
+#define M_ToConstUCharPtr(p)       reinterpret_cast<const unsigned char*>(p)          // Cast to unsigned char*
+	/*- public key data */
+	unsigned        PublicKeyLen = DecodeBase64(values[4]);
+	if (PublicKeyLen == 0)
+		return DKIM_SELECTOR_KEY_REVOKED;	// this error causes the signature to fail
+	else {
+		EVP_PKEY       *pkey;
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+		int             rtype;
+#endif
+		const unsigned char  *qq; /*- public key data */
+
+		qq = M_ToConstUCharPtr(values[4]);
+#ifdef DARWIN
+		pkey = d2i_PUBKEY(NULL, (unsigned char **) &qq, PublicKeyLen);
+#else
+		pkey = d2i_PUBKEY(NULL, &qq, PublicKeyLen);
+#endif
+		if (!pkey)
+			return DKIM_SELECTOR_PUBLIC_KEY_INVALID;
+		/*- make sure public key is the correct type (we only support rsa) */
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+		rtype = EVP_PKEY_base_id(pkey);
+		if (rtype == EVP_PKEY_RSA || rtype == EVP_PKEY_RSA2)
+#else
+		if (pkey->type == EVP_PKEY_RSA || pkey->type == EVP_PKEY_RSA2)
+#endif
+			PublicKey = pkey;
+		else {
+			EVP_PKEY_free(pkey);
+			return DKIM_SELECTOR_PUBLIC_KEY_INVALID;
+		}
+	}
+	return DKIM_SUCCESS;
+}
+
+// GetSelector - Get a DKIM selector for a domain
+SelectorInfo &CDKIMVerify::GetSelector(const string &sSelector, const string &sDomain)
+{
+
+	// see if we already have this selector
+	for (list < SelectorInfo >::iterator i = Selectors.begin(); i != Selectors.end(); ++i) {
+		if (_stricmp(i->Selector.c_str(), sSelector.c_str()) == 0 && _stricmp(i->Domain.c_str(), sDomain.c_str()) == 0) {
+			return *i;
+		}
+	}
+	Selectors.push_back(SelectorInfo(sSelector, sDomain));
+	SelectorInfo &sel = Selectors.back();
+	string sFQDN = sSelector;
+	sFQDN += "._domainkey.";
+	sFQDN += sDomain;
+	char            Buffer[4096];
+	int             DNSResult;
+
+	if (m_pfnSelectorCallback)
+		DNSResult = m_pfnSelectorCallback(sFQDN.c_str(), Buffer, sizeof(Buffer));
+	else
+		DNSResult = DNSGetTXT(sFQDN.c_str(), Buffer, sizeof(Buffer));
+	switch (DNSResult) {
+	case DNSRESP_SUCCESS:
+		sel.Status = sel.Parse(Buffer);
+		break;
+	case DNSRESP_TEMP_FAIL:
+		sel.Status = DKIM_SELECTOR_DNS_TEMP_FAILURE;
+		break;
+	case DNSRESP_PERM_FAIL:
+	default:
+		sel.Status = DKIM_SELECTOR_DNS_PERM_FAILURE;
+		break;
+	case DNSRESP_DOMAIN_NAME_TOO_LONG:
+		sel.Status = DKIM_SELECTOR_DOMAIN_NAME_TOO_LONG;
+		break;
+	}
+	return sel;
+}
+
+// GetDetails - Get DKIM verification details (per signature)
+int
+CDKIMVerify::GetDetails(int *nSigCount, DKIMVerifyDetails ** pDetails)
+{
+	Details.clear();
+	for (list < SignatureInfo >::iterator i = Signatures.begin(); i != Signatures.end(); ++i) {
+		DKIMVerifyDetails d;
+		d.szSignature = (char *) i->Header.c_str();
+		d.szSignatureDomain = (char*)i->Domain.c_str();
+		d.szIdentityDomain = (char*)i->IdentityDomain.c_str();
+		d.nResult = i->Status;
+		d.szCanonicalizedData = (char *) i->CanonicalizedData.c_str();
+		Details.push_back(d);
+	} *nSigCount = Details.size();
+	*pDetails = (*nSigCount != 0) ? &Details[0] : NULL;
+	return DKIM_SUCCESS;
+}
+
+char           *DKIM_CALL
+CDKIMVerify::GetDomain(void)
+{
+	static string   sFromDomain;
+	for (list <string>::iterator i = HeaderList.begin(); i != HeaderList.end(); ++i) {
+		if (_strnicmp(i->c_str(), "From", 4) == 0) {
+			// skip over whitespace between the header name and :
+			const char     *s = i->c_str() + 4;
+			while (*s == ' ' || *s == '\t')
+				s++;
+			if (*s == ':') {
+				vector <string> Addresses;
+				if (ParseAddresses(s + 1, Addresses)) {
+					unsigned atpos = Addresses[0].find('@');
+					sFromDomain = Addresses[0].substr(atpos + 1);
+					break;
+				}
+			}
+		}
+	}
+	return ((char *) sFromDomain.c_str());
+}
+
+void
+getversion_dkimverify_cpp()
+{
+	static char    *x = (char *) "$Id: dkimverify.cpp,v 1.18 2017-09-05 11:00:33+05:30 Cprogrammer Exp mbhangui $";
+
+	x++;
+}
diff -Naur netqmail-1.06.org/dkimverify.h netqmail-1.06/dkimverify.h
--- netqmail-1.06.org/dkimverify.h	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/dkimverify.h	2019-05-22 09:29:26.821077830 +0530
@@ -0,0 +1,144 @@
+/*
+ * $Log: dkimverify.h,v $
+ * Revision 1.7  2017-08-31 17:07:45+05:30  Cprogrammer
+ * fixed g++ compiler warning
+ *
+ * Revision 1.6  2017-08-09 22:03:46+05:30  Cprogrammer
+ * initialized EVP_MD_CTX variables
+ *
+ * Revision 1.5  2017-08-08 23:50:47+05:30  Cprogrammer
+ * openssl 1.1.0 port
+ *
+ * Revision 1.4  2015-12-15 16:03:09+05:30  Cprogrammer
+ * use time_t for ExpireTime
+ *
+ * Revision 1.3  2011-06-04 09:37:25+05:30  Cprogrammer
+ * added AllowUnsignedFromHeaders
+ *
+ * Revision 1.2  2009-03-26 15:12:15+05:30  Cprogrammer
+ * changes for ADSP
+ *
+ * Revision 1.1  2009-03-21 08:50:22+05:30  Cprogrammer
+ * Initial revision
+ *
+ *
+ *  Copyright 2005 Alt-N Technologies, Ltd. 
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License"); 
+ *  you may not use this file except in compliance with the License. 
+ *  You may obtain a copy of the License at 
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0 
+ *
+ *  This code incorporates intellectual property owned by Yahoo! and licensed 
+ *  pursuant to the Yahoo! DomainKeys Patent License Agreement.
+ *
+ *  Unless required by applicable law or agreed to in writing, software 
+ *  distributed under the License is distributed on an "AS IS" BASIS, 
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ *  See the License for the specific language governing permissions and 
+ *  limitations under the License.
+ *
+ */
+
+#ifndef DKIMVERIFY_H
+#define DKIMVERIFY_H
+
+#include "dkimbase.h"
+#include "time_t_size.h"
+#include <vector>
+
+#define DKIM_SIG_VERSION_PRE_02			0
+#define DKIM_SIG_VERSION_02_PLUS		1
+
+class           SelectorInfo {
+ public:
+	SelectorInfo(const string & sSelector, const string & sDomain);
+	~SelectorInfo();
+
+	string          Domain;
+	string          Selector;
+	string          Granularity;
+	bool            AllowSHA1;
+	bool            AllowSHA256;
+	EVP_PKEY       *PublicKey;	/* the public key */
+	bool            Testing;
+	bool            SameDomain;
+	int             Status;
+	int             Parse(char *Buffer);
+};
+
+class           SignatureInfo {
+public:
+	SignatureInfo(bool SaveCanonicalizedData);
+	~SignatureInfo();
+
+	void            Hash(const char *szBuffer, unsigned nBufLength, bool IsBody = false);
+	string          Header;
+	unsigned        Version;
+	string          Domain;
+	string          Selector;
+	string          SignatureData;
+	string          BodyHashData;
+	string          IdentityLocalPart;
+	string          IdentityDomain;
+	string          CanonicalizedData;
+	vector <string> SignedHeaders;
+	int             BodyLength;
+	unsigned        HeaderCanonicalization;
+	unsigned        BodyCanonicalization;
+#if SIZEOF_TIME_T  == 8
+	time_t          ExpireTime;
+#else
+	long long       ExpireTime;
+#endif
+	int             VerifiedBodyCount;
+	unsigned        UnverifiedBodyCount;
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+	EVP_MD_CTX     *m_Hdr_ctx = NULL;
+	EVP_MD_CTX     *m_Bdy_ctx = NULL;
+#else
+	EVP_MD_CTX      m_Hdr_ctx;
+	EVP_MD_CTX      m_Bdy_ctx;
+#endif
+	SelectorInfo   *m_pSelector;
+	int             Status;
+	int             m_nHash;	// use one of the DKIM_HASH_xxx constants here
+	unsigned        EmptyLineCount;
+	bool            m_SaveCanonicalizedData;
+};
+
+class           CDKIMVerify:public CDKIMBase {
+public:
+
+	CDKIMVerify();
+	~CDKIMVerify();
+
+	int             Init(DKIMVerifyOptions * pOptions);
+	int             GetResults(int *sCount, int *sSize);
+	int             GetDetails(int *nSigCount, DKIMVerifyDetails ** pDetails);
+	virtual int     ProcessHeaders(void);
+	virtual int     ProcessBody(char *szBuffer, int nBufLength, bool bEOF);
+	const char     *GetPractices() {return Practices.c_str();}
+	char           *DKIM_CALL GetDomain(void);
+
+protected:
+	int             ParseDKIMSignature(const string & sHeader, SignatureInfo & sig);
+	SelectorInfo   &GetSelector(const string & sSelector, const string & sDomain);
+	int             GetADSP(const string &sDomain, int &iADSP);
+	int             GetSSP(const string &sDomain, int &iSSP, bool & bTesting);
+	list <SignatureInfo> Signatures;
+	list <SelectorInfo> Selectors;
+	DKIMDNSCALLBACK m_pfnSelectorCallback;	// selector record callback
+	DKIMDNSCALLBACK m_pfnPracticesCallback;	// SSP record callback
+	bool            m_HonorBodyLengthTag;
+	bool            m_CheckPractices;
+	bool            m_Accept3ps;		//TBS(Luc) : accept 3rd party signature(s)
+	bool            m_SubjectIsRequired;
+	bool            m_SaveCanonicalizedData;
+	bool            m_AllowUnsignedFromHeaders;
+	vector <DKIMVerifyDetails> Details;
+	string          Practices;
+};
+
+#endif	/*- DKIMVERIFY_H */
diff -Naur netqmail-1.06.org/dknewkey.sh netqmail-1.06/dknewkey.sh
--- netqmail-1.06.org/dknewkey.sh	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/dknewkey.sh	2018-04-03 17:28:43.662318518 +0530
@@ -0,0 +1,27 @@
+#
+# $Log: dknewkey.sh,v $
+# Revision 1.4  2010-05-16 19:59:48+05:30  Cprogrammer
+# fix for Mac OS X
+#
+# Revision 1.3  2004-11-02 20:48:31+05:30  Cprogrammer
+# fixed error when dknewkey was called without arguments
+#
+# Revision 1.2  2004-10-21 21:54:25+05:30  Cprogrammer
+# create public key file
+#
+# Revision 1.1  2004-10-20 20:40:56+05:30  Cprogrammer
+# Initial revision
+#
+#
+if [ $# -lt 1 ] ; then
+	echo "USAGE: dknewkey keyfile [bits]"
+	exit 1
+fi
+BITS=384
+if test -n "$2"; then BITS=$2; fi
+
+openssl genrsa -out $1 $BITS 2>/dev/null
+openssl rsa -in $1 -out /tmp/dknewkey.$$ -pubout -outform PEM 2>/dev/null
+printf "%s._domainkey\tIN\tTXT\t\"k=rsa; p=%s\"\n" `basename $1` `grep -v ^-- /tmp/dknewkey.$$ | tr -d '\n'` > $1.pub
+/bin/cat $1.pub
+/bin/rm -f /tmp/dknewkey.$$
diff -Naur netqmail-1.06.org/dktest.9 netqmail-1.06/dktest.9
--- netqmail-1.06.org/dktest.9	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/dktest.9	2018-04-03 17:28:43.663318538 +0530
@@ -0,0 +1,86 @@
+.TH dktest 8
+.SH NAME
+dktest \- exercise the domainkeys library
+.SH SYNOPSIS
+.B dktest
+.I opts
+
+.I opts
+is a series of getopt-style options.
+
+.SH DESCRIPTION
+.B dktest
+exercises the domainkeys library. Both signing and verification merely print out the DK header.
+They do not keep a copy of the input file. You will need to do something like this:
+
+.EX
+ (./dktest -s QMAILHOME/control/domainkeys/dog </tmp/testmsg; cat /tmp/testmsg)\
+ | ./dktest -v
+.EE
+
+Here are the options:
+.IP \[bu] 2
+-s
+\fIkey\fR: Sign. 
+.I key
+is a path to a file containing a PEM-format private key. The base name of
+the file is  used  as  the  selector. Reads the email message on stdin. Prints the
+.B DomainKey-Signature
+header.
+
+.IP \[bu]
+-v: Verify. Verifies the email on stdin. Exits with a non-zero exit code and a message to
+stderr if there was a problem with the signature. Always prints a
+.B DomainKey-Status:
+header to stdout. This option requires the \fBs\fR._domainkey.\fBd\fR txt record in
+dns (public key). Here \fBs\fR is the selector and \fBd\fR is the domain
+.EX
+
+ Comment: DomainKeys? See http://antispam.yahoo.com/domainkeys
+ DomainKey-Signature: a=rsa-sha1; q=dns; c=simple;
+  s=dog; d=indimail.org; 
+  b=CndyNmOBqXD+d6qLGVjVua/oDJetLzAKAh3JoId93GmWRg1Y40DUdvZZhw8tTIoZ;
+.EE
+
+.IP \[bu]
+-c \fI[simple|nofws]\fR Canonicalization.
+Defaults to simple.
+
+.IP \[bu]
+-t \fIn\fR: Test.
+.I n
+is a number indicating which internal test is being performed. The meanings of the numbers
+are documented in the source code.
+
+.IP \[bu]
+-d \fIdns\fR Test dns record
+
+.IP \[bu]
+-b \fIn\fR: Buffer size.
+.I n
+is a number which forces the buffer size. Only needed for testing.
+
+.IP \[bu]
+-D \fIdkdomain\fR: set d= tag.
+.I dkdomain
+is set as the value for d= tag
+
+.IP \[bu]
+-h:
+include h= tag when signing
+
+.IP \[bu]
+-r:
+only include unique headers in the signature generation, implies -h
+
+.IP \[bu]
+-T:
+Generate DomainKey-Trace: header, shows Diff header if Verifying.
+
+.SH "SEE ALSO"
+dkim(8),
+qmail-dk(8),
+qmail-dkim(8),
+dknewkey(8),
+rfc-4870(5),
+rfc-4871(5)
diff -Naur netqmail-1.06.org/dktest.c netqmail-1.06/dktest.c
--- netqmail-1.06.org/dktest.c	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/dktest.c	2018-04-03 17:28:43.663318538 +0530
@@ -0,0 +1,431 @@
+/*
+ * $Log: dktest.c,v $
+ * Revision 1.16  2013-08-17 16:01:08+05:30  Cprogrammer
+ * added case for duplicate DomainKey-Signature header
+ *
+ * Revision 1.15  2011-07-29 09:28:09+05:30  Cprogrammer
+ * fixed gcc 4.6 warnings
+ *
+ * Revision 1.14  2011-07-22 14:39:27+05:30  Cprogrammer
+ * added -D option to specify d= tag
+ *
+ * Revision 1.13  2009-12-10 15:04:09+05:30  Cprogrammer
+ * exit with DK_STAT
+ *
+ * Revision 1.12  2009-04-20 22:20:55+05:30  Cprogrammer
+ * fixed compilation warning
+ *
+ * Revision 1.11  2009-04-16 22:39:33+05:30  Cprogrammer
+ * assign from = dk_from()
+ *
+ * Revision 1.10  2009-04-05 12:51:22+05:30  Cprogrammer
+ * added preprocessor warning
+ *
+ * Revision 1.9  2009-03-14 16:28:22+05:30  Cprogrammer
+ * Fixed dktest.c to check for DK_STAT_GRANULARITY
+ *
+ * Revision 1.8  2009-03-14 08:50:41+05:30  Cprogrammer
+ * Added -h option to dktest to add h= tag when signing
+ * Added -r option to dktest to enable ignoring duplicate headers when signing (implies -h)
+ * Added -T option to dktest to enable generation of trace headers
+ * Added -d option to fetch dns text record for domainkey
+ *
+ * Revision 1.7  2005-08-23 17:15:02+05:30  Cprogrammer
+ * gcc 4 compliance
+ *
+ * Revision 1.6  2005-04-25 22:52:45+05:30  Cprogrammer
+ * removed printing of comments
+ *
+ * Revision 1.5  2005-04-01 19:54:27+05:30  Cprogrammer
+ * libdomainkeys-0.64
+ *
+ * Revision 1.4  2004-10-25 14:54:02+05:30  Cprogrammer
+ * libdomainkeys-0.63
+ *
+ * Revision 1.3  2004-10-22 20:24:18+05:30  Cprogrammer
+ * added RCS id
+ *
+ * Revision 1.2  2004-10-20 20:01:58+05:30  Cprogrammer
+ * upgrade to libdomainkeys-0.62
+ *
+ * Revision 1.1  2004-09-22 23:30:32+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
+#include <stdio.h>
+#include <string.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include "domainkeys.h"
+
+#ifdef DOMAIN_KEYS
+int             optf = 0;
+
+void
+errorout(DK *dk, DK_STAT st)
+{
+	if (optf && dk)
+		fprintf(stderr, "%s(%d):", dk_errfile(dk), dk_errline(dk));
+	fprintf(stderr, "dktest: %s\n", DK_STAT_to_string(st));
+	exit(st);
+}
+
+int
+main(int argc, char *argv[])
+{
+	char            inbuf[1024];
+	char            advice[2048];
+	char            trace_count[BUFSIZ];
+	size_t          inlen;
+	size_t          advicelen = sizeof(advice);
+	DK             *dk;
+	DK_LIB         *dklib;
+	DK_STAT         st, dkt_st;
+	signed char     ch;
+	int             opts = 0, optv = 0, optt = 0, opth = 0, optr = 0, optT = 0,
+					optc = DK_CANON_SIMPLE;
+	char           *canon = "simple";
+	char           *keyfn  = 0, *selector  = 0;
+	char           *txtrec, *cp, *from, *dkdomain;
+	char            privkey[2048];
+	FILE           *privkeyf = 0;
+	size_t          privkeylen;
+	DK_FLAGS        dkf = 0;
+	int             i;
+	DK_TRACE_TYPE   dk_trace_tag[4] = {
+		DKT_RAW_HEADER,
+		DKT_CANON_HEADER,
+		DKT_RAW_BODY,
+		DKT_CANON_BODY
+	};
+
+	for (dkdomain = (char *) 0;;)
+	{
+		ch = getopt(argc, argv, "s:vt:fb:c:hrTd:D:");
+		if (ch == -1)
+			break;
+		switch (ch)
+		{
+		case 'D':
+			dkdomain = optarg;
+			break;
+		case 'd': /*- optD */
+			txtrec = dns_text(optarg);
+			cp = txtrec;
+			printf("%ld\n", (long) strlen(cp));
+			while (*cp) {
+				printf("%02x ", *cp++);
+				if ((cp - txtrec) % 16 == 0)
+					printf("\n");
+			}
+			printf("\n");
+			if (!strcmp(txtrec, "e=perm;"))
+				exit(0);
+			if (!strcmp(txtrec, "e=temp;"))
+				exit(0);
+			free(txtrec);
+			return (0);
+			break;
+		case 'T':
+			optT = 1;
+			break;
+		case 'v':
+			optv = 1;
+			break;
+		case 'f':
+			optf = 1;
+			break;
+		case 'r':
+			optr = 1;
+			opth = 1;
+			break;
+		case 's':
+			opts = 1;
+			keyfn = optarg;
+			selector = optarg;
+			while (*optarg)
+			{
+				if (*optarg == '/')
+					selector = optarg + 1;
+				optarg++;
+			}
+			break;
+		case 't':
+			optt = atoi(optarg);
+			break;
+		case 'h':
+			opth = 1;
+			break;
+		case 'b':
+			advicelen = atoi(optarg);
+			if (advicelen > sizeof(advice))
+				advicelen = sizeof(advice);
+			break;
+		case 'c':
+			if (!strcmp(optarg, "simple"))
+				optc = DK_CANON_SIMPLE, canon = "simple";
+			else
+			if (!strcmp(optarg, "nofws"))
+				optc = DK_CANON_NOFWS, canon = "nofws";
+			else
+			{
+				fprintf(stderr, "dktest: unrecognized canonicalization.\n");
+				exit(1);
+			}
+		}
+	}
+	if (opts)
+	{
+		if (!(privkeyf = fopen(keyfn, "r"))) /*- TC10 */
+		{
+			fprintf(stderr, "dktest: can't open private key file %s\n", keyfn);
+			exit(1);
+		}
+		if ((privkeylen = fread(privkey, 1, sizeof(privkey), privkeyf)) == sizeof(privkey))
+					/*- TC9 */
+		{					
+			fprintf(stderr, "dktest: private key buffer isn't big enough, use a smaller private key or recompile.\n");
+			exit(1);
+		}
+		privkey[privkeylen] = '\0';
+		fclose(privkeyf);
+	}
+	if (optt == 1)
+		errorout(NULL, 0);		/*- TC2 */
+	if (optt == 2)
+		errorout(NULL, 32767);	/*- TC3 */
+	dklib = dk_init(&st);
+	if (st != DK_STAT_OK)
+		errorout(NULL, st);
+	if (!dklib)
+		errorout(NULL, 200);
+	if (optv)
+	{
+		dk = dk_verify(dklib, &st);
+		if (st != DK_STAT_OK)
+			errorout(dk, st);
+	} else
+	if (opts)
+	{
+		dk = dk_sign(dklib, &st, optc);
+		if (st != DK_STAT_OK)
+			errorout(dk, st);
+		if (optr)
+			st = dk_setopts(dk, DKOPT_RDUPE);
+		if (st != DK_STAT_OK)
+			errorout(dk, st);
+	} else
+	{
+		fprintf(stderr, "dktest: [-f] [-b#] [-c nofws|simple] [-v|-s selector] [-h] [-t#] [-r] [-T][-d dnsrecord]\n"); /* TC1 */
+		exit(1);
+	}
+	if (optT) /*- trace */
+	{
+		st = dk_setopts(dk, (DKOPT_TRACE_h|DKOPT_TRACE_H|DKOPT_TRACE_b|DKOPT_TRACE_B));
+		if (st != DK_STAT_OK)
+			errorout(dk, st);
+	}
+	if (optt == 3)
+		errorout(dk, dk_message(NULL, (const unsigned char *) "", 1));	/*- TC4 */
+	if (optt == 4)
+		errorout(dk, dk_message(dk, (const unsigned char *) NULL, 1));	/*- TC5 */
+	if (optt == 5)
+		errorout(dk, dk_message(dk, (const unsigned char *) "", 0));	/*- TC6 */
+	if (optt >= 100 && optt <= 140)
+		errorout(dk, optt - 100);	/*- TC53 */
+	st = DK_STAT_OK;
+	/* 
+	 * This should work with DOS or UNIX text files -Tim
+	 * Reduced calls to dk_message, in lib dkhash called for EVERY char
+	 * DOS formatted input (CRLF line terminated) will have fewer calls
+	 * to dk_message() than UNIX (LF line terminated) input.
+	 */
+	while (1)
+	{
+		char           *inp;
+
+		inlen = fread(inbuf, 1, sizeof(inbuf), stdin);
+		inp = inbuf;
+		while (inlen--)
+		{
+			if (*inp == '\n')
+				st = dk_message(dk, (const unsigned char *) "\r\n", 2);
+			else
+				st = dk_message(dk, (const unsigned char *) inp, 1);
+			if (st != DK_STAT_OK)
+				break;  //stop looping if there was an error
+			inp++;
+		}
+		if ((inp-inbuf < sizeof(inbuf)) || (st != DK_STAT_OK))
+			break; /*- if we read in the entire message or encountered an error */
+	}
+	if (st == DK_STAT_OK)
+	{
+		if (optt == 10)
+			st = dk_end(dk, &dkf);
+		else
+			st = dk_eom(dk, &dkf);
+	}
+	if (optT)
+	{
+		printf("DomainKey-Trace: U=http://domainkeys.sourceforge.net; V=TESTING;\n");
+		for (i = 0; i < 4; i++)
+		{
+			if (dk_get_trace(dk, dk_trace_tag[i], trace_count, sizeof (trace_count)) != DK_STAT_OK)
+			{
+				fprintf(stderr, "dktest: Not enough resources for trace buffer output\n");
+				break;
+			} else
+				printf("  %s\n", trace_count);
+		}
+		if (optv)
+		{
+			printf("DomainKey-Trace-Diff:\n");
+			for (i = 0; i < 4; i++) {
+				dkt_st = dk_compare_trace(dk,dk_trace_tag[i],trace_count,sizeof(trace_count));
+				if (dkt_st == DK_STAT_NOSIG)
+				{
+					printf("  No DK-Trace: header found\n");
+					break;
+				} else
+				if (dkt_st != DK_STAT_OK)
+				{
+					fprintf(stderr,"dktest: Not enough resources for trace buffer output\n");
+					break;
+				} else
+					printf("  %s\n",trace_count);
+			}
+		}
+	}
+	if ((optt == 6 || optt == 10) && optv)
+	{
+		printf("flags: ");
+		if (dkf & DK_FLAG_SET)
+			printf("+");
+		if (dkf & DK_FLAG_TESTING)
+			printf("t");
+		if (dkf & DK_FLAG_SIGNSALL)
+			printf("s"); /*- wont be set if dk_end() is sucessful */
+		if (dkf & DK_FLAG_G)
+			printf("g");
+		printf("\n");
+	} else
+	if (optt == 6 && opts)
+		errorout(dk, dk_getsig(dk, NULL, NULL, advicelen));	/*- TC14 */
+	else
+	if (optt == 7)
+	{
+		from = dk_from(dk);
+		if (!from)
+			from = "";
+		printf("%s\n", from);	/*- TC14-1, TC14-2 */
+	} else
+	if (optt == 11)
+	{
+		from = dk_address(dk);
+		printf("%s\n", from);	/*- TC14-3, TC14-4 */
+	} else
+	if (optt == 9)
+	{
+		char           *s;
+
+		s = malloc(dk_headers(dk, NULL));
+		dk_headers(dk, s);
+		printf("%s\n", s);
+		free(s);
+	} else
+	if (optt == 8 && opts)
+	{
+		dk_getsig(dk, privkey, (unsigned char *) advice, advicelen);
+		if (st != DK_STAT_OK)
+			errorout(dk, st);
+		printf("%d %d\n", (int) dk_siglen(privkey), (int) strlen(advice)); /*- TC39 */
+	} else
+	if (opts)
+	{
+		if (st != DK_STAT_OK)
+			errorout(dk, st);
+		st = dk_getsig(dk, privkey, (unsigned char *) advice, advicelen);
+		if (st != DK_STAT_OK)
+			errorout(dk, st);
+#if 0
+		printf("Comment: DomainKeys? See http://antispam.yahoo.com/domainkeys\n");
+#endif
+		from = dk_from(dk);
+		printf("DomainKey-Signature: a=rsa-sha1; q=dns; c=%s;\n"
+			"  s=%s; d=%s;\n" "  b=%s;\n", canon, selector, dkdomain ? dkdomain : from, advice);
+		if (opth == 1)
+		{
+			if (dk_headers(dk, NULL) < sizeof(inbuf))
+			{
+				dk_headers(dk, inbuf);
+				printf("  h=%s;\n", inbuf);
+			}
+		}
+	} else
+	if (optv)
+	{
+		char           *status = 0;
+
+		switch (st)
+		{
+		case DK_STAT_OK:
+			status = "good";
+			break;
+		case DK_STAT_BADSIG:
+			status = "bad";
+			break;
+		case DK_STAT_NOSIG:
+			status = "no signature";
+			break;
+		case DK_STAT_NOKEY:
+		case DK_STAT_CANTVRFY:
+			status = "no key";
+			break;
+		case DK_STAT_BADKEY:
+			status = "bad key";
+			break;
+		case DK_STAT_INTERNAL:
+		case DK_STAT_ARGS:
+		case DK_STAT_SYNTAX:
+			status = "bad format";
+			break;
+		case DK_STAT_NORESOURCE:
+			status = "no resources";
+			break;
+		case DK_STAT_REVOKED:
+			status = "revoked";
+			break;
+		case DK_STAT_GRANULARITY:
+			status = "bad sender (g=)";
+			break;
+		}
+#if 0
+		printf("Comment: DomainKeys? See http://antispam.yahoo.com/domainkeys\n");
+#endif
+		printf("DomainKey-Status: %s\n", status);
+		rewind(stdin);
+	}
+	if (st != DK_STAT_OK)
+		errorout(dk, st);
+	dk_free(dk, 1);//cleanup properly (not really necessary for single run process)
+	dk_shutdown(dklib);
+	return(0);
+}
+#else
+#warning "not compiled with -DDOMAIN_KEYS"
+int
+main(int argc, char *argv[])
+{
+	fprintf(stderr, "not compiled with -DDOMAIN_KEYS\n");
+	return(1);
+}
+#endif
+
+void
+getversion_dktest_c()
+{
+	static char    *x = "$Id: dktest.c,v 1.16 2013-08-17 16:01:08+05:30 Cprogrammer Exp mbhangui $";
+
+	x++;
+}
diff -Naur netqmail-1.06.org/dktrace.c netqmail-1.06/dktrace.c
--- netqmail-1.06.org/dktrace.c	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/dktrace.c	2018-04-03 17:28:43.663318538 +0530
@@ -0,0 +1,277 @@
+/*
+ * $Log: dktrace.c,v $
+ * Revision 1.1  2009-03-14 09:00:52+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
+/*
+ * $Id: dktrace.c,v 1.1 2009-03-14 09:00:52+05:30 Cprogrammer Stab mbhangui $ 
+ */
+
+#ifdef DOMAIN_KEYS
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include "str.h"
+#include "case.h"
+#include "dktrace.h"
+
+#define strncasecmp(x,y,z) case_diffb((x), (z), (y))
+
+static int     *
+getPointer(DK_TRACE * dkp, DK_TRACE_TYPE type)
+{
+	switch (type) {
+	case DKT_RAW_HEADER:
+		return dkp->ccounts_h;
+	case DKT_CANON_HEADER:
+		return dkp->ccounts_H;
+	case DKT_RAW_BODY:
+		return dkp->ccounts_b;
+	case DKT_CANON_BODY:
+		return dkp->ccounts_B;
+	default:
+		return 0;
+	}
+}
+
+//Modified version of dkparselist()
+static int
+dkt_parselist(char *list, char *letters, char *values[])
+{
+	char            key;
+	int             i;
+	char           *value;
+
+	/*- start with all args unset */
+	for (i = 0; letters[i]; i++) {
+		values[i] = NULL;
+	}
+	key = 0;
+	while (*list) {
+		if ((*list == ' ') || (*list == '\t') || (*list == '\r') || (*list == '\n')) {
+			list++;
+		} else if (*list == '=') {
+			char           *ws;
+
+			++list;
+			value = list;
+			ws = list;
+			while (1) {
+			/*
+			 * copy up to null or semicolon, deleting whitespace as we go 
+			 */
+				*ws = *list;
+				if ((*list == ' ') || (*list == '\t') || (*list == '\r') || (*list == '\n')) {
+				/*
+				 * ignore 
+				 */
+				} else if (!*list) {
+					break;
+				} else if (*list == ';') {
+					*ws = '\0';
+					list++;
+					break;
+				} else {
+					ws++;
+				}
+				list++;
+			}
+			if (!key) {
+				return 0;		//No key
+			}
+		/*
+		 * if we find a matching letter, remember the value 
+		 */
+			for (i = 0; letters[i]; i++) {
+				if (key == letters[i]) {
+					if (values[i]) {
+						return 0;	/* no duplicate keys. TC23 */
+					}
+					values[i] = value;
+				}
+			}
+			key = 0;
+		} else {
+			if (key) {
+				return 0;		/* they already gave us a key. TC24 */
+			}
+			key = *list++;
+		}
+	}
+	return 1;
+}
+
+extern void
+dkt_add(DK_TRACE * dkp, DK_TRACE_TYPE type, const unsigned char *data, int dataLength)
+{
+	int            *ip;
+	ip = getPointer(dkp, type);
+	if (!ip)
+		return;
+
+	while (dataLength-- > 0)
+		ip[*data++]++;
+}
+
+//useful for building table directly
+extern void
+dkt_quickadd(DK_TRACE * dkp, DK_TRACE_TYPE type, int index, int count)
+{
+	int            *ip;
+	ip = getPointer(dkp, type);
+	if (!ip)
+		return;
+	if ((index < 256) && (index >= 0))
+		ip[index] = ip[index] + count;
+}
+
+//reverse of dkt_quickadd, reads data from table and returns the int count
+extern int
+dkt_getcount(DK_TRACE * dkp, DK_TRACE_TYPE type, int index, int count)
+{
+	int            *ip;
+	ip = getPointer(dkp, type);
+	if (!ip)
+		return 0;
+	if ((index < 256) && (index >= 0))
+		return ip[index];
+	return 0;
+}
+
+
+/*
+ * Fills in DK_TRACE *diff_table with the differences between
+ * *dka (before) and *dkb (after), (after - before = diff)
+ */
+extern int
+dkt_diff(DK_TRACE * dka, DK_TRACE * dkb, DK_TRACE_TYPE type, DK_TRACE * diff_table)
+{
+	int            *inputa, *inputb, *output;
+	int             i;
+	inputa = getPointer(dka, type);
+	if (!inputa)
+		return 0;
+	inputb = getPointer(dkb, type);
+	if (!inputb)
+		return 0;
+	output = getPointer(diff_table, type);
+	if (!output)
+		return 0;
+
+	for (i = 0; i < 256; i++) {
+		output[i] = (inputb[i] - inputa[i]);
+	}
+	return 1;
+}
+
+/*
+ * Generate the tag=value; data for a particular trace type
+ * returns length of generated C string including ending '\0'
+ */
+
+extern int
+dkt_generate(DK_TRACE * dkp, DK_TRACE_TYPE type, char *buffer, int maxBufferSize)
+{
+	int            *ip;
+	char           *cp;
+	int             ix;
+	int             len;
+	int             highest;
+
+	if (maxBufferSize < 20)
+		return 0;				/* Getting too close, you lose */
+	cp = buffer;
+	ip = getPointer(dkp, type);
+	if (!ip)
+		return 0;
+	*buffer++ = (char) type;
+	--maxBufferSize;
+	*buffer++ = '=';
+	--maxBufferSize;
+
+/*
+ * Only produce as many entries as needed, rather than the full 256 
+ */
+
+	for (ix = 0, highest = 0; ix < 256; ++ix) {
+		if (ip[ix] != 0)
+			highest = ix;
+	}
+
+	for (ix = 0; ix <= highest; ++ix) {
+		if (ip[ix] != 0) {
+			len = snprintf(buffer, maxBufferSize, "%d", ip[ix]);
+			buffer += len;
+			maxBufferSize -= len;
+		}
+		if (maxBufferSize < 10)
+			return 0;			/* Getting too close, you lose */
+		*buffer++ = ':';
+		--maxBufferSize;
+	}
+	/*
+	 * Finish up the tag with a semi-colon and turn it into a C string 
+	 */
+	--buffer;
+	*buffer++ = ';'; //replace last ':'
+	*buffer++ = '\0';
+	--maxBufferSize;
+	return buffer - cp;
+}
+
+//converts a header to to a DK_TRACE table
+extern int
+dkt_hdrtotrace(char *ptr, DK_TRACE * store)
+{
+	char           *values[4];	// hHbB
+	int             idx;
+	int             delim_count;
+	char           *sptr, *eptr;
+	DK_TRACE_TYPE   dk_trace_tag[4] = {
+		DKT_RAW_HEADER,
+		DKT_CANON_HEADER,
+		DKT_RAW_BODY,
+		DKT_CANON_BODY
+	};
+	int            *ip;
+
+	if ((strncasecmp(ptr, "DomainKey-Trace:", 16)) || !store || (!dkt_parselist(ptr + 16, "hHbB", values))) {
+		return 0;
+	}
+	for (idx = 0; idx < 4; idx++) {
+		if (!values[idx])
+			continue;
+		ip = getPointer(store, dk_trace_tag[idx]);
+		if (!ip)
+			return 0;
+		sptr = values[idx];
+		for (delim_count = 0; ((delim_count < 256) && (*sptr != '\0')); sptr++) {
+			if (*sptr == ':') {
+				delim_count++;
+				continue;
+			}
+		//find the end of the int
+			for (eptr = sptr + 1; ((*eptr != ':') && (*eptr != '\0')); eptr++);
+			if (*eptr == '\0') //if end of values for key finish up
+			{
+				ip[delim_count] = atoi(sptr);
+				break;
+			}
+			*eptr = '\0';
+			ip[delim_count] = atoi(sptr);
+			delim_count++;
+			sptr = eptr;
+		}
+	}
+	return 1;
+}
+#endif
+
+void
+getversion_dktrace_c()
+{
+	static char    *x = "$Id: dktrace.c,v 1.1 2009-03-14 09:00:52+05:30 Cprogrammer Stab mbhangui $";
+
+	x++;
+}
diff -Naur netqmail-1.06.org/dktrace.h netqmail-1.06/dktrace.h
--- netqmail-1.06.org/dktrace.h	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/dktrace.h	2018-04-03 17:28:43.663318538 +0530
@@ -0,0 +1,26 @@
+/* $Id: dktrace.h,v 1.3 2005/06/27 18:47:57 ted46045 Exp $ */
+
+#ifndef _DK_TRACE_H
+#define _DK_TRACE_H
+
+typedef struct {
+  int ccounts_h[256];
+  int ccounts_H[256];
+  int ccounts_b[256];
+  int ccounts_B[256];
+} DK_TRACE;
+
+typedef enum { DKT_RAW_HEADER='h', DKT_CANON_HEADER='H',
+         DKT_RAW_BODY='b', DKT_CANON_BODY='B' } DK_TRACE_TYPE;
+
+#define dkt_init(s) memset(s,0,sizeof(DK_TRACE))
+
+//extern void   dkt_init(DK_TRACE *dkp);
+extern void   dkt_add(DK_TRACE *dkp, DK_TRACE_TYPE type, const unsigned char *data, int dataLength);
+extern int    dkt_diff(DK_TRACE *dka, DK_TRACE *dkb, DK_TRACE_TYPE type, DK_TRACE *table);
+extern void   dkt_quickadd(DK_TRACE *dkp, DK_TRACE_TYPE type, int index, int count);
+extern int    dkt_getcount(DK_TRACE *dkp, DK_TRACE_TYPE type, int index, int count);
+extern int    dkt_generate(DK_TRACE *dkp, DK_TRACE_TYPE type, char *buffer, int maxBufferSize);
+extern int    dkt_hdrtotrace(char *ptr, DK_TRACE *store);
+
+#endif
diff -Naur netqmail-1.06.org/dns.c netqmail-1.06/dns.c
--- netqmail-1.06.org/dns.c	2007-12-01 01:52:54.000000000 +0530
+++ netqmail-1.06/dns.c	2018-04-03 17:28:43.663318538 +0530
@@ -1,4 +1,3 @@
-#include <stdio.h>
 #include <netdb.h>
 #include <sys/types.h>
 #include <netinet/in.h>
@@ -19,10 +18,12 @@
 static unsigned short getshort(c) unsigned char *c;
 { unsigned short u; u = c[0]; return (u << 8) + c[1]; }
 
-static union { HEADER hdr; unsigned char buf[PACKETSZ]; } response;
+static struct { unsigned char *buf; } response;
+static int responsebuflen = 0;
 static int responselen;
 static unsigned char *responseend;
 static unsigned char *responsepos;
+static u_long saveresoptions;
 
 static int numanswers;
 static char name[MAXDNAME];
@@ -43,18 +44,33 @@
  errno = 0;
  if (!stralloc_copy(&glue,domain)) return DNS_MEM;
  if (!stralloc_0(&glue)) return DNS_MEM;
- responselen = lookup(glue.s,C_IN,type,response.buf,sizeof(response));
+ if (!responsebuflen)
+  if (response.buf = (unsigned char *)alloc(PACKETSZ+1))
+   responsebuflen = PACKETSZ+1;
+  else return DNS_MEM;
+
+ responselen = lookup(glue.s,C_IN,type,response.buf,responsebuflen);
+ if ((responselen >= responsebuflen) ||
+     (responselen > 0 && (((HEADER *)response.buf)->tc)))
+  {
+   if (responsebuflen < 65536)
+    if (alloc_re(&response.buf, responsebuflen, 65536))
+     responsebuflen = 65536;
+    else return DNS_MEM;
+    saveresoptions = _res.options;
+    _res.options |= RES_USEVC;
+    responselen = lookup(glue.s,C_IN,type,response.buf,responsebuflen);
+    _res.options = saveresoptions;
+  }
  if (responselen <= 0)
   {
    if (errno == ECONNREFUSED) return DNS_SOFT;
    if (h_errno == TRY_AGAIN) return DNS_SOFT;
    return DNS_HARD;
   }
- if (responselen >= sizeof(response))
-   responselen = sizeof(response);
  responseend = response.buf + responselen;
  responsepos = response.buf + sizeof(HEADER);
- n = ntohs(response.hdr.qdcount);
+ n = ntohs(((HEADER *)response.buf)->qdcount);
  while (n-- > 0)
   {
    i = dn_expand(response.buf,responseend,responsepos,name,MAXDNAME);
@@ -64,7 +80,7 @@
    if (i < QFIXEDSZ) return DNS_SOFT;
    responsepos += QFIXEDSZ;
   }
- numanswers = ntohs(response.hdr.ancount);
+ numanswers = ntohs(((HEADER *)response.buf)->ancount);
  return 0;
 }
 
diff -Naur netqmail-1.06.org/domainkeys.h netqmail-1.06/domainkeys.h
--- netqmail-1.06.org/domainkeys.h	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/domainkeys.h	2018-04-03 17:28:43.664318558 +0530
@@ -0,0 +1,378 @@
+/* This file is automatically created from the corresponding .c file */
+/* Do not change this file; change the .c file instead. */
+/* This is libdomainkeys.  It's Copyright (c) 2004 Yahoo, Inc.
+ * This code incorporates intellectual property owned by
+ * Yahoo! and licensed pursuant to the Yahoo! DomainKeys Public License
+ * Agreement: http://domainkeys.sourceforge.net/license/softwarelicense1-0.html
+ */
+#include <openssl/evp.h>
+#include <openssl/pem.h>
+#include <openssl/err.h>
+
+#ifdef SWIG
+%module domainkeys
+%{
+#include "domainkeys.h"
+%}
+#endif
+
+#include "dktrace.h"
+
+/* Performance/Debug options.
+ * Uncomment below or use -D switch in gcc
+ * DK_DEBUG Dumps whatever dkhash() hashes in to stderr and turns on
+ *  some debug warnings that should never happen
+ * DK_HASH_BUFF Enables code that uses a buffer when processing the
+ *  canocalized message, reducing calls to the crypto library (from dkhash()),
+ *  but can use up slightly more memory
+*/
+//#define DK_DEBUG 1
+#define DK_HASH_BUFF 1
+
+
+#define DKMARK ('D' | 'K'<<8 | 'E'<<16 | 'Y'<<24)
+#define DK_SIGNING_SIGN 0
+#define DK_SIGNING_VERIFY 1
+#define DK_SIGNING_NOSIGN 2
+#define DK_SIGNING_NOVERIFY 3
+#define DK_MALLOC(s)  OPENSSL_malloc(s)
+#define DK_MFREE(s)   OPENSSL_free(s); s = NULL;
+#define DKERR(x) ((dk->errline=__LINE__),(dk->errfile=__FILE__),(x))
+#define DK_BLOCK 1024 //default size of malloc'd block
+
+/*
+ * Option Flags for dk_setopts
+ * OR together or run dk_setopts several times
+ * All option flags are OFF by default
+*/
+#define DKOPT_TRACE_h 0x01 //enables tracking character count in pre-canon header
+#define DKOPT_TRACE_H 0x02 //enables tracking character count in post-canon header
+#define DKOPT_TRACE_b 0x04 //enables tracking character count in pre-canon body
+#define DKOPT_TRACE_B 0x08 //enables tracking character count in post-canon header
+#define DKOPT_RDUPE 0x10 //enables skipping duplicate headers when generateing a signature
+
+typedef enum
+{
+  DK_STAT_OK, /* Function completed successfully */
+  DK_STAT_BADSIG, /* Signature was available but failed to verify against domain specified key */
+  DK_STAT_NOSIG, /* No signature available in message */
+  DK_STAT_NOKEY, /* No public key available (permanent failure) */
+  DK_STAT_BADKEY, /* Unusable key, public if verifying, private if signing */
+  DK_STAT_CANTVRFY, /* Cannot get domain key to verify signature (temporary failure) */
+  DK_STAT_SYNTAX, /* Message is not valid syntax. Signature could not be created/checked */
+  DK_STAT_NORESOURCE, /* Could not get critical resource (temporary failure) */
+  DK_STAT_ARGS, /* Arguments are not usable. */
+  DK_STAT_REVOKED,    /* Key has been revoked. */
+  DK_STAT_INTERNAL, /* cannot call this routine in this context.  Internal error. */
+  DK_STAT_GRANULARITY, /* Granularity mismatch: sender doesn't match g= option. */
+} DK_STAT;
+
+typedef enum
+{
+  DK_FLAG_TESTING = 1,    /* set when in testing mode. */
+  DK_FLAG_SIGNSALL = 2,   /* domain signs all outgoing email. */
+  DK_FLAG_SET = 4,    /* flags set from a successful DNS query */
+  DK_FLAG_G = 8,    /* g tag was present in the selector. */
+} DK_FLAGS;
+typedef enum
+{
+  DK_TXT_KEY = 0,
+  DK_TXT_POLICY
+} DK_TXT;
+
+typedef enum
+{
+  DK_CANON_SIMPLE = 0,
+  DK_CANON_NOFWS = 1,
+} DK_CANON;
+/* STARTSTRUCT */
+typedef struct
+{
+
+} DK_LIB;
+/* STOPSTRUCT */
+
+//UnixWare Fix -Tim
+/* STARTSTRUCT */
+typedef struct
+{
+} DK;
+/* STOPSTRUCT */
+
+
+/* returns the source file from which an error was returned. */
+char * dk_errfile(DK *dk)
+;
+
+
+/* returns the source line number from which an error was returned. */
+int dk_errline(DK *dk)
+;
+
+
+/* Per-process, one-time initialization
+ * Returns library structure for subsequent dk_sign or dk_verify calls.
+ * Consult statp before using.
+ *
+ * When terminating the PROCESS its a good idea to call dk_shutdown()
+ * When terminating a THREAD it's a good idea to call ERR_remove_state(0); defined in <openssl/err.h>
+ * NOTE: DK_LIB pointers are safe to use over multiple threads
+ *       DK pointers are NOT safe to use over multiple threads
+ */
+DK_LIB *dk_init(DK_STAT *statp)
+;
+
+
+/* Per-process, one-time cleanup
+ * Should be called just before the application ends.
+ * the dklib pointer is not valid anymore after this call
+ * This function should be called even if dk_init failed.
+ * It's safe to call dk_shutdown with a NULL pointer
+ */
+void dk_shutdown(DK_LIB * dklib)
+;
+
+
+/* Set dk options, use instead of dk_remdupe and dk_enable_trace
+ * Can be called multiple times.
+ * use after dk_sign()/dk_verify()
+ *
+ * the bits field can be an OR of any of the following
+ *DKOPT_TRACE_h Trace pre-canon header
+ *DKOPT_TRACE_H Trace post-canon header
+ *DKOPT_TRACE_b Trace pre-canon body
+ *DKOPT_TRACE_B Trace post-canon body
+ *DKOPT_RDUPE   Exclude duplicate headers from hash (Signing only)
+ */
+DK_STAT dk_setopts(DK *dk, int bits)
+;
+
+
+/* returns the int holding the options set
+ * See dk_setopts for bit flags
+ */
+int dk_getopts(DK *dk)
+;
+
+
+/* DEPRECATED in favor of calling dk_setopts().
+ * Enables character trace tracking
+ *
+ * use after dk_sign()/dk_verify()
+ */
+DK_STAT dk_enable_trace(DK *dk)
+;
+
+
+/* Prints trace table to *store variable (char string)
+ * *dk is the container for the table
+ * *store is a pointer to a character array to output to
+ * store_size is the size of the character array *store
+ *
+ */
+DK_STAT dk_get_trace(DK *dk, DK_TRACE_TYPE type, char *store, int store_size)
+;
+
+
+/* Prints difference trace table to *store variable (char string)
+ * *dk is the container for the table
+ * *store is a pointer to a character array to output to
+ * store_size is the size of the character array *store
+ * return DK_STAT_NOSIG if no DK-Trace header was found
+ */
+DK_STAT dk_compare_trace(DK *dk, DK_TRACE_TYPE type, char *store, int store_size)
+;
+
+
+/* Sets the DNS key/policy record manually (no DNS lookup)
+ * txtrecord needs to be set to "e=perm;" to force a permanent DNS failure
+ * txtrecord needs to be set to "e=temp;" to force a temporary DNS failure
+ * Valid DK_TXT types are:
+ * DK_TXT_KEY (normal selector record; for <selctor>._domainkey.<domain>)
+ * DK_TXT_POLICY (domain policy record; for _domainkey.<domain>)
+ */
+DK_STAT dk_settxt(DK *dk, DK_TXT recordtype, const char *txtrecord)
+;
+
+
+/* Per-message, may be threaded.
+ * canon is one of DK_CANON_*.
+ * Returns state structure for operation.  Consult statp before using.
+ */
+DK *dk_sign(DK_LIB *dklib, DK_STAT *statp, int canon)
+;
+
+
+/* Per-message, may be threaded.
+ * Returns state structure for operation.  Consult statp before using.
+ */
+DK *dk_verify(DK_LIB *dklib, DK_STAT *statp)
+;
+
+
+/* DEPRECATED in favor of calling dk_setopts()
+ * set option to remove dupe headers
+ * should be called after dk_sign();
+ * any int NOT 0 turns dupe removal on
+ */
+DK_STAT dk_remdupe(DK *dk,int i)
+;
+
+
+/* Returns the policy flags belonging to the signing domain.
+ * Sender: overrides From:, and the d= entry in the DK-Sig overrides both.
+ * If the policy flags were not successfully fetched, DK_FLAG_SET will not
+ * be set.
+ */
+DK_FLAGS dk_policy(DK *dk)
+;
+
+
+/* Copies the header names that were signed into the pointer.
+ * Returns the number of bytes copied.
+ * ptr may be NULL, in which case the bytes are just counted, not copied.
+ * Feel free to call this twice; once to get the length, and again to
+ * copy the data.
+ * NOTE: If the return value is 0 then an error occured.
+ *	It's a good idea to check for this
+ */
+int dk_headers(DK *dk, char *ptr)
+;
+
+
+/* Must NOT include dots inserted for SMTP encapsulation.
+ * Must NOT include CRLF.CRLF which terminates the message.
+ * Otherwise must be exactly that which is sent or received over the SMTP session.
+ * May be called multiple times (not necessary to read an entire message into memory).
+ */
+DK_STAT dk_message(DK *dk, const unsigned char *ptr, size_t len)
+;
+
+
+/* DEPRECATED in favor of calling dk_address().
+ * Returns a pointer to a null-terminated domain name portion of an RFC 2822 address.
+ * If a Sender: was encountered, it returns that domain.  Otherwise,
+ * if a From: was encountered, it returns that domain.  Otherwise,
+ * return NULL.
+ * return NULL if no domain name found in the address.
+ * return NULL if the dk is unusable for any reason.
+ * return NULL if the address is unusable for any reason.
+ */
+char *dk_from(DK *dk)
+;
+
+
+/* Returns a pointer to the selector name used or NULL if there isn't one
+ * Added by rjp
+ */
+const char *dk_selector(DK *dk)
+;
+
+
+/* Returns a pointer to the domain name used or NULL if there isn't one
+ */
+const char *dk_domain(DK *dk)
+;
+
+
+/*
+ * Returns a pointer to a string which begins with "N", "S", or "F",
+ * corresponding to None, Sender: and From:, respectively.
+ * This single character is followed by a null-terminated RFC 2822 address.
+ * The first character is "N" if no valid address has been seen yet,
+ * "S" if the address came from the Sender: field, and "F" if the
+ * address came from the From: field.
+ */
+char *dk_address(DK *dk)
+;
+
+
+/*
+ * Returns a pointer to a null-terminated string containing the granularity
+ * value found in the selector DNS record, if any, but only after dk_end
+ * has been called. Otherwise returns NULL.
+ */
+char *dk_granularity(DK *dk)
+;
+
+
+/*
+ * Called at end-of-message (before response to DATA-dot, if synchronous with SMTP session).
+ * If verifying, returns signature validity.
+ * This does not calculate the signature.  Call dk_getsig() for that.
+ * Flags are returned indirectly through dkf.
+ * If you pass in NULL for dkf, the flags will not be fetched.
+ * If there is a DK-Sig line, the d= entry will be used to fetch the flags.
+ * Otherwise the Sender: domain will be used to fetch the flags.
+ * Otherwise the From: domain will be used to fetch the flags.
+ *
+ * NOTE: If for some reason dk_end() returns an error (!DK_STAT_OK) dk_policy() should be called
+ * to get the domain signing policy (o=) and handle accordingly.
+ * dkf (selector flags) wont be set if dk_end() returns
+ * DK_STAT_NOSIG
+ * DK_STAT_NOKEY
+ * DK_STAT_SYNTAX
+ * DK_STAT_NORESOURCE
+ * DK_STAT_BADKEY
+ * DK_STAT_CANTVERIFY
+ */
+DK_STAT dk_end(DK *dk, DK_FLAGS *dkf)
+;
+
+
+/*
+ * DEPRECATED in favor of calling dk_end and dk_policy() directly.
+ * If you pass in NULL for dkf, the policy flags will not be fetched.
+ * If the message verified okay, the policy flags will not be fetched.
+ */
+DK_STAT dk_eom(DK *dk, DK_FLAGS *dkf)
+;
+
+
+/*
+ *
+ * privatekey is the private key used to create the signature; It should contain
+ * the entire contents of a PEM-format private key file, thusly it will begin with
+ * -----BEGIN RSA PRIVATE KEY-----.  It should be null-terminated.
+ */
+size_t dk_siglen(void *privatekey)
+;
+
+
+/*
+ * Sets buf to a null-terminated string.
+ * If the message is being signed, signature is stored in the buffer.
+ * If the message is being verified, returns DK_STAT_INTERNAL.
+ * privatekey is the private key used to create the signature; It should contain
+ * the entire contents of a PEM-format private key file, thus it will begin with
+ * -----BEGIN RSA PRIVATE KEY-----.  It should be null-terminated.
+ * If you pass in NULL for buf, you'll get back DK_STAT_NORESOURCE.
+ * If len is not big enough, you'll get back DK_STAT_NORESOURCE.
+ */
+DK_STAT dk_getsig(DK *dk, void *privatekey, unsigned char buf[], size_t len)
+;
+
+
+/*
+ * Free all resources associated with this message.
+ * dk is no longer usable.
+ * if doClearErrState != 0, the OpenSSL ErrorState is freed.
+ * Set clearErrState=0 if you use other openssl functions and
+ * want to call openssl's ERR_remove_state(0) by yourself
+ * ERR_remove_state(0) is declared in <openssl/err.h>
+ */
+DK_STAT dk_free(DK *dk, int doClearErrState)
+;
+
+
+/*
+ * return a pointer to a string which describes st.
+ * The string is structured.  All the characters up to the first colon
+ * contain the name of the DK_STAT constant.  From there to the end of
+ * string is a human-readable description of the error.
+ */
+const char *DK_STAT_to_string(DK_STAT st)
+;
+
+
+char           *dns_text(char *);
diff -Naur netqmail-1.06.org/hier.c netqmail-1.06/hier.c
--- netqmail-1.06.org/hier.c	1998-06-15 16:23:16.000000000 +0530
+++ netqmail-1.06/hier.c	2018-04-03 17:28:43.664318558 +0530
@@ -32,6 +32,7 @@
   h(auto_qmail,auto_uido,auto_gidq,0755);
 
   d(auto_qmail,"control",auto_uido,auto_gidq,0755);
+  d(auto_qmail,"control/cache",auto_uidd,auto_gidq,0755);
   d(auto_qmail,"users",auto_uido,auto_gidq,0755);
   d(auto_qmail,"bin",auto_uido,auto_gidq,0755);
   d(auto_qmail,"boot",auto_uido,auto_gidq,0755);
@@ -104,10 +105,19 @@
   c(auto_qmail,"bin","qmail-start",auto_uido,auto_gidq,0700);
   c(auto_qmail,"bin","qmail-getpw",auto_uido,auto_gidq,0711);
   c(auto_qmail,"bin","qmail-local",auto_uido,auto_gidq,0711);
+  c(auto_qmail,"bin","spawn-filter",auto_uido,auto_gidq,0711);
+  c(auto_qmail,"bin","surblfilter",auto_uido,auto_gidq,0711);
+  c(auto_qmail,"bin","dk-filter",auto_uido,auto_gidq,0555);
+  c(auto_qmail,"bin","surblqueue",auto_uido,auto_gidq,0555);
   c(auto_qmail,"bin","qmail-remote",auto_uido,auto_gidq,0711);
   c(auto_qmail,"bin","qmail-rspawn",auto_uido,auto_gidq,0711);
   c(auto_qmail,"bin","qmail-clean",auto_uido,auto_gidq,0711);
   c(auto_qmail,"bin","qmail-send",auto_uido,auto_gidq,0711);
+  c(auto_qmail,"bin","dknewkey", auto_uido, auto_gidq, 0711);
+  c(auto_qmail,"bin","dktest",auto_uidq,auto_gidq,0711);
+  c(auto_qmail,"bin","qmail-dk",auto_uidq,auto_gidq,0711);
+  c(auto_qmail,"bin","qmail-dkim",auto_uidq,auto_gidq,0711);
+  c(auto_qmail,"bin","dkim",auto_uidq,auto_gidq,0711);
   c(auto_qmail,"bin","splogger",auto_uido,auto_gidq,0711);
   c(auto_qmail,"bin","qmail-newu",auto_uido,auto_gidq,0700);
   c(auto_qmail,"bin","qmail-newmrh",auto_uido,auto_gidq,0700);
@@ -198,6 +208,18 @@
   c(auto_qmail,"man/cat1","tcp-env.0",auto_uido,auto_gidq,0644);
 
   c(auto_qmail,"man/man8","qmail-local.8",auto_uido,auto_gidq,0644);
+  c(auto_qmail,"man/man8","qmail-dk.8",auto_uido,auto_gidq,0644);
+  c(auto_qmail,"man/cat8","qmail-dk.0",auto_uido,auto_gidq,0644);
+  c(auto_qmail,"man/man8","dkim.8",auto_uido,auto_gidq,0644);
+  c(auto_qmail,"man/man8","dktest.8",auto_uido,auto_gidq,0644);
+  c(auto_qmail,"man/man8","qmail-dkim.8",auto_uido,auto_gidq,0644);
+  c(auto_qmail,"man/cat8","qmail-dkim.0",auto_uido,auto_gidq,0644);
+  c(auto_qmail,"man/man8","dk-filter.8",auto_uido,auto_gidq,0644);
+  c(auto_qmail,"man/cat8","dk-filter.0",auto_uido,auto_gidq,0644);
+  c(auto_qmail,"man/man8","surblfilter.8",auto_uido,auto_gidq,0644);
+  c(auto_qmail,"man/cat8","surblfilter.0",auto_uido,auto_gidq,0644);
+  c(auto_qmail,"man/man8","spawn-filter.8",auto_uido,auto_gidq,0644);
+  c(auto_qmail,"man/cat8","spawn-filter.0",auto_uido,auto_gidq,0644);
   c(auto_qmail,"man/cat8","qmail-local.0",auto_uido,auto_gidq,0644);
   c(auto_qmail,"man/man8","qmail-lspawn.8",auto_uido,auto_gidq,0644);
   c(auto_qmail,"man/cat8","qmail-lspawn.0",auto_uido,auto_gidq,0644);
diff -Naur netqmail-1.06.org/ip.h netqmail-1.06/ip.h
--- netqmail-1.06.org/ip.h	1998-06-15 16:23:16.000000000 +0530
+++ netqmail-1.06/ip.h	2018-04-03 17:28:43.665318578 +0530
@@ -2,6 +2,7 @@
 #define IP_H
 
 struct ip_address { unsigned char d[4]; } ;
+typedef struct  ip_address ip_addr;
 
 extern unsigned int ip_fmt();
 #define IPFMT 19
diff -Naur netqmail-1.06.org/macros.h netqmail-1.06/macros.h
--- netqmail-1.06.org/macros.h	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/macros.h	2018-04-03 17:28:43.665318578 +0530
@@ -0,0 +1,25 @@
+/*
+ * $Log: macros.h,v $
+ * Revision 1.1  2009-03-21 08:50:25+05:30  Cprogrammer
+ * Initial revision
+ *
+ *
+ * macros.h:  Useful macros
+ *
+ * Author:
+ *  Dick Porter (dick@ximian.com)
+ *
+ * (C) 2002 Ximian, Inc.
+ */
+
+#ifndef _WAPI_MACROS_H_
+#define _WAPI_MACROS_H_
+
+#include <sys/types.h>
+
+#define MAKEWORD(low, high) ((__uint16_t)(((__uint8_t)(low)) | \
+				       ((__uint16_t)((__uint8_t)(high))) << 8))
+#define LOBYTE(i16) ((__uint8_t)((i16) & 0xFF))
+#define HIBYTE(i16) ((__uint8_t)(((__uint16_t)(i16) >> 8) & 0xFF))
+
+#endif							/* _WAPI_MACROS_H_ */
diff -Naur netqmail-1.06.org/MakeArgs.c netqmail-1.06/MakeArgs.c
--- netqmail-1.06.org/MakeArgs.c	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/MakeArgs.c	2018-04-03 17:28:43.665318578 +0530
@@ -0,0 +1,144 @@
+/*
+ * $Log: MakeArgs.c,v $
+ * Revision 2.8  2007-12-21 14:35:42+05:30  Cprogrammer
+ * included env.h to prevent compiler warning
+ *
+ * Revision 2.7  2007-12-20 12:45:28+05:30  Cprogrammer
+ * expand environment variables with '$' sign
+ *
+ * Revision 2.6  2005-08-23 17:31:28+05:30  Cprogrammer
+ * removed sccsid variable
+ *
+ * Revision 2.5  2005-04-02 19:06:02+05:30  Cprogrammer
+ * djb version
+ *
+ * Revision 2.4  2005-03-30 22:52:47+05:30  Cprogrammer
+ * BUG - Incorrect free
+ *
+ * Revision 2.3  2004-07-12 22:47:58+05:30  Cprogrammer
+ * bug fix. Free all allocated members
+ *
+ * Revision 2.2  2002-12-21 18:21:09+05:30  Cprogrammer
+ * added functionality of escaping text via quotes
+ *
+ * Revision 2.1  2002-08-13 20:35:44+05:30  Cprogrammer
+ * addition spaces were not getting skipped
+ *
+ * Revision 1.2  2002-03-03 17:23:05+05:30  Cprogrammer
+ * replaced strcpy with scopy
+ *
+ * Revision 1.1  2001-12-13 01:46:09+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
+#include "alloc.h"
+#include "str.h"
+#include "stralloc.h"
+#include "env.h"
+#include <ctype.h>
+
+#define isEscape(ch) ((ch) == '"' || (ch) == '\'')
+
+/*
+ * function to expand a string into command line
+ * arguments. To free memory allocated by this
+ * function the following should be done
+ *
+ * free(argv);
+ *
+ */
+char          **
+MakeArgs(char *cmmd)
+{
+	char           *ptr, *marker;
+	char          **argv;
+	int             argc, idx;
+	static stralloc sptr = { 0 };
+
+	for (ptr = cmmd;*ptr && isspace((int) *ptr);ptr++);
+	idx = str_len(ptr);
+	if (!stralloc_copys(&sptr, ptr))
+		return((char **) 0);
+	if (!stralloc_0(&sptr))
+		return((char **) 0);
+	/*-
+	 * Get the number of arguments by counting
+	 * white spaces. Allow escape via the double
+	 * quotes character at the first word
+	 */
+	for (argc = 0, ptr = sptr.s;*ptr;)
+	{
+		for (;*ptr && isspace((int) *ptr);ptr++);
+		if (!*ptr)
+			break;
+		argc++;
+		marker = ptr;
+		/*- Move till you hit the next white space */
+		for (;*ptr && !isspace((int) *ptr);ptr++)
+		{
+			/*-
+			 * 1. If escape char is encounted skip till you
+			 *    hit the terminating escape char
+			 * 2. If terminating escape char is missing, come
+			 *    back to the start escape char
+			 */
+			if (ptr == marker && isEscape(*ptr))
+			{
+				for (ptr++;*ptr && !isEscape(*ptr);ptr++);
+				if (!*ptr)
+					ptr = marker;
+			}
+		} /*- for(;*ptr && !isspace((int) *ptr);ptr++) */
+	} /*- for (argc = 0, ptr = sptr.s;*ptr;) */
+	/*
+	 * Allocate memory to store the arguments
+	 * Do not bother extra bytes occupied by
+	 * white space characters.
+	 */
+	if (!(argv = (char **) alloc((argc + 1) * sizeof(char *))))
+		return ((char **) 0);
+	for (idx = 0, ptr = sptr.s;*ptr;)
+	{
+		for (;*ptr && isspace((int) *ptr);ptr++)
+			*ptr = 0;
+		if (!*ptr)
+			break;
+		if (*ptr == '$')
+			argv[idx++] = env_get(ptr + 1);
+		else
+			argv[idx++] = ptr;
+		marker = ptr;
+		for (;*ptr && !isspace((int) *ptr);ptr++)
+		{
+			if (ptr == marker && isEscape(*ptr))
+			{
+				for (ptr++;*ptr && !isEscape(*ptr);ptr++);
+				if (!*ptr)
+					ptr = marker;
+				else /*- Remove the quotes */
+				{
+					argv[idx - 1] += 1;
+					*ptr = 0;
+				}
+			}
+		}
+	} /*- for (idx = 0, ptr = sptr.s;*ptr;) */
+	argv[idx++] = (char *) 0;
+	return (argv);
+}
+
+void
+FreeMakeArgs(char **argv)
+{
+	alloc_free(argv);
+	return;
+}
+
+void
+getversion_MakeArgs__c()
+{
+	static char     *x = "$Id: MakeArgs.c,v 2.8 2007-12-21 14:35:42+05:30 Cprogrammer Stab mbhangui $";
+	x++;
+	x--;
+	return;
+}
diff -Naur netqmail-1.06.org/Makefile netqmail-1.06/Makefile
--- netqmail-1.06.org/Makefile	2007-12-01 01:52:54.000000000 +0530
+++ netqmail-1.06/Makefile	2019-05-23 13:03:05.793752307 +0530
@@ -807,8 +807,9 @@
 dnsptr dnsip dnsmxip dnsfq hostname ipmeprint qreceipt qsmhook qbiff \
 forward preline condredirect bouncesaying except maildirmake \
 maildir2mbox maildirwatch qail elq pinq idedit install-big install \
+dktest qmail-dk qmail-dkim dkim spawn-filter dk-filter surblfilter \
 instcheck home home+df proc proc+df binm1 binm1+df binm2 binm2+df \
-binm3 binm3+df
+binm3 binm3+df surblqueue dknewkey
 
 load: \
 make-load warn-auto.sh systype
@@ -934,8 +935,9 @@
 preline.0 condredirect.0 bouncesaying.0 except.0 maildirmake.0 \
 maildir2mbox.0 maildirwatch.0 qmail.0 qmail-limits.0 qmail-log.0 \
 qmail-control.0 qmail-header.0 qmail-users.0 dot-qmail.0 \
-qmail-command.0 tcp-environ.0 maildir.0 mbox.0 addresses.0 \
-envelopes.0 forgeries.0
+qmail-command.0 tcp-environ.0 maildir.0 mbox.0 addresses.0 dkim.8 dktest.8 \
+envelopes.0 forgeries.0 qmail-dk.0 qmail-dkim.0 dk-filter.0 spawn-filter.0 \
+surblfilter.0
 
 mbox.0: \
 mbox.5
@@ -1107,6 +1109,75 @@
 	| sed s}SPAWN}"`head -1 conf-spawn`"}g \
 	> qmail-control.5
 
+qmail-dk: \
+load qmail-dk.o triggerpull.o fmtqfn.o now.o date822fmt.o mess822_ok.o \
+subgetopt.o MakeArgs.o datetime.a seek.a ndelay.a open.a sig.a alloc.a substdio.a error.a \
+str.a case.a fs.a auto_qmail.o auto_split.o auto_uids.o fd.a wait.a \
+../libdomainkeys.a env.a getln.a control.o stralloc.a dns.lib
+	./load qmail-dk triggerpull.o fmtqfn.o now.o mess822_ok.o \
+	date822fmt.o datetime.a seek.a ndelay.a open.a sig.a \
+	subgetopt.o MakeArgs.o substdio.a error.a fs.a auto_qmail.o \
+	auto_split.o auto_uids.o \
+	fd.a wait.a ../libdomainkeys.a -lcrypto env.a control.o open.a getln.a \
+	stralloc.a alloc.a substdio.a str.a case.a `cat dns.lib`
+
+qmail-dk.0: \
+qmail-dk.8
+	nroff -man qmail-dk.8 > qmail-dk.0
+qmail-dk.8: qmail-dk.9
+	cat qmail-dk.9 \
+	| sed s}QMAILHOME}"`head -1 conf-qmail`"}g \
+	> qmail-dk.8
+
+qmail-dk.o: \
+compile qmail-dk.c readwrite.h sig.h exit.h open.h seek.h fmt.h \
+qmail.h alloc.h substdio.h datetime.h now.h datetime.h triggerpull.h extra.h \
+env.h wait.h fd.h fork.h str.h uint64.h \
+auto_qmail.h auto_uids.h date822fmt.h fmtqfn.h
+	./compile qmail-dk.c
+
+dktest: load dktest.o scan_ulong.o dktrace.o \
+dns.o ip.o error.o ipalloc.o fmt_ulong.o \
+scan_xlong.o socket_v4mappedprefix.o socket_v6any.o \
+case_diffs.o case_diffb.o fmt_str.o stralloc.a alloc.a str.a \
+../libdomainkeys.a dns.lib
+	./load dktest scan_ulong.o dktrace.o \
+	dns.o ip.o error.o ipalloc.o fmt_ulong.o \
+	scan_xlong.o socket_v4mappedprefix.o socket_v6any.o \
+	case_diffs.o case_diffb.o fmt_str.o stralloc.a alloc.a str.a \
+	../libdomainkeys.a -lcrypto `cat dns.lib`
+
+dktest.o: compile dktest.c domainkeys.h conf-domainkeys
+	./compile `grep -h -v "^#" conf-domainkeys` dktest.c
+
+dktest.8: dktest.9
+	cat dktest.9 \
+	| sed s}QMAILHOME}"`head -1 conf-qmail`"}g \
+	> dktest.8
+
+dktrace.o: compile dktrace.c dktrace.h str.h case.h conf-domainkeys
+	./compile `grep -h -v "^#" conf-domainkeys` dktrace.c
+
+qmail-dkim: \
+load qmail-dkim.o triggerpull.o fmtqfn.o now.o date822fmt.o \
+subgetopt.o MakeArgs.o dkimdns.o datetime.a seek.a ndelay.a \
+open.a sig.a alloc.a substdio.a error.a \
+str.a case.a fs.a auto_qmail.o auto_split.o auto_uids.o fd.a wait.a \
+../libdomainkeys.a env.a getln.a control.o stralloc.a dns.lib libdkim.a
+	g++ -o qmail-dkim qmail-dkim.o triggerpull.o dkimdns.o fmtqfn.o now.o \
+	subgetopt.o MakeArgs.o date822fmt.o datetime.a seek.a ndelay.a \
+	open.a sig.a substdio.a error.a fs.a auto_qmail.o \
+	auto_split.o auto_uids.o fd.a wait.a \
+	../libdomainkeys.a -lcrypto env.a control.o open.a getln.a \
+	stralloc.a alloc.a substdio.a str.a case.a libdkim.a `cat dns.lib`
+
+qmail-dkim.o: \
+compile qmail-dkim.c readwrite.h sig.h exit.h open.h seek.h fmt.h \
+qmail.h alloc.h substdio.h datetime.h now.h datetime.h triggerpull.h extra.h \
+sgetopt.h env.h wait.h fd.h fork.h str.h dkim.h \
+auto_qmail.h auto_uids.h date822fmt.h fmtqfn.h
+	./compile -DHAVE_CONFIG_H qmail-dkim.c
+
 qmail-getpw: \
 load qmail-getpw.o case.a substdio.a error.a str.a fs.a auto_break.o \
 auto_usera.o
@@ -1125,6 +1196,28 @@
 	| sed s}SPAWN}"`head -1 conf-spawn`"}g \
 	> qmail-getpw.8
 
+qmail-dkim.0: qmail-dkim.8
+	nroff -man qmail-dkim.8 > qmail-dkim.0
+qmail-dkim.8: qmail-dkim.9
+	cat qmail-dkim.9 \
+	| sed s}QMAILHOME}"`head -1 conf-qmail`"}g \
+	> qmail-dkim.8
+
+dkim.8: dkim.9
+	cat dkim.9 | sed s}QMAILHOME}"`head -1 conf-qmail`"}g \
+	> dkim.8
+
+dk-filter.0: dk-filter.8
+	nroff -man dk-filter.8 > dk-filter.0
+dk-filter.8: dk-filter.9
+	cat dk-filter.9 \
+	| sed s}QMAILHOME}"`head -1 conf-qmail`"}g \
+	> dk-filter.8
+
+dknewkey: dknewkey.sh warn-auto.sh
+	rm -f dknewkey
+	cat warn-auto.sh dknewkey.sh > dknewkey
+
 qmail-getpw.o: \
 compile qmail-getpw.c readwrite.h substdio.h subfd.h substdio.h \
 error.h exit.h byte.h str.h case.h fmt.h auto_usera.h auto_break.h \
@@ -1200,11 +1293,11 @@
 qmail-lspawn: \
 load qmail-lspawn.o spawn.o prot.o slurpclose.o coe.o sig.a wait.a \
 case.a cdb.a fd.a open.a stralloc.a alloc.a substdio.a error.a str.a \
-fs.a auto_qmail.o auto_uids.o auto_spawn.o
+fs.a auto_qmail.o auto_uids.o auto_spawn.o envread.o str_diffn.o
 	./load qmail-lspawn spawn.o prot.o slurpclose.o coe.o \
 	sig.a wait.a case.a cdb.a fd.a open.a stralloc.a alloc.a \
 	substdio.a error.a str.a fs.a auto_qmail.o auto_uids.o \
-	auto_spawn.o 
+	auto_spawn.o envread.o str_diffn.o
 
 qmail-lspawn.0: \
 qmail-lspawn.8
@@ -1213,7 +1306,7 @@
 qmail-lspawn.o: \
 compile qmail-lspawn.c fd.h wait.h prot.h substdio.h stralloc.h \
 gen_alloc.h scan.h exit.h fork.h error.h cdb.h uint32.h case.h \
-slurpclose.h auto_qmail.h auto_uids.h qlx.h
+slurpclose.h auto_qmail.h auto_uids.h qlx.h env.h
 	./compile qmail-lspawn.c
 
 qmail-newmrh: \
@@ -1463,11 +1556,11 @@
 qmail-rspawn: \
 load qmail-rspawn.o spawn.o tcpto_clean.o now.o coe.o sig.a open.a \
 seek.a lock.a wait.a fd.a stralloc.a alloc.a substdio.a error.a str.a \
-auto_qmail.o auto_uids.o auto_spawn.o
+auto_qmail.o auto_uids.o auto_spawn.o envread.o str_diffn.o
 	./load qmail-rspawn spawn.o tcpto_clean.o now.o coe.o \
 	sig.a open.a seek.a lock.a wait.a fd.a stralloc.a alloc.a \
 	substdio.a error.a str.a auto_qmail.o auto_uids.o \
-	auto_spawn.o 
+	auto_spawn.o  envread.o str_diffn.o
 
 qmail-rspawn.0: \
 qmail-rspawn.8
@@ -1475,7 +1568,7 @@
 
 qmail-rspawn.o: \
 compile qmail-rspawn.c fd.h wait.h substdio.h exit.h fork.h error.h \
-tcpto.h
+tcpto.h env.h
 	./compile qmail-rspawn.c
 
 qmail-send: \
@@ -1541,8 +1634,7 @@
 	timeoutwrite.o ip.o ipme.o ipalloc.o control.o constmap.o \
 	received.o date822fmt.o now.o qmail.o cdb.a fd.a wait.a \
 	datetime.a getln.a open.a sig.a case.a env.a stralloc.a \
-	alloc.a substdio.a error.a str.a fs.a auto_qmail.o  `cat \
-	socket.lib`
+	alloc.a substdio.a error.a str.a fs.a auto_qmail.o `cat socket.lib`
 
 qmail-smtpd.0: \
 qmail-smtpd.8
@@ -1639,10 +1731,10 @@
 qreceipt: \
 load qreceipt.o headerbody.o hfield.o quote.o token822.o qmail.o \
 getln.a fd.a wait.a sig.a env.a stralloc.a alloc.a substdio.a error.a \
-str.a auto_qmail.o
+str.a auto_qmail.o scan_ulong.o
 	./load qreceipt headerbody.o hfield.o quote.o token822.o \
 	qmail.o getln.a fd.a wait.a sig.a env.a stralloc.a alloc.a \
-	substdio.a error.a str.a auto_qmail.o 
+	substdio.a error.a str.a auto_qmail.o scan_ulong.o
 
 qreceipt.0: \
 qreceipt.1
@@ -1912,11 +2004,11 @@
 	./compile splogger.c
 
 str.a: \
-makelib str_len.o str_diff.o str_diffn.o str_cpy.o str_chr.o \
+makelib str_len.o str_diff.o str_diffn.o str_cpy.o str_cpyb.o str_chr.o \
 str_rchr.o str_start.o byte_chr.o byte_rchr.o byte_diff.o byte_copy.o \
 byte_cr.o byte_zero.o
 	./makelib str.a str_len.o str_diff.o str_diffn.o str_cpy.o \
-	str_chr.o str_rchr.o str_start.o byte_chr.o byte_rchr.o \
+	str_cpyb.o str_chr.o str_rchr.o str_start.o byte_chr.o byte_rchr.o \
 	byte_diff.o byte_copy.o byte_cr.o byte_zero.o
 
 str_chr.o: \
@@ -1927,6 +2019,10 @@
 compile str_cpy.c str.h
 	./compile str_cpy.c
 
+str_cpyb.o: \
+compile str_cpyb.c str.h
+	./compile str_cpyb.c
+
 str_diff.o: \
 compile str_diff.c str.h
 	./compile str_diff.c
@@ -2139,3 +2235,148 @@
 wait_pid.o: \
 compile wait_pid.c error.h haswaitp.h
 	./compile wait_pid.c
+MakeArgs.o: compile MakeArgs.c alloc.h str.h alloc.h stralloc.h
+	./compile MakeArgs.c
+
+spawn-filter: \
+load spawn-filter.o auto_qmail.o \
+fmt_ulong.o scan_ulong.o control.o open_read.o wildmat.o qregex.o MakeArgs.o \
+case_lowerb.o constmap.o byte_chr.o byte_cr.o case_diffb.o \
+error.a env.a stralloc.a wait.a strerr.a str.a getln.a substdio.a alloc.a
+	./load spawn-filter \
+	fmt_ulong.o scan_ulong.o control.o open_read.o wildmat.o qregex.o MakeArgs.o \
+	case_lowerb.o constmap.o byte_chr.o byte_cr.o case_diffb.o auto_qmail.o \
+	error.a env.a stralloc.a wait.a strerr.a str.a getln.a substdio.a alloc.a
+
+spawn-filter.o: \
+compile spawn-filter.c fmt.h str.h strerr.h env.h substdio.h stralloc.h error.h \
+wait.h qregex.h 
+	./compile spawn-filter.c
+
+qregex.o: \
+compile qregex.c case.h stralloc.h constmap.h substdio.h byte.h env.h
+	./compile qregex.c
+
+wildmat.o: \
+compile wildmat.c
+	./compile wildmat.c
+
+spawn-filter.0: \
+spawn-filter.8
+	nroff -man spawn-filter.8 > spawn-filter.0
+
+spawn-filter.8: \
+spawn-filter.9
+	cat spawn-filter.9 \
+	| sed s}QMAILHOME}"`head -1 conf-qmail`"}g \
+	> spawn-filter.8
+
+str_cspn.o: \
+compile str.h str_cspn.c
+	./compile str_cspn.c
+
+mess822_ok.o: \
+compile mess822_ok.c uint64.h
+
+surblfilter.0: surblfilter.8
+	nroff -man surblfilter.8 > surblfilter.0
+
+surblfilter.8: surblfilter.9
+	cat surblfilter.9 \
+	| sed s}QMAILHOME}"`head -1 conf-qmail`"}g \
+	> surblfilter.8
+
+surblfilter: \
+load surblfilter.o envread.o strerr_die.o strerr_sys.o \
+control.o alloc.o alloc_re.o error.o \
+error_str.o auto_qmail.o \
+case_startb.o byte_diff.o str_cspn.o \
+byte_copy.o byte_chr.o byte_rchr.o byte_cr.o \
+getln.o getln2.o open_read.o str_len.o str_diffn.o \
+str_cpy.o str_chr.o scan_xlong.o \
+now.o scan_ulong.o mess822_ok.o constmap.o \
+ip.o dns.o ipalloc.o fmt_str.o fmt_ulong.o \
+socket_v6any.o socket_v4mappedprefix.o \
+sgetopt.o subgetopt.o base64sub.o \
+case_diffb.o stralloc.a substdio.a
+	./load surblfilter envread.o strerr_die.o strerr_sys.o \
+	control.o alloc.o alloc_re.o error.o \
+	error_str.o auto_qmail.o \
+	case_startb.o byte_diff.o str_cspn.o \
+	byte_copy.o byte_chr.o byte_rchr.o byte_cr.o \
+	getln.o getln2.o open_read.o str_len.o str_diffn.o \
+	str_cpy.o str_chr.o scan_xlong.o \
+	now.o scan_ulong.o mess822_ok.o constmap.o \
+	ip.o dns.o ipalloc.o fmt_str.o fmt_ulong.o \
+	socket_v6any.o socket_v4mappedprefix.o \
+	sgetopt.o subgetopt.o base64sub.o \
+	case_diffb.o stralloc.a substdio.a -lresolv
+
+surblfilter.o: \
+compile surblfilter.c alloc.h error.h str.h case.h \
+constmap.h auto_qmail.h stralloc.h env.h control.h \
+strerr.h substdio.h getln.h byte.h dns.h ip.h \
+ipalloc.h mess822.h scan.h subgetopt.h uint64.h \
+base64.h
+	./compile surblfilter.c
+
+surblqueue: \
+surblqueue.sh conf-qmail
+	cat warn-auto.sh surblqueue.sh \
+	| sed s}QMAIL}"`head -1 conf-qmail`"}g \
+	> surblqueue
+	chmod 755 surblqueue
+
+hastai.h: \
+trytai.c compile load
+	(( ./compile trytai.c && ./load trytai -ltai) >/dev/null \
+	2>&1 \
+	&& echo \#define HASTAI 1 || exit 0 ) > hastai.h
+	rm -f trytai.o trytai
+
+uint64.h: \
+tryulong64.c compile load uint64.h1 uint64.h2
+	( ( ./compile tryulong64.c && ./load tryulong64 && \
+	./tryulong64 ) >/dev/null 2>&1 \
+	&& cat uint64.h1 || cat uint64.h2 ) > uint64.h
+	rm -f tryulong64.o tryulong64
+
+base64sub.o: \
+compile base64sub.c base64.h stralloc.h substdio.h str.h
+	./compile base64sub.c
+
+dk-filter: \
+warn-auto.sh dk-filter.sh conf-qmail
+	cat warn-auto.sh dk-filter.sh \
+	| sed s}QMAILHOME}"`head -1 conf-qmail`"}g \
+	> dk-filter
+
+DKIMHDRS = dkim.h dkimdns.h dkimbase.h dkimsign.h dkimverify.h time_t_size.h
+DKIMSRCS = dkimfuncs.cpp dkimbase.cpp
+DKIMOBJS = $(DKIMSRCS:.cpp=.o)
+
+time_t_size.h: time_t_size.c compile load
+	(./compile time_t_size.c && ./load time_t_size && \
+		./time_t_size) > time_t_size.h
+	rm -f time_t_size.o time_t_size
+
+dkimfuncs.o: dkimfuncs.cpp time_t_size.h
+	g++ -DHAVE_CONFIG_H -c dkimfuncs.cpp
+
+dkimverify.o: dkim.h dkimdns.h dkimverify.h dkimverify.cpp time_t_size.h
+	g++ -DHAVE_CONFIG_H -c dkimverify.cpp
+
+dkimsign.o: dkim.h dkimsign.h dkimsign.cpp
+	g++ -DHAVE_CONFIG_H -c dkimsign.cpp
+
+dkim: libdkim.a dkim.o dkimdns.o
+	g++ -o dkim $(LFLAGS) -L. dkim.o dkimdns.o libdkim.a `cat dns.lib` -lcrypto
+	
+dkim.o: dkim.c $(DKIMHDRS)
+	g++ -DHAVE_CONFIG_H -I. -DHAVE_EVP_SHA256 -c dkim.c
+
+libdkim.a: $(DKIMOBJS) dkimverify.o dkimsign.o makelib time_t_size.h
+	rm -f libdkim.a
+	./makelib libdkim.a $(DKIMOBJS) dkimsign.o dkimverify.o
+.cpp.o:
+	g++ -I. -DHAVE_CONFIG_H $(CFLAGS) $(INCL) -c $<
diff -Naur netqmail-1.06.org/mess822.h netqmail-1.06/mess822.h
--- netqmail-1.06.org/mess822.h	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/mess822.h	2018-04-03 17:28:43.666318599 +0530
@@ -0,0 +1,55 @@
+/*
+ * $Log: mess822.h,v $
+ * Revision 1.3  2004-10-11 13:55:55+05:30  Cprogrammer
+ * added function prototypes
+ *
+ * Revision 1.2  2004-06-18 23:00:58+05:30  Cprogrammer
+ * added RCS log
+ *
+ */
+#ifndef MESS822_H
+#define MESS822_H
+#include "stralloc.h"
+#include "caltime.h"
+
+#define MESS822_HEADER { {0} }
+
+typedef struct
+{
+	struct caltime  ct;
+	int             known; /*- 0 for ct uninitialized; 1 if ok; 2 if ok and right zone */
+}
+mess822_time;
+
+typedef struct
+{
+	char           *name; /*- 0 means all names */
+	int            *flag;
+	stralloc       *copy;
+	stralloc       *value;
+	stralloc       *addr;
+	mess822_time   *when;
+}
+mess822_action;
+
+typedef struct
+{
+	stralloc        inprogress;
+	mess822_action *action;
+}
+mess822_header;
+
+int             mess822_quoteplus(stralloc *, char *, char *);
+int             mess822_quote(stralloc *, char *, char *);
+int             mess822_quotelist(stralloc *, stralloc *);
+int             mess822_fold(stralloc *, stralloc *, char *, int);
+int             mess822_date(stralloc *, mess822_time *);
+int             mess822_token(stralloc *, char *);
+int             mess822_addrlist(stralloc *, char *);
+int             mess822_when(mess822_time *, char *);
+int             mess822_begin(mess822_header *, mess822_action *);
+int             mess822_line(mess822_header *, stralloc *);
+int             mess822_end(mess822_header *);
+int             mess822_ok(stralloc *);
+
+#endif
diff -Naur netqmail-1.06.org/mess822_ok.c netqmail-1.06/mess822_ok.c
--- netqmail-1.06.org/mess822_ok.c	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/mess822_ok.c	2018-04-03 17:28:43.666318599 +0530
@@ -0,0 +1,55 @@
+/*
+ * $Log: mess822_ok.c,v $
+ * Revision 1.2  2004-10-22 20:27:30+05:30  Cprogrammer
+ * added RCS id
+ *
+ * Revision 1.1  2004-01-04 23:17:51+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
+#include "mess822.h"
+#include "byte.h"
+
+int
+mess822_ok(sa)
+	stralloc       *sa;
+{
+	int             i;
+	int             len;
+	int             colon;
+
+	len = sa->len;
+	if (len && (sa->s[len - 1] == '\n'))
+		--len;
+	if (!len)
+		return 0;
+	/*
+	 * if input message is 822-compliant, will return 1 after this 
+	 */
+	if (sa->s[0] == ' ')
+		return 1;
+	if (sa->s[0] == '\t')
+		return 1;
+	colon = byte_chr(sa->s, sa->len, ':');
+	if (colon >= sa->len)
+		return 0;
+	while (colon && ((sa->s[colon - 1] == ' ') || (sa->s[colon - 1] == '\t')))
+		--colon;
+	if (!colon)
+		return 0;
+	for (i = 0; i < colon; ++i)
+		if (sa->s[i] < 33)
+			return 0;
+	for (i = 0; i < colon; ++i)
+		if (sa->s[i] > 126)
+			return 0;
+	return 1;
+}
+
+void
+getversion_mess822_ok_c()
+{
+	static char    *x = "$Id: mess822_ok.c,v 1.2 2004-10-22 20:27:30+05:30 Cprogrammer Stab mbhangui $";
+
+	x++;
+}
diff -Naur netqmail-1.06.org/qmail.c netqmail-1.06/qmail.c
--- netqmail-1.06.org/qmail.c	2007-12-01 01:52:54.000000000 +0530
+++ netqmail-1.06/qmail.c	2018-04-03 17:28:43.667318619 +0530
@@ -23,22 +23,32 @@
 {
   int pim[2];
   int pie[2];
+  int pic[2], errfd;
+  char *x;
 
   setup_qqargs();
 
   if (pipe(pim) == -1) return -1;
   if (pipe(pie) == -1) { close(pim[0]); close(pim[1]); return -1; }
+  if (pipe(pic) == -1) { close(pim[0]); close(pim[1]); close(pie[0]); close(pie[1]); return -1; }
  
   switch(qq->pid = vfork()) {
     case -1:
       close(pim[0]); close(pim[1]);
       close(pie[0]); close(pie[1]);
+      close(pic[0]); close(pic[1]);
       return -1;
     case 0:
       close(pim[1]);
       close(pie[1]);
+      close(pic[0]); /*- we want to receive data */
       if (fd_move(0,pim[0]) == -1) _exit(120);
       if (fd_move(1,pie[0]) == -1) _exit(120);
+      if (!(x = env_get("ERROR_FD")))
+        errfd = CUSTOM_ERR_FD;
+      else
+        scan_int(x, &errfd);
+      if (fd_move(errfd, pic[1]) == -1) _exit(120);
       if (chdir(auto_qmail) == -1) _exit(61);
       execv(*binqqargs,binqqargs);
       _exit(120);
@@ -46,6 +56,7 @@
 
   qq->fdm = pim[1]; close(pim[0]);
   qq->fde = pie[1]; close(pie[0]);
+  qq->fdc = pic[0]; close(pic[1]);
   substdio_fdbuf(&qq->ss,write,qq->fdm,qq->buf,sizeof(qq->buf));
   qq->flagerr = 0;
   return 0;
@@ -93,10 +104,21 @@
 {
   int wstat;
   int exitcode;
+  int len = 0;
+  char ch;
+  static char errstr[256];
 
   qmail_put(qq,"",1);
   if (!qq->flagerr) if (substdio_flush(&qq->ss) == -1) qq->flagerr = 1;
   close(qq->fde);
+  substdio_fdbuf(&qq->ss, read, qq->fdc, qq->buf, sizeof(qq->buf));
+  while (substdio_bget(&qq->ss, &ch, 1) && len < 255)
+  {
+    errstr[len] = ch; len++;
+  }
+  if (len > 0)
+    errstr[len] = 0; /* add str-term */
+  close(qq->fdc);
 
   if (wait_pid(&wstat,qq->pid) != qq->pid)
     return "Zqq waitpid surprise (#4.3.0)";
@@ -108,6 +130,7 @@
     case 115: /* compatibility */
     case 11: return "Denvelope address too long for qq (#5.1.3)";
     case 31: return "Dmail server permanently rejected message (#5.3.0)";
+    case 32: return "DPrivate key file does not exist (#5.3.5)";
     case 51: return "Zqq out of memory (#4.3.0)";
     case 52: return "Zqq timeout (#4.3.0)";
     case 53: return "Zqq write error or disk full (#4.3.0)";
@@ -127,6 +150,10 @@
     case 74: return "Zcommunication with mail server failed (#4.4.2)";
     case 91: /* fall through */
     case 81: return "Zqq internal bug (#4.3.0)";
+	case 82: /*- simscan exits with 82 */
+	case 88: /*- custom error */
+		 if (len > 2)
+			return errstr;
     case 120: return "Zunable to exec qq (#4.3.0)";
     default:
       if ((exitcode >= 11) && (exitcode <= 40))
diff -Naur netqmail-1.06.org/qmail-dk.9 netqmail-1.06/qmail-dk.9
--- netqmail-1.06.org/qmail-dk.9	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/qmail-dk.9	2018-04-03 17:28:43.667318619 +0530
@@ -0,0 +1,164 @@
+.TH qmail-dk 8
+.SH NAME
+qmail-dk \- sign/verify and queue a mail message for delivery
+.SH SYNOPSIS
+.B qmail-dk
+.SH DESCRIPTION
+.B qmail-dk
+has the same interface as
+.B qmail-queue
+except that it inserts an appropriate DomainKeys header before it
+queues the message.  To invoke
+.BR qmail-dk ,
+set QMAILQUEUE to point to qmail-dk in the environment when
+you send or receive email. qmail-dk will call
+.BR qmail-multi .
+To invoke an executable other than
+.B qmail-multi
+set DKQUEUE=bin/qmail-queue for example.
+
+.B qmail-dk
+supports DomainKey signing and verification.  It uses the libdomainkey
+and OpenSSL libraries.  To sign a message, set the
+.B DKSIGN
+environment variable to the pathname to the private key that will be
+used to sign the message.  If there is a % character in the environment
+variable, it is removed and replaced by the domain name in the From: header.
+If, after substituting the %, that file does not exist, the % will be removed.
+If the private key file does not exist and does not have a % character, the message will
+be rejected with error 32. The selector will be taken from the basename of the file.
+The private key should be created by 
+.BR dknewkey(8) .
+
+In the absense of DKSIGN and DKVERIFY environment variable, qmail-dk will sign the
+message if RELAYCLIENT environment variable is set and verify the message if RELAYCLIENT
+environment variable is not set. If DKVERIFY is set, you can disable dk verification, if
+RELAYCLIENT is set by setting RELAYCLIENT_NODKVERIFY environment variable.
+
+You can set various DK options in getopt style, by setting the environment variable DKSIGNOPTIONS
+ b <advice_length>    Length of Advice
+ c <canonicalization> simple, nofws
+ s <privkeyfile>
+ h                    include h= tag
+ r                    Skip Duplicate Headers
+.EX
+ DKSIGNOPTIONS="-h -r -c nofws"
+ sets the h= tag, skips duplicate headers and sets nofws canonicalization
+.EE
+
+To verify a message, set the
+.B DKVERIFY
+environment variable to a desired set of letters.  Precisely, if you
+want a libdomainkey return status to generate an error, include that
+letter, where A is the first return status (DK_STAT_OK), B is the
+second (DK_STAT_BADSIG), etc.  The letter should be uppercase if you
+want a permanent error to be returned and lowercase if you want a temporary error
+to be returned.
+
+The complete set of letters with the corresponding return status is given below
+
+ A - DK_STAT_OK           - Function completed successfully
+ B - DK_STAT_BADSIG       - Signature was available but failed to verify against
+                            domain specified key
+ C - DK_STAT_NOSIG        - No signature available in message
+ D - DK_STAT_NOKEY        - No public key available (permanent failure)
+ E - DK_STAT_BADKEY       - Unusable key, public if verifying, private if signing
+ F - DK_STAT_CANTVRFY     - Cannot get domain key to verify signature
+                            (temporary failure)
+ G - DK_STAT_SYNTAX       - Message is not valid syntax. Signature could not be
+                            created/checked
+ H - DK_STAT_NORESOURCE   - Could not get critical resource (temporary failure)
+ I - DK_STAT_ARGS         - Arguments are not usable.
+ J - DK_STAT_REVOKED      - Key has been revoked.
+ K - DK_STAT_INTERNAL     - cannot call this routine in this context. Internal error.
+ L - DK_STAT_GRANULARITY  - Granularity mismatch: sender doesn't match g= option.
+ M - DK_STAT_DUPLICATE    - duplicate Domainkey-Signature in message.
+
+For example, if you want to permanently reject messages that have a
+signature that has been revoked, include the letter 'K' in the
+.B DKVERIFY
+environment variable.  A conservative set of letters is
+.BR DEGIJKfh .
+Reject permanently BADSIG, NOKEY, BADKEY, SYNTAX, ARGS, REVOKED, and
+INTERNAL errors, and temporarily CANTVRFY and NORESOURCE. Add in
+.B B
+if you want to reject messages that have a signature that doesn't
+verify (presumably because the message is a forgery or has been
+damaged in transit.  Note that
+.B qmail-dk
+always inserts the 
+.B DomainKey-Status
+header, so that messages can be
+rejected at delivery time, or in the mail reader.
+
+Typically, you would sign messages generated on-host by setting
+.B DKSIGN
+in the environment before running an email program.  DKSIGN will be carried
+through qmail's sendmail emulation through 
+.B qmail-inject
+to
+.BR qmail-dk .
+You would also set it for
+.B qmail-smtpd
+at the same time
+.B RELAYCLIENT
+is set, most often in the tcpserver cdb file.  If a host is authorized
+to relay, you probably want to sign messages sent by that host.
+.B DKVERIFY
+should be set for all other hosts.
+
+If neither
+.B DKSIGN
+nor
+.B DKVERIFY
+are set, then
+.B DKSIGN
+will be set to QMAILHOME/control/domainkeys/%/default. The % will be replaced by the domain in the
+From: header. If such a file does not exist, then it will be set to
+QMAILHOME/control/domainkeys/default. If such a private key exists, it will be used to sign the
+domain. You can also set \fBDKKEY\fR to chose a key different from
+QMAILHOME/control/domainkeys/%/default. \fBDKKEY\fR can also have % character that will be
+replaced by the domain in the From: header.
+
+By default
+.B qmail-dk
+will use all of the headers when signing a message.
+The environment variable
+.B DKEXCLUDEHEADERS
+may be set to a colon-separated list of headers that are to be excluded from signing.
+
+.B qmail-dk
+will ordinarily spawn
+.BR qmail-multi ,
+but if DKQUEUE is set in the environment,
+the program that it points to will be executed instead.
+
+.SH "EXIT CODES"
+.B qmail-dk
+returns the same exit codes as qmail-queue with these additions:
+.TP 5
+.B 35
+The private key file does not exist.
+.TP 5
+.B 57
+Trouble waiting for qmail-queue to exit.
+.TP 5
+.B 58
+Unable to vfork.
+.TP 5
+.B 59
+Unable to create a pipe to qmail-queue.
+.SH "SEE ALSO"
+addresses(5),
+envelopes(5),
+qmail-header(5),
+dknewkey(8),
+dktest(8),
+qmail-inject(8),
+qmail-qmqpc(8),
+qmail-queue(8),
+qmail-send(8),
+qmail-smtpd(8),
+qmail-dkim(8),
+domain-keys(5)
+
diff -Naur netqmail-1.06.org/qmail-dk.c netqmail-1.06/qmail-dk.c
--- netqmail-1.06.org/qmail-dk.c	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/qmail-dk.c	2018-04-03 17:28:43.667318619 +0530
@@ -0,0 +1,866 @@
+/*
+ * $Log: qmail-dk.c,v $
+ * Revision 1.37  2013-01-24 22:42:07+05:30  Cprogrammer
+ * alternate code for chosing DKSIGN selector filename
+ *
+ * Revision 1.36  2011-11-10 14:31:42+05:30  Cprogrammer
+ * BUG ssout to be assigned only after pidopen()
+ *
+ * Revision 1.35  2011-11-07 09:35:25+05:30  Cprogrammer
+ * set ssout, sserr, ssin before executing other functions
+ *
+ * Revision 1.34  2011-07-29 09:28:48+05:30  Cprogrammer
+ * fixed key file name
+ *
+ * Revision 1.33  2011-07-28 19:34:45+05:30  Cprogrammer
+ * BUG - fixed opening of private key with absolute path
+ *
+ * Revision 1.32  2011-07-22 19:29:06+05:30  Cprogrammer
+ * fixed compilation error
+ *
+ * Revision 1.31  2011-07-22 14:39:53+05:30  Cprogrammer
+ * added DKDOMAIN feature to set d= tag
+ *
+ * Revision 1.30  2011-06-04 17:44:16+05:30  Cprogrammer
+ * remove % sign from private key if file not found
+ *
+ * Revision 1.29  2010-07-21 08:59:14+05:30  Cprogrammer
+ * use CONTROLDIR environment variable instead of a hardcoded control directory
+ *
+ * Revision 1.28  2009-08-13 18:36:39+05:30  Cprogrammer
+ * for verification continue in case of DK_SYNTAX errors
+ *
+ * Revision 1.27  2009-04-22 13:42:47+05:30  Cprogrammer
+ * made fd for custom error configurable through env variable ERROR_FD
+ *
+ * Revision 1.26  2009-04-21 09:05:14+05:30  Cprogrammer
+ * return relevant error message for reading private key
+ *
+ * Revision 1.25  2009-04-21 08:56:03+05:30  Cprogrammer
+ * return temp errors for temporary failures
+ *
+ * Revision 1.24  2009-04-21 08:15:39+05:30  Cprogrammer
+ * moved stralloc variable outside block
+ *
+ * Revision 1.23  2009-04-20 22:20:40+05:30  Cprogrammer
+ * added DKSIGNOPTIONS
+ *
+ * Revision 1.22  2009-04-07 11:38:02+05:30  Cprogrammer
+ * use TMPDIR env variable for tmp directory
+ *
+ * Revision 1.21  2009-04-05 12:52:10+05:30  Cprogrammer
+ * added preprocessor warning
+ *
+ * Revision 1.20  2009-03-31 08:21:12+05:30  Cprogrammer
+ * set dksign when RELAYCLIENT is defined when both dksign, dkverify are undefined
+ *
+ * Revision 1.19  2009-03-28 22:26:35+05:30  Cprogrammer
+ * use DKSIGN,DKVERIFY env variables if RELAYCLIENT is not set
+ *
+ * Revision 1.18  2009-03-28 22:02:32+05:30  Cprogrammer
+ * removed extra white space
+ *
+ * Revision 1.17  2009-03-28 11:34:51+05:30  Cprogrammer
+ * BUG fix. corrected setting of dksign, dkverify variables
+ *
+ * Revision 1.16  2009-03-22 16:58:13+05:30  Cprogrammer
+ * report custom errors to qmail-queue through custom error interface
+ *
+ * Revision 1.15  2009-03-21 15:15:56+05:30  Cprogrammer
+ * improved logic
+ *
+ * Revision 1.14  2009-03-20 22:35:24+05:30  Cprogrammer
+ * fix for multi-line headers
+ *
+ * Revision 1.13  2009-03-19 08:28:12+05:30  Cprogrammer
+ * added EXCLUDEHEADERS
+ *
+ * Revision 1.12  2009-03-14 17:11:32+05:30  Cprogrammer
+ * added DK_STAT_GRANULARITY
+ *
+ * Revision 1.11  2009-03-14 08:52:54+05:30  Cprogrammer
+ * look for domainkey in control/domainkeys
+ *
+ * Revision 1.10  2005-08-23 17:33:37+05:30  Cprogrammer
+ * gcc 4 compliance
+ *
+ * Revision 1.9  2005-04-01 21:42:04+05:30  Cprogrammer
+ * added DK_STAT_SYNTAX
+ * changed error codes
+ *
+ * Revision 1.8  2004-11-02 09:15:53+05:30  Cprogrammer
+ * commented out writing of Comments: header
+ *
+ * Revision 1.7  2004-10-24 21:32:00+05:30  Cprogrammer
+ * removed unecessary header files
+ *
+ * Revision 1.6  2004-10-22 20:28:18+05:30  Cprogrammer
+ * added RCS id
+ *
+ * Revision 1.5  2004-10-22 15:36:45+05:30  Cprogrammer
+ * removed readwrite.h
+ *
+ * Revision 1.4  2004-10-22 14:44:26+05:30  Cprogrammer
+ * use control_readnativefile to avoid skipping signure with '#' char
+ *
+ * Revision 1.3  2004-10-20 20:08:53+05:30  Cprogrammer
+ * libdomainkeys-0.62
+ *
+ * Revision 1.2  2004-09-23 22:55:32+05:30  Cprogrammer
+ * removed uneccessary header files
+ *
+ * Revision 1.1  2004-08-28 01:02:16+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
+#include <unistd.h>
+#include <stdlib.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include "sgetopt.h"
+#include "substdio.h"
+#include "open.h"
+#include "qmail.h"
+#include "sig.h"
+#include "fmt.h"
+#include "fd.h"
+#include "alloc.h"
+#include "str.h"
+#include "getln.h"
+#include "case.h"
+#include "stralloc.h"
+#include "datetime.h"
+#include "now.h"
+#include "wait.h"
+#include "auto_qmail.h"
+#include "env.h"
+#include "scan.h"
+#include "mess822.h"
+#include "control.h"
+#include "domainkeys.h"
+
+#define DEATH 86400	/*- 24 hours; _must_ be below q-s's OSSIFIED (36 hours) */
+#define ADDR 1003
+#define ADVICE_BUF 2048
+
+char            inbuf[2048];
+struct substdio ssin;
+char            outbuf[256];
+struct substdio ssout;
+struct substdio sserr;
+char            errbuf[256];
+
+datetime_sec    starttime;
+struct datetime dt;
+unsigned long   mypid;
+unsigned long   uid;
+char           *pidfn;
+int             messfd;
+int             readfd;
+char           *dksign = 0;
+char           *dkverify = 0;
+
+char          **MakeArgs(char *);
+void            FreeMakeArgs(char **);
+
+void
+die(e)
+	int             e;
+{
+	_exit(e);
+}
+
+void
+die_write()
+{
+	die(53);
+}
+
+void
+die_read()
+{
+	die(54);
+}
+
+void
+sigalrm()
+{
+	/*- thou shalt not clean up here */
+	die(52);
+}
+
+void
+sigbug()
+{
+	die(81);
+}
+
+void
+custom_error(char *flag, char *status, char *code)
+{
+	char           *c;
+
+	if (substdio_put(&sserr, flag, 1) == -1)
+		die_write();
+	if (substdio_put(&sserr, "qmail-dk: ", 10) == -1)
+		die_write();
+	if (substdio_puts(&sserr, status) == -1)
+		die_write();
+	if (code)
+	{
+		if (substdio_put(&sserr, " (#", 3) == -1)
+			die_write();
+		c = (*flag == 'Z') ? "4" : "5";
+		if (substdio_put(&sserr, c, 1) == -1)
+			die_write();
+		if (substdio_put(&sserr, code + 1, 4) == -1)
+			die_write();
+		if (substdio_put(&sserr, ")", 1) == -1)
+			die_write();
+	}
+	if (substdio_flush(&sserr) == -1)
+		die_write();
+	return;
+}
+
+void
+maybe_die_dk(e)
+	DK_STAT         e;
+{
+	switch (e)
+	{
+	case DK_STAT_NORESOURCE:
+		_exit(51);
+	case DK_STAT_INTERNAL:
+		_exit(81);
+	case DK_STAT_ARGS:
+		custom_error("Z", "Arguments are not usable. (#4.3.5)", 0);
+		_exit(88);
+	case DK_STAT_SYNTAX:
+		if (!dksign && dkverify)
+			return;
+		custom_error("Z", "Message is not valid syntax. Signature could not be created/checked (#4.6.0)", 0);
+		_exit(88);
+	case DK_STAT_CANTVRFY:
+		custom_error("Z", "Cannot get domainkeys to verify signature (#5.7.5)", 0);
+		_exit(88);
+	case DK_STAT_BADKEY:
+		if (env_get("DKVERIFY"))
+			custom_error("Z", "Unusable public key for verifying (#5.7.5)", 0);
+		else
+			custom_error("Z", "Unusable private key for signing (#5.7.15", 0);
+		_exit(88);
+	default:
+		return;
+	}
+}
+
+unsigned int
+pidfmt(s, seq)
+	char           *s;
+	unsigned long   seq;
+{
+	unsigned int    i;
+	unsigned int    len;
+	char           *tmpdir;
+
+	if (!(tmpdir = env_get("TMPDIR")))
+		tmpdir = "/tmp";
+	len = 0;
+	i = fmt_str(s, tmpdir);
+	len += i;
+	if (s)
+		s += i;
+	i = fmt_str(s, "/qmail-dk.");
+	len += i;
+	if (s)
+		s += i;
+	i = fmt_ulong(s, mypid);
+	len += i;
+	if (s)
+		s += i;
+	i = fmt_str(s, ".");
+	len += i;
+	if (s)
+		s += i;
+	i = fmt_ulong(s, starttime);
+	len += i;
+	if (s)
+		s += i;
+	i = fmt_str(s, ".");
+	len += i;
+	if (s)
+		s += i;
+	i = fmt_ulong(s, seq);
+	len += i;
+	if (s)
+		s += i;
+	++len;
+	if (s)
+		*s++ = 0;
+
+	return len;
+}
+
+void
+pidopen()
+{
+	unsigned int    len;
+	unsigned long   seq;
+
+	seq = 1;
+	len = pidfmt((char *) 0, seq);
+	if (!(pidfn = alloc(len)))
+		die(51);
+	for (seq = 1; seq < 10; ++seq)
+	{
+		if (pidfmt((char *) 0, seq) > len)
+			die(81); /*- paranoia */
+		pidfmt(pidfn, seq);
+		if ((messfd = open_excl(pidfn)) != -1)
+			return;
+	}
+	die(63);
+}
+
+char            tmp[FMT_ULONG];
+DK_LIB         *dklib;
+DK             *dk;
+DK_STAT         st;
+stralloc        dkoutput = { 0 };    /*- Domainkey-Signature */
+stralloc        dksignature = { 0 }; /*- content of private signature */
+stralloc        dkopts = { 0 };
+char           *dkqueue = 0;
+char           *dkexcludeheaders;
+
+static void
+write_signature(DK *dk, char *dk_selector, char *keyfn,
+	int advicelen, int opth, char *canon)
+{
+	unsigned char   advice[ADVICE_BUF];
+	char           *selector, *from, *tmp;
+	static stralloc keyfnfrom = { 0 };
+	int             i;
+
+	from = dk_from(dk);
+	if (keyfn[0] != '/')
+	{
+		if (!stralloc_copys(&keyfnfrom, "control/"))
+			die(51, 1);
+	}
+	i = str_chr(keyfn, '%');
+	if (keyfn[i])
+	{
+		if (keyfn[0] == '/')
+		{
+			if (!stralloc_copyb(&keyfnfrom, keyfn, i))
+				die(51, 1);
+		} else
+		if (!stralloc_catb(&keyfnfrom, keyfn, i))
+			die(51, 1);
+		if (!stralloc_cats(&keyfnfrom, from))
+			die(51);
+		if (!stralloc_cats(&keyfnfrom, keyfn + i + 1))
+			die(51);
+		if (!stralloc_0(&keyfnfrom))
+			die(51);
+		if (access(keyfnfrom.s, F_OK))
+		{
+			/*- since file is not found remove '%' sign */
+			keyfnfrom.len = 8;
+			if (keyfn[0] == '/')
+			{
+				if (!stralloc_copyb(&keyfnfrom, keyfn, i))
+					die(51, 1);
+			} else
+			if (!stralloc_catb(&keyfnfrom, keyfn, i))
+				die(51, 1);
+			if ((i - 1) > 0 && keyfn[i - 1] == '/' && keyfn[i + 1] == '/')
+				i++;
+			if (!stralloc_cats(&keyfnfrom, keyfn + i + 1))
+				die(51);
+			if (!stralloc_0(&keyfnfrom))
+				die(51);
+		} 
+	} else
+	{
+		if (keyfn[0] == '/')
+		{
+			if (!stralloc_copys(&keyfnfrom, keyfn))
+				die(51, 1);
+		} else
+		if (!stralloc_cats(&keyfnfrom, keyfn))
+			die(51, 1);
+		if (!stralloc_0(&keyfnfrom))
+			die(51);
+	}
+	switch (control_readnativefile(&dksignature, keyfnfrom.s, 1))
+	{
+	case 0: /*- file not present */
+		/*
+		 * You may have multiple domains, but may chose to sign
+		 * only for few domains which have the key present. Do not
+		 * treat domains with missing key as an error.
+		 */
+		if (keyfn[i])
+			return;
+		die(32);
+	case 1:
+		break;
+	default:
+		custom_error("Z", "Unable to read private key. (#4.3.0)", 0);
+		_exit(88);
+	}
+	for (i = 0; i < dksignature.len; i++)
+	{
+		if (dksignature.s[i] == '\0')
+			dksignature.s[i] = '\n';
+	}
+	if (!stralloc_0(&dksignature))
+		die(51);
+	st = dk_getsig(dk, dksignature.s, advice, advicelen);
+	maybe_die_dk(st);
+	if (!dk_selector)
+	{
+		selector = keyfn;
+		while (*keyfn)
+		{
+			if (*keyfn == '/')
+				selector = keyfn + 1;
+			keyfn++;
+		}
+	} else
+		selector = dk_selector;
+	if (!stralloc_cats(&dkoutput,
+#if 0
+		"Comment: DomainKeys? See http://antispam.yahoo.com/domainkeys\n"
+#endif
+		"DomainKey-Signature: a=rsa-sha1; q=dns; c="))
+		die(51);
+	if (!stralloc_cats(&dkoutput, canon))
+		die(51);
+	if (!stralloc_cats(&dkoutput, ";\n"))
+		die(51);
+	if (!stralloc_cats(&dkoutput, "    s="))
+		die(51);
+	if (!stralloc_cats(&dkoutput, selector))
+		die(51);
+	if (!stralloc_cats(&dkoutput, "; d="))
+		die(51);
+	tmp = env_get("DKDOMAIN");
+	if (from || tmp)
+	{
+		if (!stralloc_cats(&dkoutput, tmp ? tmp : from))
+			die(51);
+	} else
+	if (!stralloc_cats(&dkoutput, "unknown"))
+		die(51);
+	if (!stralloc_cats(&dkoutput, ";\n"))
+		die(51);
+	if (!stralloc_cats(&dkoutput, "    b="))
+		die(51);
+	if (!stralloc_cats(&dkoutput, (char *) advice))
+		die(51);
+	if (dkexcludeheaders || opth)
+	{
+		if ((i = dk_headers(dk, NULL)) > 0)
+		{
+			if (!(tmp = alloc(i)))
+				die(51);
+			if (!dk_headers(dk, tmp))
+				die(51);
+			if (!stralloc_cats(&dkoutput, ";\n    h="))
+				die(51);
+			if (!stralloc_cats(&dkoutput, tmp))
+				die(51);
+			alloc_free(tmp);
+		}
+	}
+	if (!stralloc_cats(&dkoutput, ";\n"))
+		die(51);
+}
+
+int
+find_header(stralloc *line)
+{
+	static stralloc headers = { 0 };
+	int             n, i, j;
+
+	for (n = 0; n < line->len; ++n)
+	{
+		if (line->s[n] == ':')
+			break;
+	}
+	if (n == line->len)
+		return -1;
+	if (!headers.len)
+	{
+		if (!stralloc_copys(&headers, ""))
+			die(51);
+		if (dkexcludeheaders)
+		{
+			if (!stralloc_cats(&headers, dkexcludeheaders))
+				die(51);
+			if (!stralloc_append(&headers, ":"))
+				die(51);
+		}
+	}
+	if (!headers.len)
+		return 0;
+	for (i = j = 0; i < headers.len; ++i)
+	{
+		if (headers.s[i] != ':')
+			continue;
+		if (i - j == n && !case_diffb(headers.s + j, n, line->s))
+			return 1;
+		j = i + 1;
+	}
+	return 0;
+}
+
+int
+dk_setoptions(char **selector, int *advicelen, int *opth, int *optr, int *optc,
+	char **canon, char *signOptions)
+{
+	char          **argv;
+	int             ch, argc;
+
+	*opth = 0;
+	*optr = 0;
+	*optc = DK_CANON_NOFWS;
+	*canon = "nofws";
+	*selector = 0;
+	if (!signOptions)
+		return (0);
+	if (!stralloc_copys(&dkopts, "qmail-dk "))
+		die(51);
+	if (!stralloc_cats(&dkopts, signOptions))
+		die(51);
+	if (!stralloc_0(&dkopts))
+		die(51);
+	if (!(argv = MakeArgs(dkopts.s)))
+		die(51);
+	for (argc = 0;argv[argc];argc++);
+	while ((ch = sgopt(argc, argv, "hrb:c:s:")) != sgoptdone)
+	{
+		switch (ch)
+		{
+		case 'h':
+			*opth = 1;
+			break;
+		case 'r':
+			*optr = 1;
+			*opth = 1;
+			break;
+		case 'b':
+			*advicelen = atoi(optarg);
+			if (*advicelen > ADVICE_BUF);
+				*advicelen = ADVICE_BUF;
+			break;
+		case 'c':
+			if (!str_diffn("simple\0", optarg, 7))
+			{
+				*optc = DK_CANON_SIMPLE;
+				*canon = "simple";
+			}
+			break;
+		case 's':
+			*selector = optarg;
+			break;
+		default:
+			FreeMakeArgs(argv);
+			return (1);
+		}
+	} /*- while ((ch = sgopt(argc, argv, "hrb:c:s:")) != sgoptdone) */
+	FreeMakeArgs(argv);
+	return (0);
+}
+
+static char    *binqqargs[2] = { "bin/qmail-queue", 0 };
+
+int
+main(int argc, char *argv[])
+{
+	int             errfd, pim[2];
+	int             wstat, match, opth = 0, optr = 0, optc = DK_CANON_NOFWS,
+					advicelen = ADVICE_BUF;
+	char           *x, *relayclient, *canon = "nofws", *selector = 0; 
+	stralloc        line = {0}, dkfn = {0};
+	unsigned long   pid;
+
+	sig_blocknone();
+	umask(033);
+	if (!(x = env_get("ERROR_FD")))
+		errfd = CUSTOM_ERR_FD;
+	else
+		scan_int(x, &errfd);
+	substdio_fdbuf(&sserr, write, errfd, errbuf, sizeof(errbuf));
+	if (chdir(auto_qmail) == -1)
+		die(61);
+	dkqueue = env_get("DKQUEUE");
+	if (dkqueue && *dkqueue)
+		binqqargs[0] = dkqueue;
+	dksign = env_get("DKSIGN");
+	dkverify = env_get("DKVERIFY");
+	relayclient = env_get("RELAYCLIENT");
+	if (dkverify && relayclient && env_get("RELAYCLIENT_NODKVERIFY")) {
+		execv(*binqqargs, binqqargs);
+		die(120, 0);
+	}
+	if (!dksign && !dkverify && relayclient)
+	{
+		if (!(dksign = env_get("DKKEY")))
+		{
+			if (!stralloc_copys(&dkfn, "domainkeys/%/default"))
+				die(51);
+			if (!stralloc_0(&dkfn))
+				die(51);
+			dksign = dkfn.s;
+		}
+	}
+	if (dksign || dkverify)
+	{
+		if (!(dklib = dk_init(&st)))
+		{
+			maybe_die_dk(st);
+			custom_error("Z", "dk initialization failed (#4.3.0)", 0);
+			_exit(88);
+		}
+	}
+	/*- Initialization */
+	if (dksign)
+	{
+		if (dk_setoptions(&selector, &advicelen, &opth, &optr, &optc, &canon, env_get("DKSIGNOPTIONS")))
+		{
+			custom_error("Z", "Invalid DKSIGNOPTIONS (#4.3.0)", 0);
+			_exit(88);
+		}
+		if (!(dk = dk_sign(dklib, &st, optc)))
+		{
+			maybe_die_dk(st);
+			custom_error("Z", "dk_sign failed (#4.3.0)", 0);
+			_exit(88);
+		}
+		if (optr && dk_setopts(dk, DKOPT_RDUPE) != DK_STAT_OK)
+		{
+			custom_error("Z", "DKOPT_RDUPE failed (#4.3.0)", 0);
+			_exit(88);
+		}
+	} else
+	if (dkverify)
+	{
+		if (!(dk = dk_verify(dklib, &st)))
+		{
+			maybe_die_dk(st);
+			custom_error("Z", "dk_verify failed (#4.3.0)", 0);
+			_exit(88);
+		}
+	}
+	mypid = getpid();
+	uid = getuid();
+	starttime = now();
+	datetime_tai(&dt, starttime);
+	sig_pipeignore();
+	sig_miscignore();
+	sig_alarmcatch(sigalrm);
+	sig_bugcatch(sigbug);
+	alarm(DEATH);
+	pidopen();
+	if ((readfd = open_read(pidfn)) == -1)
+		die(63);
+	if (unlink(pidfn) == -1)
+		die(63);
+	substdio_fdbuf(&ssin, read, 0, inbuf, sizeof(inbuf));
+	substdio_fdbuf(&ssout, write, messfd, outbuf, sizeof(outbuf));
+	dkexcludeheaders = env_get("DKEXCLUDEHEADERS");
+	if (dkexcludeheaders)
+	{
+		int             hdr_continue, in_header = 1;
+
+		hdr_continue = 0;
+		for (;;)
+		{
+	
+			if (getln(&ssin, &line, &match, '\n') == -1)
+				die_read();
+			if (!match && line.len == 0)
+				break;
+			if (substdio_put(&ssout, line.s, line.len) == -1)
+				die_write();
+			if (!dksign && !dkverify)
+				continue;
+			if (in_header && !mess822_ok(&line))
+				in_header = 0;
+			if (in_header)
+			{
+				if (line.s[0] == ' ' || line.s[0] == '\t')
+				{
+					if (hdr_continue)
+						continue;
+				} else
+				if (find_header(&line) == 1) {
+					hdr_continue = 1;
+					continue;
+				} else
+					hdr_continue = 0;
+			}
+			if (match)
+			{
+				st = dk_message(dk, (unsigned char *) line.s, line.len - 1);
+				maybe_die_dk(st);
+				st = dk_message(dk, (unsigned char *) "\r\n", 2);
+			} else
+				st = dk_message(dk, (unsigned char *) line.s, line.len);
+			maybe_die_dk(st);
+		}
+	} else
+	for (;;)
+	{
+		register int    n;
+		register char  *x;
+		int             i;
+
+		if ((n = substdio_feed(&ssin)) < 0)
+			die_read();
+		if (!n)
+			break;
+		x = substdio_PEEK(&ssin);
+		if (dksign || dkverify)
+		{
+			for (i = 0; i < n; i++)
+			{
+				if (x[i] == '\n')
+					st = dk_message(dk, (unsigned char *) "\r\n", 2);
+				else
+					st = dk_message(dk, (unsigned char *) x + i, 1);
+				maybe_die_dk(st);
+			}
+		}
+		if (substdio_put(&ssout, x, n) == -1)
+			die_write();
+		substdio_SEEK(&ssin, n);
+	}
+	if (substdio_flush(&ssout) == -1)
+		die_write();
+	if (dksign || dkverify)
+	{
+		st = dk_eom(dk, (void *) 0);
+		maybe_die_dk(st);
+		if (dksign)
+			write_signature(dk, selector, dksign, advicelen, opth, canon);
+		else
+		if (dkverify)
+		{
+			char           *status = 0, *code = 0;
+
+			if (!stralloc_copys(&dkoutput, "DomainKey-Status: "))
+				die(51);
+			switch (st)
+			{
+			case DK_STAT_OK:
+				status = "good        ";
+				break;
+			case DK_STAT_BADSIG:
+				status = "bad         ";
+				code = "X.7.5";
+				break;
+			case DK_STAT_NOSIG:
+				status = "no signature";
+				code = "X.7.5";
+				break;
+			case DK_STAT_NOKEY:
+			case DK_STAT_CANTVRFY:
+				status = "no key      ";
+				code = "X.7.0";
+				break;
+			case DK_STAT_BADKEY:
+				status = "bad key     ";
+				code = "X.7.5";
+				break;
+			case DK_STAT_INTERNAL:
+				status = "bad format  ";
+				code = "X.3.0";
+				break;
+			case DK_STAT_ARGS:
+				status = "bad format  ";
+				code = "X.3.5";
+				break;
+			case DK_STAT_SYNTAX:
+				status = "bad format  ";
+				code = "X.6.0";
+				break;
+			case DK_STAT_NORESOURCE:
+				status = "no resources";
+				code = "X.3.0";
+				break;
+			case DK_STAT_REVOKED:
+				status = "revoked     ";
+				code = "X.7.5";
+				break;
+			case DK_STAT_GRANULARITY:
+				status = "bad sender  ";
+				code = "X.7.5";
+				break;
+			}
+			if (!stralloc_cats(&dkoutput, status))
+				die(51);
+			if (!stralloc_cats(&dkoutput, "\n"))
+				die(51);
+			if (dkverify[str_chr(dkverify, 'A' + st)])
+			{
+				custom_error("D", status, code); /*- return permanent error */
+				die(88);
+			}
+			if (dkverify[str_chr(dkverify, 'a' + st)])
+			{
+				custom_error("Z", status, code); /*- return temporary error */
+				die(88);
+			}
+		}
+	}
+	if (pipe(pim) == -1)
+		die(59);
+	switch (pid = vfork())
+	{
+	case -1:
+		close(pim[0]);
+		close(pim[1]);
+		die(58);
+	case 0:
+		close(pim[1]);
+		if (fd_move(0, pim[0]) == -1)
+			die(120);
+		execv(*binqqargs, binqqargs);
+		die(120);
+	}
+	close(pim[0]);
+	substdio_fdbuf(&ssin, read, readfd, inbuf, sizeof(inbuf));
+	substdio_fdbuf(&ssout, write, pim[1], outbuf, sizeof(outbuf));
+	if (substdio_bput(&ssout, dkoutput.s, dkoutput.len) == -1) /*- write DK signature */
+		die_write();
+	switch (substdio_copy(&ssout, &ssin))
+	{
+	case -2:
+		die_read();
+	case -3:
+		die_write();
+	}
+	if (substdio_flush(&ssout) == -1)
+		die_write();
+	close(pim[1]);
+	if (wait_pid(&wstat, pid) != pid)
+		die(57);
+	if (wait_crashed(wstat))
+		die(57);
+	die(wait_exitcode(wstat));
+	/*- Not Reached */
+	exit(0);
+}
+
+void
+getversion_qmail_dk_c()
+{
+	static char    *x = "$Id: qmail-dk.c,v 1.37 2013-01-24 22:42:07+05:30 Cprogrammer Exp mbhangui $";
+
+	x++;
+}
diff -Naur netqmail-1.06.org/qmail-dkim.9 netqmail-1.06/qmail-dkim.9
--- netqmail-1.06.org/qmail-dkim.9	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/qmail-dkim.9	2019-02-15 19:36:44.292532249 +0530
@@ -0,0 +1,321 @@
+.TH qmail-dkim 8
+.SH NAME
+qmail-dkim \- sign/verify using DKIM (SSP/ADSP optionally) and queue a mail message for delivery
+.SH SYNOPSIS
+.B qmail-dkim
+.SH DESCRIPTION
+.B qmail-dkim
+has the same interface as
+.B qmail-queue
+except that it inserts an appropriate DKIM header (rfc4871) before it
+queues the message.  To invoke
+.BR qmail-dkim ,
+set QMAILQUEUE to point to qmail-dkim in the environment when
+you send or receive email. qmail-dkim will call
+.BR qmail-queue .
+To invoke an executable other than
+.B qmail-queue
+set DKIMQUEUE=bin/qmail-dk for example.
+
+.B qmail-dkim
+supports DKIM signing and verification and can optionally use
+.B Sender Signing Practice (SSP)
+or
+.B Author Domain Signing Practice.
+It uses the libdkim and OpenSSL libraries.  To sign a message, set the
+.B DKIMSIGN
+environment variable to the pathname of the private key that will be
+used to sign the message. If there is a % character in the environment
+variable, it is removed and replaced by the domain name in the From: header.
+If, after substituting the %, that file does not exist, the % character will be
+removed. If the private key file does not exist and does not have a % character,
+the message will be rejected with error 35. The selector (s=) will be taken from
+the basename of the file. The private key should be created by 
+.BR dknewkey(8) .
+
+In the absense of DKSIGN and DKVERIFY environment variable, qmail-dkim will sign the
+message if RELAYCLIENT or AUTHINFO environment variable is set. It will verify the message
+if RELAYCLIENT or AUTHINFO environment variable is not set. Even if DKVERIFY is set, you can disable dkim
+verification, if RELAYCLIENT or AUTHINFO is set, by setting RELAYCLIENT_NODKVERIFY environment variable.
+
+You can set various DKIM options in getopt style, by setting the environment variable
+.B DKIMSIGNOPTIONS
+
+ b <standard>         1 - allman, 2 - ietf or 3 - both
+ c <canonicalization> r for relaxed [DEFAULT], s - simple,
+                      t relaxed/simple, u - simple/relaxed
+ l                    include body length tag
+ q                    include query method tag;
+ t                    include a timestamp tag
+ h                    include copied headers
+ i <identity>         the identity, if not provided it will not be included
+ x <expire_time>      the expire time in seconds since epoch
+                      ( DEFAULT = current time + 604800)
+                      if set to - then it will not be included
+ z <hash>             1 for sha1, 2 for sha256, 3 for both
+
+.EX
+ DKIMSIGNOPTIONS="-b 1 -c r -q"
+ sets allman standard, with relaxed canonicalization and include query method tag
+.EE
+
+Apart from setting
+.BR DKIMSIGNOPTIONS ,
+you can set the identity and the expire time by setting
+.B DKIMIDENTITY
+and
+.B DKIMEXPIRE
+respectively.
+.B DKIMIDENTITY
+takes precedence over -i option specified in
+.BR DKIMSIGNOPTIONS.
+Similarly,
+.B DKIMEXPIRE
+takes precedence over -x option specifed in
+.BR DKIMSIGNOPTIONS.
+.B qmail-dkim
+uses the domain found in the Sender: header to set the domain tag. If not it uses the
+From: header. You can override this by setting 
+.B DKIMDOMAIN
+environment variable.
+.B DKIMDOMAIN
+can be set to an email address or a domain (without the at sign).
+
+To verify a message, set the
+.B DKIMVERIFY
+environment variable to a desired set of letters.  Precisely, if you
+want a libdkim return status to generate an error, include that
+letter, where A is the first return status (DKIM_SUCCESS), B is the
+second (DKIM_FINISHED_BODY), etc.  The letter should be uppercase if you
+want a permanent error to be returned, and lowercase if
+you want a temporary error to be returned (exit code 88). If you omit the letter,
+\fBqmail-dkim\fR will not issue any error inspite of DKIM verification failure. It
+will return success and the email will get delivered. The complete set of letters
+with the corresponding return status is given below
+
+ A - DKIM_SUCCESS                        - Function executed successfully
+ B - DKIM_FINISHED_BODY                  - process result: no more message
+                                           body is needed
+ C - DKIM_PARTIAL_SUCCESS                - verify result: at least one
+                                           but not all signatures verified
+ D - DKIM_NEUTRAL                        - verify result: no signatures
+                                           verified but message is
+                                           not suspicious
+ E - DKIM_SUCCESS_BUT_EXTRA              - signature result: signature
+                                           verified but it did not
+                                           include all of the body
+ F - DKIM_3PS_SIGNATURE                  - 3rd-party signature
+ G - DKIM_FAIL                           - Function failed to execute
+ H - DKIM_BAD_SYNTAX                     - signature error: DKIM-Signature
+                                           could not parse or has bad
+                                           tags/values
+ I - DKIM_SIGNATURE_BAD                  - signature error: RSA verify
+                                           failed
+ J - DKIM_SIGNATURE_BAD_BUT_TESTING      - signature error: RSA verify
+                                           failed but testing
+ K - DKIM_SIGNATURE_EXPIRED              - signature error: x= is old
+ L - DKIM_SELECTOR_INVALID               - signature error: selector doesn't
+                                           parse or contains invalid values
+ M - DKIM_SELECTOR_GRANULARITY_MISMATCH  - signature error: selector
+                                           g= doesn't match i=
+ N - DKIM_SELECTOR_KEY_REVOKED           - signature error: selector
+                                           p= empty
+ O - DKIM_SELECTOR_DOMAIN_NAME_TOO_LONG  - signature error: selector domain
+                                           name too long to request
+ P - DKIM_SELECTOR_DNS_TEMP_FAILURE      - signature error: temporary dns
+                                           failure requesting selector
+ Q - DKIM_SELECTOR_DNS_PERM_FAILURE      - signature error: permanent dns
+                                           failure requesting selector
+ R - DKIM_SELECTOR_PUBLIC_KEY_INVALID    - signature error: selector
+                                           p= value invalid or wrong format
+ S - DKIM_NO_SIGNATURES                  - no signatures
+ T - DKIM_NO_VALID_SIGNATURES            - no valid signatures
+ U - DKIM_BODY_HASH_MISMATCH             - sigature verify error: message
+                                           body does not hash to bh value
+ V - DKIM_SELECTOR_ALGORITHM_MISMATCH    - signature error: selector
+                                           h= doesn't match signature a=
+ W - DKIM_STAT_INCOMPAT                  - signature error: incompatible v=
+ X - DKIM_UNSIGNED_FROM                  - signature error: not all message's
+                                           From headers in signature
+
+For example, if you want to permanently reject messages that have a
+signature that is expired, include the letter 'K' in the
+.B DKIMVERIFY
+environment variable.  A conservative set of letters is
+.BR FGHIKLMNOQRTUVWjp .
+Reject permanently 3PS, FAILURE, SYNTAX, SIGNATURE_BAD, SIGNATURE_EXPIRED, SELECTOR_INVALID,
+GRANULARITY_MISMATCH, SELECTOR_KEY_REVOKED, DOMAIN_NAME_TOO_LONG, SELECTOR_PUBLIC_KEY_INVALID,
+NO_VALID_SIGNATURES and BODY_HASH_MISMATCH errors, and temporarily SIGNATURE_BAD_BUT_TESTING and DNS_TEMP_FAILURE .
+Add in
+.B S
+if you want to reject messages that do not have a DKIM signature. You can use the control files
+signaturedomains and nosignature domains (See Below) to further fine tune the action to be
+taken when a mail arrives with no DKIM signature.  Note that
+.B qmail-dkim
+always inserts the 
+.B DKIM-Status
+header, so that messages can be
+rejected later at delivery time, or in the mail reader. In that case you may set
+.B DKIMVERIFY
+to an empty string. If you want to check all message's From header in signature set the
+\fBUNSIGNED_FROM\fR environment variable to an empty string.
+
+qmail-dkim supports signing practice which can be additonall checked when a signature
+verifcation fails -
+
+.BR "SSP - Sender Signing Practice"
+
+and
+
+.BR "ADSP - Author Domain Signing Practice" .
+
+When a signature fails to verify for a message, you can use SSP/ADSP to determine if the message is suspicious or not.
+To verify a message against SSP/ADSP, set the
+.B DKIMPRACTICE
+environment variable to the desired set of letters allowed for DKIMVERIFY environment variable.
+SSP/ADSP should be used only when signature verification fails. SSP/ADSP should be invoked only when libdkim returns the
+error codes (F,G,H,I,J,K,L,M,N,P,Q,R,S,T,U,V,W,X) for signature verification. In case you want to test
+against SSP/ADSP only for DKIM_NO_SIGNATURE and DKIM_NO_VALID_SIGNATURE
+set the environment variable 
+.BR DKIMPRACTICE="ST" .
+If you want automatic behaviour, set DKIMADSPERROR to an empty string. In this case ADSP/SSP will be used when return code
+matches "FGHIJKLMNPQRSTUVWX".
+.B qmail-dkim
+uses ADSP as the default signing practice. You can override this by setting the SIGN_PRACTICE to ssp, adsp, local (lowercase).
+if you set SIGN_PRACTICE to \fIlocal\fB,
+.B qmail-dkim
+will check the domain against the control file
+.I signaturedomains
+(See Below). If the domain is found listed in
+.I signaturedomains
+.B qmail-dkim
+will bypass ADSP/SSP and return DKIM_FAIL if signature fails to verify. Setting SIGN_PRACTICE
+to anything else will cause
+.B qmail-dkim
+to disable Signing Practice.
+
+If ADSP or SSP is checked,
+.B qmail-dkim
+will insert the
+.B X-DKIM-ADSP
+or
+.B X-DKIM-SSP
+header as given below
+
+ A - DKIM_SUCCESS             - Message passes ADSP test
+ B - DKIM_ADSP_UNKNOWN        - some messages may be signed
+ C - DKIM_ADSP_ALL            - All message are signed with author signature 
+ D - DKIM_ADSP_DISCARDABLE    - messages which fail verification are Discardable
+ E - DKIM_ADSP_SCOPE          - domain is out of scope
+ F - DKIM_ADSP_TEMPFAIL       - Temporary Error 
+
+ or
+
+ A - DKIM_SUCCESS            - Message passes ADSP test
+ B - DKIM_SSP_UNKNOWN        - some messages may be signed
+ C - DKIM_SSP_ALL            - All message are signed with author signature 
+ D - DKIM_SSP_STRICT         - messages which fail verification are Discardable
+ E - DKIM_SSP_SCOPE          - domain is out of scope
+ F - DKIM_SSP_TEMPFAIL       - Temporary Error 
+
+You can have a control file
+.I signaturedomains
+containing a list of domains which you know are sure to sign messages using DKIM. If a message comes
+from a domain listed in
+.IR signaturedomains ,
+and the signature fails verification (any of DKIM failure status), 
+.B qmail-dkim
+will bypass ADSP/SSP checks and return DKIM_FAIL. The name of this control file can be
+overriden by the environment variable
+.BR SIGNATUREDOMAINS .
+
+You can have a control file
+.I nosignaturedomains
+containing a list of domains which you know are sure not to sign messages using DKIM.
+If a message comes from a domain listed in
+.IR nosignaturedomains ,
+and does not have a DKIM-Signature header, 
+.B qmail-dkim
+will bypass ADSP/SSP checks and return DKIM_NEUTRAL. The wildcard entry '*' in this file, will
+result in all mails which do not have a signature to pass DKIM test (unless the domain is listed
+in the control file
+.BR signaturedomains ).
+The name of this control file can be overriden by the environment variable
+.BR NOSIGNATUREDOMAINS .
+
+Typically, you would sign messages generated on-host by setting
+.B DKIMSIGN
+in the environment before running an email program.  DKIMSIGN will be carried
+through qmail's sendmail emulation through 
+.B qmail-inject
+to
+.BR qmail-dkim .
+You would also set it for
+.B qmail-smtpd
+at the same time
+.B RELAYCLIENT
+is set, most often in the tcpserver cdb file.  If a host is authorized
+to relay, you probably want to sign messages sent by that host.
+.B DKIMVERIFY
+should be set for all other hosts.
+
+If neither
+.B DKIMSIGN
+nor
+.B DKIMVERIFY
+are set, then
+.B DKIMSIGN
+will be set to QMAILHOME/control/domainkeys/%/default. The % will be replaced by the domain in the
+From: header. If such a file does not exist, then it will be set to
+QMAILHOME/control/domainkeys/default. If such a private key exists, it will be used to sign the
+domain. You can also set \fBDKIMKEY\fR to chose a key different from
+QMAILHOME/control/domainkeys/%/default. \fBDKIMKEY\fR can also have % character that will be
+replaced by the domain in the From: header. If the private key does not exist, qmail-dkim
+will exit with return code 32.
+
+By default
+.B qmail-dkim
+will use all of the headers when signing a message.
+
+.B qmail-dkim
+will ordinarily spawn
+.BR qmail-queue ,
+but if DKIMQUEUE is set in the environment,
+the program that it points to will be executed instead.
+
+.SH "EXIT CODES"
+.B qmail-dkim
+returns the same exit codes as qmail-queue with these additions:
+.TP 5
+.B 32
+The private key file does not exist.
+.TP 5
+.B 57
+Trouble waiting for qmail-queue to exit.
+.TP 5
+.B 58
+Unable to vfork.
+.TP 5
+.B 59
+Unable to create a pipe to qmail-queue.
+.SH "SEE ALSO"
+addresses(5),
+envelopes(5),
+qmail-header(5),
+dknewkey(8),
+dktest(8),
+qmail-inject(8),
+qmail-qmqpc(8),
+qmail-queue(8),
+qmail-send(8),
+qmail-smtpd(8),
+qmail-dk(8),
+domain-keys(5)
+
+.SH "AUTHORS"
+
+Manvendra Bhangui.
+.SH PROBLEMS
+Problems with
+.B qmail-dkim
+should be forwarded to "Manvendra Bhangui" <mbhangui@gmail.com>
diff -Naur netqmail-1.06.org/qmail-dkim.c netqmail-1.06/qmail-dkim.c
--- netqmail-1.06.org/qmail-dkim.c	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/qmail-dkim.c	2019-02-17 11:30:40.804148867 +0530
@@ -0,0 +1,1400 @@
+/*
+ * $Log: qmail-dkim.c,v $
+ * Revision 1.49  2018-08-08 23:58:01+05:30  Cprogrammer
+ * issue success if at lease one one good signature is found
+ *
+ * Revision 1.48  2017-09-05 12:37:16+05:30  Cprogrammer
+ * added missing DKIM_MFREE()
+ *
+ * Revision 1.47  2016-06-03 09:57:59+05:30  Cprogrammer
+ * moved qmail-multi to sbin
+ *
+ * Revision 1.46  2016-05-17 19:44:58+05:30  Cprogrammer
+ * use auto_control, set by conf-control to set control directory
+ *
+ * Revision 1.45  2016-03-01 18:48:02+05:30  Cprogrammer
+ * added env variable UNSIGNED_SUBJECT to verify dkim without subject field
+ *
+ * Revision 1.44  2015-12-15 16:05:58+05:30  Cprogrammer
+ * increased buffer size for long header issue
+ *
+ * Revision 1.43  2014-01-22 22:45:01+05:30  Cprogrammer
+ * treat AUTHINFO environment like RELAYCLIENT environment variable
+ *
+ * Revision 1.42  2013-10-01 17:11:24+05:30  Cprogrammer
+ * fixed QMAILQUEUE recursion
+ *
+ * Revision 1.41  2013-09-16 22:16:35+05:30  Cprogrammer
+ * corrected logic for RELAYCLIENT_NODKIMVERIFY
+ *
+ * Revision 1.40  2013-09-13 16:34:35+05:30  Cprogrammer
+ * turn off verification if RELAYCLIENT, DKIMVERIFY and RELAYCLIENT_NODKIMVERIFY is set
+ *
+ * Revision 1.39  2013-08-18 15:53:30+05:30  Cprogrammer
+ * revert back to default verification mode if both dksign, dkverify are not set
+ *
+ * Revision 1.38  2013-08-17 15:00:33+05:30  Cprogrammer
+ * BUG - corrected location of private key when % sign is removed
+ *
+ * Revision 1.37  2013-01-24 22:37:22+05:30  Cprogrammer
+ * BUG (fix by Piotr Gronek) - DKIM_FREE(results) called before call to ParseTagValues()
+ * alternate code for DKIMSIGN selector file name
+ *
+ * Revision 1.36  2012-08-16 08:01:46+05:30  Cprogrammer
+ * do not skip X-Mailer headers
+ *
+ * Revision 1.35  2011-11-10 14:32:08+05:30  Cprogrammer
+ * BUG ssout to be assigned only after pidopen()
+ *
+ * Revision 1.34  2011-11-07 09:35:59+05:30  Cprogrammer
+ * set ssout, sserr, ssin before executing other functions
+ *
+ * Revision 1.33  2011-07-29 09:29:17+05:30  Cprogrammer
+ * fixed key file name
+ *
+ * Revision 1.32  2011-07-28 19:36:36+05:30  Cprogrammer
+ * BUG - fixed opening of private key with absolute path
+ *
+ * Revision 1.31  2011-07-22 14:40:05+05:30  Cprogrammer
+ * fixed checking of private key file
+ *
+ * Revision 1.30  2011-06-04 14:49:48+05:30  Cprogrammer
+ * remove '%' sign from private key if key not found
+ *
+ * Revision 1.29  2011-06-04 14:22:29+05:30  Cprogrammer
+ * added DKIM_UNSIGNED_FROM error code for dkimadspverify
+ *
+ * Revision 1.28  2011-06-04 14:07:41+05:30  Cprogrammer
+ * added DKIM_UNSIGNED_FROM
+ *
+ * Revision 1.27  2011-02-10 23:39:59+05:30  Cprogrammer
+ * use DKIMKEY to override defult control/domainkeys/%/default
+ *
+ * Revision 1.26  2011-02-06 10:13:50+05:30  Cprogrammer
+ * BUG - signature was wrongly freed before being accessed.
+ *
+ * Revision 1.25  2011-02-05 09:47:47+05:30  Cprogrammer
+ * fixed SIGSEGV occuring for messages without body
+ *
+ * Revision 1.24  2010-11-02 18:45:14+05:30  Cprogrammer
+ * Improve DKIM signing/verification speed
+ *
+ * Revision 1.23  2010-07-21 08:59:57+05:30  Cprogrammer
+ * use CONTROLDIR environment variable instead of a hardcoded control directory
+ *
+ * Revision 1.22  2009-04-22 13:42:51+05:30  Cprogrammer
+ * made fd for custom error configurable through env variable ERROR_FD
+ *
+ * Revision 1.21  2009-04-21 09:05:48+05:30  Cprogrammer
+ * return relevant error message for reading private key
+ *
+ * Revision 1.20  2009-04-21 08:55:41+05:30  Cprogrammer
+ * return temporary error for temp failures
+ *
+ * Revision 1.19  2009-04-20 22:19:01+05:30  Cprogrammer
+ * made dkimopts global
+ *
+ * Revision 1.18  2009-04-16 13:48:32+05:30  Cprogrammer
+ * added dkim_setoptions() to set all DKIM options
+ *
+ * Revision 1.17  2009-04-07 11:36:56+05:30  Cprogrammer
+ * use TMPDIR env variable for tmp directory
+ *
+ * Revision 1.16  2009-04-05 12:52:17+05:30  Cprogrammer
+ * added preprocessor warning
+ *
+ * Revision 1.15  2009-04-04 00:33:44+05:30  Cprogrammer
+ * removed dk_strdup()
+ *
+ * Revision 1.14  2009-03-31 08:21:58+05:30  Cprogrammer
+ * set dkimsign when RELAYCLIENT is defined when both dkimsign and dkimverify are undefined
+ *
+ * Revision 1.13  2009-03-30 22:25:54+05:30  Cprogrammer
+ * made DKIM messages friendlier
+ *
+ * Revision 1.12  2009-03-30 14:47:59+05:30  Cprogrammer
+ * added descriptive text for original dkim error
+ *
+ * Revision 1.11  2009-03-29 19:20:43+05:30  Cprogrammer
+ * added nosignaturedomains
+ *
+ * Revision 1.10  2009-03-28 22:27:02+05:30  Cprogrammer
+ * use DKIMSIGN, DKIMVERIFY if RELAYCLIENT is not set
+ *
+ * Revision 1.9  2009-03-28 22:03:05+05:30  Cprogrammer
+ * fixed DKIM return codes
+ *
+ * Revision 1.8  2009-03-28 13:37:37+05:30  Cprogrammer
+ * call DKIMVerifyGetDetails() always
+ *
+ * Revision 1.7  2009-03-28 11:39:23+05:30  Cprogrammer
+ * set automatic setting of dkimsign, dkimverify variables based on RELAYCLIENT
+ *
+ * Revision 1.6  2009-03-28 11:35:58+05:30  Cprogrammer
+ * added ADSP/SSP
+ *
+ * Revision 1.5  2009-03-22 17:39:38+05:30  Cprogrammer
+ * set identity using basename of signature or environment variable DKIMIDENTITY
+ *
+ * Revision 1.4  2009-03-22 16:58:38+05:30  Cprogrammer
+ * fixed bug with verification
+ * report custom errors to qmail-queue through custom error interface
+ *
+ * Revision 1.3  2009-03-21 12:34:38+05:30  Cprogrammer
+ * use hasdkim.h for conditional compilation of dkim
+ *
+ * Revision 1.2  2009-03-20 22:35:57+05:30  Cprogrammer
+ * set error to DKIM_NO_SIGNATURE when DKIM-Signature is not present
+ *
+ * Revision 1.1  2009-03-18 13:54:49+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
+#include <unistd.h>
+#include <stdlib.h>
+#include <ctype.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include "sgetopt.h"
+#include "substdio.h"
+#include "open.h"
+#include "qmail.h"
+#include "sig.h"
+#include "scan.h"
+#include "case.h"
+#include "fmt.h"
+#include "fd.h"
+#include "alloc.h"
+#include "str.h"
+#include "stralloc.h"
+#include "datetime.h"
+#include "now.h"
+#include "wait.h"
+#include "auto_qmail.h"
+#include "env.h"
+#include "control.h"
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+#include "dkim.h"
+
+#define DEATH 86400	/*- 24 hours; _must_ be below q-s's OSSIFIED (36 hours) */
+#define ADDR 1003
+#define HAVE_EVP_SHA256
+#define strncasecmp(x,y,z) case_diffb((x), (z), (y))
+#define strcasecmp(x,y)    case_diffs((x), (y))
+
+char            inbuf[4096];
+char            outbuf[256];
+char            errbuf[256];
+struct substdio ssin;
+struct substdio ssout;
+struct substdio sserr;
+
+datetime_sec    starttime;
+struct datetime dt;
+unsigned long   mypid;
+unsigned long   uid;
+char           *pidfn;
+int             messfd;
+int             readfd;
+DKIMContext     ctxt;
+
+char          **MakeArgs(char *);
+void            FreeMakeArgs(char **);
+
+
+void
+die(int e, int what)
+{
+	if (!what)
+		_exit(e);
+	(what == 1 ? DKIMSignFree : DKIMVerifyFree) (&ctxt);
+	_exit(e);
+}
+
+void
+die_write()
+{
+	die(53, 0);
+}
+
+void
+die_read()
+{
+	die(54, 0);
+}
+
+void
+sigalrm()
+{
+	/*- thou shalt not clean up here */
+	die(52, 0);
+}
+
+void
+sigbug()
+{
+	die(81, 0);
+}
+
+void
+custom_error(char *flag, char *status, char *code)
+{
+	char           *c;
+
+	if (substdio_put(&sserr, flag, 1) == -1)
+		die_write();
+	if (substdio_put(&sserr, "qmail-dkim: ", 12) == -1)
+		die_write();
+	if (substdio_puts(&sserr, status) == -1)
+		die_write();
+	if (code) {
+		if (substdio_put(&sserr, " (#", 3) == -1)
+			die_write();
+		c = (*flag == 'Z') ? "4" : "5";
+		if (substdio_put(&sserr, c, 1) == -1)
+			die_write();
+		if (substdio_put(&sserr, code + 1, 4) == -1)
+			die_write();
+		if (substdio_put(&sserr, ")", 1) == -1)
+			die_write();
+	}
+	if (substdio_flush(&sserr) == -1)
+		die_write();
+	return;
+}
+
+int DKIM_CALL
+SignThisHeader(const char *szHeader)
+{
+	if ((!strncasecmp((char *) szHeader, "X-", 2) 
+			&& strncasecmp((char *) szHeader, "X-Mailer", 8))
+		|| strncasecmp((char *) szHeader, "Received:", 9) == 0
+		|| strncasecmp((char *) szHeader, "Authentication-Results:", 23) == 0
+		|| strncasecmp((char *) szHeader, "Return-Path:", 12) == 0) {
+		return 0;
+	}
+	return 1;
+}
+
+void
+maybe_die_dkim(e)
+	int             e;
+{
+	switch (e)
+	{
+	case DKIM_OUT_OF_MEMORY:
+	case DKIM_BUFFER_TOO_SMALL:
+		_exit (51);
+	case DKIM_INVALID_CONTEXT:
+		custom_error("Z", "DKIMContext structure invalid for this operation (#4.3.0)", 0);
+		_exit(88);
+	case DKIM_NO_SENDER:
+		custom_error("Z", "Could not find From: or Sender: header in message (#5.1.7)", 0);
+		_exit(88);
+	case DKIM_BAD_PRIVATE_KEY:
+		custom_error("D", "Could not parse private key (#5.7.5)", 0);
+		_exit(88);
+	default:
+		return;
+	}
+}
+
+unsigned int
+pidfmt(s, seq)
+	char           *s;
+	unsigned long   seq;
+{
+	unsigned int    i;
+	unsigned int    len;
+	char           *tmpdir;
+
+	if (!(tmpdir = env_get("TMPDIR")))
+		tmpdir = "/tmp";
+	len = 0;
+	i = fmt_str(s, tmpdir);
+	len += i;
+	if (s)
+		s += i;
+	i = fmt_str(s, "/qmail-dkim.");
+	len += i;
+	if (s)
+		s += i;
+	i = fmt_ulong(s, mypid);
+	len += i;
+	if (s)
+		s += i;
+	i = fmt_str(s, ".");
+	len += i;
+	if (s)
+		s += i;
+	i = fmt_ulong(s, starttime);
+	len += i;
+	if (s)
+		s += i;
+	i = fmt_str(s, ".");
+	len += i;
+	if (s)
+		s += i;
+	i = fmt_ulong(s, seq);
+	len += i;
+	if (s)
+		s += i;
+	++len;
+	if (s)
+		*s++ = 0;
+
+	return len;
+}
+
+void
+pidopen()
+{
+	unsigned int    len;
+	unsigned long   seq;
+
+	seq = 1;
+	len = pidfmt((char *) 0, seq);
+	if (!(pidfn = alloc(len)))
+		die(51, 0);
+	for (seq = 1; seq < 10; ++seq) {
+		if (pidfmt((char *) 0, seq) > len)
+			die(81, 0); /*- paranoia */
+		pidfmt(pidfn, seq);
+		if ((messfd = open_excl(pidfn)) != -1)
+			return;
+	}
+	die(63, 0);
+}
+
+char            tmp[FMT_ULONG];
+char           *dkimsign = 0;
+char           *dkimverify = 0;
+char           *dkimadspverify = 0, *dkimpractice =  "FGHIJKLMNPQRSTUVWX";
+stralloc        dkimoutput = { 0 };  /*- DKIM-Signature */
+stralloc        dksignature = { 0 }; /*- content of private signature */
+stralloc        sigdomains = { 0 };  /*- domains which must have signatures */
+stralloc        nsigdomains = { 0 }; /*- domains which do not have signatures */
+stralloc        dkimopts = { 0 };
+char           *dkimqueue = 0;
+
+static void
+write_signature(char *domain, char *keyfn)
+{
+	char           *pSig;
+	int             i;
+	static stralloc keyfnfrom = { 0 };
+
+	if (keyfn[0] != '/') {
+		if (!stralloc_copys(&keyfnfrom, "control/"))
+			die(51, 1);
+	}
+	i = str_chr(keyfn, '%');
+	if (keyfn[i]) {
+		if (keyfn[0] == '/') {
+			if (!stralloc_copyb(&keyfnfrom, keyfn, i))
+				die(51, 1);
+		} else
+		if (!stralloc_catb(&keyfnfrom, keyfn, i))
+			die(51, 1);
+		if (!stralloc_cats(&keyfnfrom, domain))
+			die(51, 1);
+		if (!stralloc_cats(&keyfnfrom, keyfn + i + 1))
+			die(51, 1);
+		if (!stralloc_0(&keyfnfrom))
+			die(51, 1);
+		if (access(keyfnfrom.s, F_OK)) {
+			/*- since file does not exists remove '%' sign */
+			keyfnfrom.len = 8;
+			if (keyfn[0] == '/') {
+				if (!stralloc_copyb(&keyfnfrom, keyfn, i))
+					die(51, 1);
+			} else
+			if (!stralloc_catb(&keyfnfrom, keyfn, i))
+				die(51, 1);
+			if ((i - 1) > 0 && keyfn[i - 1] == '/' && keyfn[i + 1] == '/')
+				i++;
+			if (!stralloc_cats(&keyfnfrom, keyfn + i + 1))
+				die(51, 1);
+			if (!stralloc_0(&keyfnfrom))
+				die(51, 1);
+		} 
+	} else {
+		if (keyfn[0] == '/') {
+			if (!stralloc_copys(&keyfnfrom, keyfn))
+				die(51, 1);
+		} else
+		if (!stralloc_cats(&keyfnfrom, keyfn))
+			die(51, 1);
+		if (!stralloc_0(&keyfnfrom))
+			die(51, 1);
+	}
+	switch (control_readnativefile(&dksignature, keyfnfrom.s, 1))
+	{
+	case 0: /*- missing signature file */
+		DKIMSignFree(&ctxt);
+		/*
+		 * You may have multiple domains, but may chose to sign
+		 * only for few domains which have the key present. Do not
+		 * treat domains with missing key as an error.
+		 */
+		if (keyfn[i])
+			return;
+		die(32, 0);
+	case 1:
+		break;
+	default:
+		custom_error("Z", "Unable to read private key. (#4.3.0)", 0);
+		DKIMSignFree(&ctxt);
+		_exit(88);
+	}
+	for (i = 0; i < dksignature.len; i++) {
+		if (dksignature.s[i] == '\0')
+			dksignature.s[i] = '\n';
+	}
+	if (!stralloc_0(&dksignature))
+		die(51, 1);
+	i = DKIMSignGetSig2(&ctxt, dksignature.s, &pSig);
+	maybe_die_dkim(i);
+	if (pSig) {
+		if (!stralloc_catb(&dkimoutput, pSig, str_len(pSig)))
+			die(51, 1);
+		if (!stralloc_cats(&dkimoutput, "\n"))
+			die(51, 1);
+	}
+	DKIMSignFree(&ctxt);
+}
+
+#include <openssl/evp.h>
+#define DKIM_MALLOC(n)     OPENSSL_malloc(n)
+#define DKIM_MFREE(s)      OPENSSL_free(s); s = NULL;
+char           *dns_text(char *);
+
+int
+ParseTagValues(char *list, char *letters[], char *values[])
+{
+	char           *tmp, *ptr, *key;
+	int             i;
+
+	/*- start with all args unset */
+	for (i = 0; letters[i]; i++)
+		values[i] = 0;
+	key = 0;
+	for(ptr = list;*ptr;) {
+		if ((*ptr == ' ') || (*ptr == '\t') || (*ptr == '\r') || (*ptr == '\n')) /*- FWS */
+			*ptr++ = 0;
+		if (!key)
+			key = ptr;
+		if (*ptr == '=') {
+			*ptr = 0;
+			for (i = 0;letters[i];i++) {
+				if (!str_diff(letters[i], key)) {
+					ptr++;
+					for (;*ptr;) {
+						if ((*ptr == ' ') || (*ptr == '\t') || (*ptr == '\r') || (*ptr == '\n')) {
+							ptr++;
+							continue;
+						}
+						break;
+					}
+					values[i] = ptr;
+					for(;*ptr && *ptr != ';';ptr++);
+					tmp = ptr;
+					if (*ptr)
+						*ptr++ = 0;
+					for(;tmp != values[i];tmp--) { /*- RFC 4871 3.2 */
+						if ((*tmp == ' ') || (*tmp == '\t') || (*tmp == '\r') || (*tmp == '\n')) {
+							*tmp = 0;
+							continue;
+						}
+						break;
+					}
+					key = 0;
+					break;
+				}
+			}
+		} else
+			ptr++;
+	}
+	return (0);
+}
+
+int
+checkSSP(char *domain, int *bTesting)
+{
+	char           *query, *results;
+	char           *tags[] = { "dkim", "t", 0};
+	char           *values[2];
+	int             bIsParentSSP = 0, iSSP = DKIM_SSP_UNKNOWN;
+
+	*bTesting = 0;
+	if (!(query = DKIM_MALLOC(str_len("_ssp._domainkey.") + str_len(domain) + 1)))
+		die(51, 0);
+	sprintf(query, "_ssp._domainkey.%s", domain);
+	results = dns_text(query);
+	DKIM_MFREE(query);
+	if (!str_diff(results, "e=temp;")) {
+		DKIM_MFREE(results);
+		return DKIM_SSP_TEMPFAIL;
+	} else
+	if (!str_diff(results, "e=perm;")) {
+		results = dns_text(domain);
+		if (!str_diff(results, "e=temp;")) {
+			DKIM_MFREE(results);
+			return DKIM_SSP_TEMPFAIL;
+		} else
+		if (!str_diff(results, "e=perm;")) {
+			DKIM_MFREE(results);
+			return DKIM_SSP_SCOPE;
+		}
+		bIsParentSSP = 1;
+	}
+	/* 
+	 * PG.1 2013-01-03
+	 * Bug fix by Piotr Gronek, Faculy of Physics & Applied Computer Science, Poland 2013-01-03
+	 * Deallocating storage for 'results' here is premature - moved beyond last reference to it.
+	 *
+	 */
+	if (!ParseTagValues(results, tags, values)) {
+		DKIM_MFREE(results);
+		return DKIM_SSP_UNKNOWN;
+	}
+	DKIM_MFREE(results);
+	if (values[0] != NULL) {
+		if (strcasecmp(values[0], "all") == 0)
+			iSSP = DKIM_SSP_ALL;
+		else
+		if (strcasecmp(values[0], "strict") == 0)
+			iSSP = DKIM_SSP_STRICT;
+	}
+	// flags
+	if (values[1] != NULL) {
+		char           *s, *p;
+		for (p = values[1], s = values[1]; *p; p++) {
+			if (*p == '|')
+				*p = 0;
+			else
+				continue;
+			if (!str_diff(s, "y"))
+				*bTesting = 1;
+			else
+			if (!str_diff(s, "s")) {
+				if (bIsParentSSP) {
+					/* 
+					 * this is a parent's SSP record that should not apply to subdomains
+					 * the message is non-suspicious
+					 */
+					*bTesting = 0;
+					return (DKIM_SSP_UNKNOWN);
+				}
+			}
+			s = p + 1;
+		}
+	}
+	return iSSP;
+}
+
+int
+checkADSP(char *domain)
+{
+	char           *query, *results;
+	char           *tags[] = { "dkim", 0};
+	char           *values[1];
+
+	results = dns_text(domain);
+	if (!str_diff(results, "e=perm;")) {
+		DKIM_MFREE(results);
+		return DKIM_ADSP_SCOPE;
+	} else
+	if (!str_diff(results, "e=temp;")) {
+		DKIM_MFREE(results);
+		return DKIM_ADSP_TEMPFAIL;
+	}
+	if (!(query = DKIM_MALLOC(str_len("_adsp._domainkey.") + str_len(domain) + 1))) {
+		DKIM_MFREE(results);
+		die(51, 0);
+	}
+	sprintf(query, "_adsp._domainkey.%s", domain);
+	results = dns_text(query);
+	DKIM_MFREE(query);
+	if (!str_diff(results, "e=perm;")) {
+		DKIM_MFREE(results);
+		return DKIM_ADSP_SCOPE;
+	} else
+	if (!str_diff(results, "e=temp;")) {
+		DKIM_MFREE(results);
+		return DKIM_ADSP_TEMPFAIL;
+	}
+	/* 
+	 * PG.1 2013-01-03
+	 * Bug fix by Piotr Gronek, Faculy of Physics & Applied Computer Science, Poland 2013-01-03
+	 *
+	 * Deallocating storage for 'results' here is premature - moved beyond last reference to it.
+	 *
+	 */
+	if (!ParseTagValues(results, tags, values)) {
+		DKIM_MFREE(results);
+		return DKIM_SSP_UNKNOWN;
+	}
+	DKIM_MFREE(results);
+	if (values[0] != NULL) {
+		if (strcasecmp(values[0], "all") == 0)
+			return (DKIM_ADSP_ALL);
+		else
+		if (strcasecmp(values[0], "discardable") == 0)
+			return (DKIM_ADSP_DISCARDABLE);
+	}
+	return DKIM_ADSP_UNKNOWN; /*- No ADSP Record */
+}
+
+void
+dkimverify_exit(int dkimRet, char *status, char *code)
+{
+	if (dkimRet < 0) {
+		if (dkimverify[str_chr(dkimverify, 'F' - dkimRet)]) {
+			custom_error("D", status, code);
+			die(88, 0);
+		}
+		if (dkimverify[str_chr(dkimverify, 'f' - dkimRet)]) {
+			custom_error("Z", status, code);
+			die(88, 0);
+		}
+	} else {
+		if (dkimverify[str_chr(dkimverify, 'A' + dkimRet)]) {
+			custom_error("D", status, code);
+			die(88, 0);
+		}
+		if (dkimverify[str_chr(dkimverify, 'a' + dkimRet)]) {
+			custom_error("Z", status, code);
+			die(88, 0);
+		}
+	}
+}
+
+void
+writeHeaderNexit(int ret, int origRet, int resDKIMSSP, int resDKIMADSP, int useSSP, int useADSP)
+{
+	char           *dkimStatus = 0, *sspStatus = 0, *adspStatus = 0, *code = 0, *orig = 0;
+	char            strnum[FMT_ULONG];
+
+	switch (ret)
+	{
+	case DKIM_SUCCESS:			/*- 0 */ /*- A */
+		dkimStatus = "good        ";
+		code = "X.7.0";
+		break;
+	case DKIM_FINISHED_BODY:	/*- 1 process result: no more message body is needed */
+		dkimStatus = "process result: no more message body is needed";
+		code = "X.7.0";
+		break;
+	case DKIM_PARTIAL_SUCCESS:	/*- 2 verify result: at least one but not all signatures verified */
+		dkimStatus = "verify result: at least none but not all signatures verified";
+		code = "X.7.0";
+		break;
+	case DKIM_NEUTRAL:			/*- 3 verify result: no signatures verified but message is not suspicious */
+		dkimStatus = "verify result: no signatures verified but message is not suspicious";
+		code = "X.7.0";
+		break;
+	case DKIM_SUCCESS_BUT_EXTRA:/*- 4 signature result: signature verified but it did not include all of the body */
+		dkimStatus = "signature result: signature verified but it did not include all of the body";
+		code = "X.7.0";
+		break;
+	case DKIM_FAIL:				/*- -1 */ /*- F */
+		dkimStatus = "DKIM Signature verification failed";
+		code = "X.7.0";
+		break;
+	case DKIM_BAD_SYNTAX:		/*- -2 */ /*- G */
+		dkimStatus = "signature error: DKIM-Signature could not parse or has bad tags/values";
+		code = "X.7.5";
+		break;
+	case DKIM_SIGNATURE_BAD:	/*- -3 */
+		dkimStatus = "signature error: RSA verify failed";
+		code = "X.7.5";
+		break;
+	case DKIM_SIGNATURE_BAD_BUT_TESTING:
+		dkimStatus = "signature error: RSA verify failed but testing";
+		code = "X.7.5";
+		break;
+	case DKIM_SIGNATURE_EXPIRED:
+		dkimStatus = "signature error: x= is old";
+		code = "X.7.5";
+		break;
+	case DKIM_SELECTOR_INVALID:
+		dkimStatus = "signature error: selector doesn't parse or contains invalid values";
+		code = "X.7.5";
+		break;
+	case DKIM_SELECTOR_GRANULARITY_MISMATCH:
+		dkimStatus = "signature error: selector g= doesn't match i=";
+		code = "X.7.5";
+		break;
+	case DKIM_SELECTOR_KEY_REVOKED:
+		dkimStatus = "signature error: selector p= empty";
+		code = "X.7.5";
+		break;
+	case DKIM_SELECTOR_DOMAIN_NAME_TOO_LONG:
+		dkimStatus = "signature error: selector domain name too long to request";
+		code = "X.7.0";
+		break;
+	case DKIM_SELECTOR_DNS_TEMP_FAILURE:
+		dkimStatus = "signature error: temporary dns failure requesting selector";
+		code = "X.7.0";
+		break;
+	case DKIM_SELECTOR_DNS_PERM_FAILURE:
+		dkimStatus = "signature error: permanent dns failure requesting selector";
+		code = "X.7.0";
+		break;
+	case DKIM_SELECTOR_PUBLIC_KEY_INVALID:
+		dkimStatus = "signature error: selector p= value invalid or wrong format";
+		code = "X.7.5";
+		break;
+	case DKIM_NO_SIGNATURES:
+		dkimStatus = "no signatures";
+		code = "X.7.5";
+		break;
+	case DKIM_NO_VALID_SIGNATURES:
+		dkimStatus = "no valid signatures";
+		code = "X.7.5";
+		break;
+	case DKIM_BODY_HASH_MISMATCH:
+		dkimStatus = "signature verify error: message body does not hash to bh value";
+		code = "X.7.7";
+		break;
+	case DKIM_SELECTOR_ALGORITHM_MISMATCH:
+		dkimStatus = "signature error: selector h= doesn't match signature a=";
+		code = "X.7.7";
+		break;
+	case DKIM_STAT_INCOMPAT:
+		dkimStatus = "signature error: incompatible v=";
+		code = "X.7.6";
+		break;
+	case DKIM_UNSIGNED_FROM:
+		dkimStatus = "signature error: not all message's From headers in signature";
+		code = "X.7.7";
+		break;
+	default:
+		dkimStatus = "error";
+		code = "X.3.0";
+		break;
+	}
+	if (useSSP && resDKIMSSP != -1) {
+		switch(resDKIMSSP)
+		{
+			case DKIM_SSP_ALL:
+				sspStatus = (char *) "all;";
+				break;
+			case DKIM_SSP_STRICT:
+				sspStatus = (char *) "strict;";
+				break;
+			case DKIM_SSP_SCOPE:
+				sspStatus = (char *) "out of scope;";
+				break;
+			case DKIM_SSP_TEMPFAIL:
+				sspStatus = (char *) "temporary failure;";
+				break;
+			case DKIM_SSP_UNKNOWN:
+			default:
+				sspStatus = (char *) "unknown;";
+				break;
+		}
+	}
+	if (useADSP && resDKIMADSP != -1) {
+		switch(resDKIMADSP)
+		{
+			case DKIM_ADSP_ALL:
+				adspStatus = (char *) "all;";
+				break;
+			case DKIM_ADSP_DISCARDABLE:
+				adspStatus = (char *) "discardable;";
+				break;
+			case DKIM_ADSP_SCOPE:
+				adspStatus = (char *) "out of scope;";
+				break;
+			case DKIM_ADSP_TEMPFAIL:
+				adspStatus = (char *) "temporary failure;";
+				break;
+			case DKIM_ADSP_UNKNOWN:
+			default:
+				adspStatus = (char *) "unknown ;";
+				break;
+		}
+	}
+	if (!stralloc_copys(&dkimoutput, "DKIM-Status: "))
+		die(51, 0);
+	if (!stralloc_cats(&dkimoutput, dkimStatus))
+		die(51, 0);
+	if (origRet != DKIM_MAX_ERROR && ret != origRet) {
+		if (!stralloc_cats(&dkimoutput, "\n\t(old="))
+			die(51, 0);
+		switch (origRet)
+		{
+		case DKIM_SUCCESS:			/*- 0 */ /*- A */
+			orig = "SUCCESS";
+			break;
+		case DKIM_FINISHED_BODY:	/*- 1 process result: no more message body is needed */
+			orig = "FINISHED BODY";
+			break;
+		case DKIM_PARTIAL_SUCCESS:	/*- 2 verify result: at least one but not all signatures verified */
+			orig = "PARTIAL SUCCESS";
+			break;
+		case DKIM_NEUTRAL:			/*- 3 verify result: no signatures verified but message is not suspicious */
+			orig = "NEUTRAL";
+			break;
+		case DKIM_SUCCESS_BUT_EXTRA:/*- 4 signature result: signature verified but it did not include all of the body */
+			orig = "SUCCESS(BUT EXTRA)";
+			break;
+		case DKIM_FAIL:				/*- -1 */ /*- F */
+			orig = "FAIL";
+			break;
+		case DKIM_BAD_SYNTAX:		/*- -2 */ /*- G */
+			orig = "BAD SYNTAX";
+			break;
+		case DKIM_SIGNATURE_BAD:	/*- -3 */
+			orig = "SIGNATURE BAD";
+			break;
+		case DKIM_SIGNATURE_BAD_BUT_TESTING:
+			orig = "SIGNATURE BAD (TESTING)";
+			break;
+		case DKIM_SIGNATURE_EXPIRED:
+			orig = "SIGNATURE EXPIRED";
+			break;
+		case DKIM_SELECTOR_INVALID:
+			orig = "SELECTOR INVALID";
+			break;
+		case DKIM_SELECTOR_GRANULARITY_MISMATCH:
+			orig = "SELECTOR GRANULARITY MISMATCH";
+			break;
+		case DKIM_SELECTOR_KEY_REVOKED:
+			orig = "SELECTOR KEY REVOKED";
+			break;
+		case DKIM_SELECTOR_DOMAIN_NAME_TOO_LONG:
+			orig = "DOMAIN NAME TOO LONG";
+			break;
+		case DKIM_SELECTOR_DNS_TEMP_FAILURE:
+			orig = "DNS TEMP FAILURE";
+			break;
+		case DKIM_SELECTOR_DNS_PERM_FAILURE:
+			orig = "DNS PERM FAILURE";
+			break;
+		case DKIM_SELECTOR_PUBLIC_KEY_INVALID:
+			orig = "PUBLIC KEY INVALID";
+			break;
+		case DKIM_NO_SIGNATURES:
+			orig = "NO SIGNATURES";
+			break;
+		case DKIM_NO_VALID_SIGNATURES:
+			orig = "NO VALID SIGNATURES";
+			break;
+		case DKIM_BODY_HASH_MISMATCH:
+			orig = "BODY HASH MISMATCH";
+			break;
+		case DKIM_SELECTOR_ALGORITHM_MISMATCH:
+			orig = "ALGORITHM MISMATCH";
+			break;
+		case DKIM_STAT_INCOMPAT:
+			orig = "STAT INCOMPAT";
+			break;
+		case DKIM_UNSIGNED_FROM:
+			orig = "UNSIGNED FROM";
+			break;
+		default:
+			orig = "Unkown error";
+			break;
+		}
+		if (!stralloc_cats(&dkimoutput, orig))
+			die(51, 0);
+		if (!stralloc_cats(&dkimoutput, ":"))
+			die(51, 0);
+		if (origRet < 0) {
+			if (!stralloc_cats(&dkimoutput, "-"))
+				die(51, 0);
+			strnum[fmt_ulong(strnum, 0 - origRet)] = 0;
+		} else
+			strnum[fmt_ulong(strnum, origRet)] = 0;
+		if (!stralloc_cats(&dkimoutput, strnum))
+			die(51, 0);
+		if (!stralloc_cats(&dkimoutput, ")"))
+			die(51, 0);
+	}
+	if (!stralloc_cats(&dkimoutput, "\n"))
+		die(51, 0);
+	if (useSSP && sspStatus) {
+		if (!stralloc_cats(&dkimoutput, "X-DKIM-SSP: "))
+			die(51, 0);
+		if (!stralloc_cats(&dkimoutput, sspStatus))
+			die(51, 0);
+		if (!stralloc_cats(&dkimoutput, "\n"))
+			die(51, 0);
+	}
+	if (useADSP && adspStatus) {
+		if (!stralloc_cats(&dkimoutput, "X-DKIM-ADSP: "))
+			die(51, 0);
+		if (!stralloc_cats(&dkimoutput, adspStatus))
+			die(51, 0);
+		if (!stralloc_cats(&dkimoutput, "\n"))
+			die(51, 0);
+	}
+	dkimverify_exit(ret, dkimStatus, code);
+	return;
+}
+
+int
+checkPractice(int dkimRet)
+{
+	char           *ptr;
+
+	if (!(ptr = env_get("DKIMPRACTICE")))
+		return (0);
+	else
+		dkimpractice = ptr;
+	if (!*ptr) {
+		if (dkimRet < 0 || dkimRet == DKIM_3PS_SIGNATURE)
+			return (1);
+		return (0);
+	}
+	if (dkimRet < 0) {
+		if (dkimpractice[str_chr(dkimpractice, 'F' - dkimRet)])
+			return (1);
+		if (dkimpractice[str_chr(dkimpractice, 'f' - dkimRet)])
+			return (1);
+	} else {
+		if (dkimpractice[str_chr(dkimpractice, 'A' + dkimRet)])
+			return (1);
+		if (dkimpractice[str_chr(dkimpractice, 'a' + dkimRet)])
+			return (1);
+	}
+	return (0);
+}
+
+static char    *binqqargs[2] = { "bin/qmail-queue", 0 };
+
+int
+dkim_setoptions(DKIMSignOptions *opts, char *signOptions)
+{
+	int             ch, argc;
+	char          **argv;
+
+	opts->nIncludeBodyHash = DKIM_BODYHASH_IETF_1;
+	opts->nCanon = DKIM_SIGN_RELAXED;					/*- c */
+	opts->nIncludeBodyLengthTag = 0;					/*- l */
+	opts->nIncludeQueryMethod = 0;						/*- q */
+	opts->nIncludeTimeStamp = 0;						/*- t */
+	opts->nIncludeCopiedHeaders = 0;					/*- h */
+	opts->szIdentity[0] = '\0';
+	opts->expireTime = starttime + 604800;	// expires in 1 week
+	opts->nHash = DKIM_HASH_SHA1;
+	str_copy(opts->szRequiredHeaders, "NonExistent");
+	if (!signOptions)
+		return (0);
+	if (!stralloc_copys(&dkimopts, "dkim "))
+		die(51, 0);
+	if (!stralloc_cats(&dkimopts, signOptions))
+		die(51, 0);
+	if (!stralloc_0(&dkimopts))
+		die(51, 0);
+	if (!(argv = MakeArgs(dkimopts.s)))
+		die(51, 0);
+	for (argc = 0;argv[argc];argc++);
+#ifdef HAVE_EVP_SHA256
+	while ((ch = sgopt(argc, argv, "b:c:li:qthx:z:")) != sgoptdone) {
+#else
+	while ((ch = sgopt(argc, argv, "b:c:li:qthx:")) != sgoptdone) {
+#endif
+		switch (ch)
+		{
+		case 'b':
+			switch (*optarg)
+			{
+			case '1':
+				opts->nIncludeBodyHash = DKIM_BODYHASH_ALLMAN_1;
+				break;
+			case '2':
+				opts->nIncludeBodyHash = DKIM_BODYHASH_IETF_1;
+				break;
+			case '3':
+				opts->nIncludeBodyHash = DKIM_BODYHASH_BOTH;
+				break;
+			default:
+				FreeMakeArgs(argv);
+				return (1);
+			}
+			break;
+		case 'c':
+			switch (*optarg)
+			{
+			case 'r':
+				opts->nCanon = DKIM_SIGN_RELAXED;
+				break;
+			case 's':
+				opts->nCanon = DKIM_SIGN_SIMPLE;
+				break;
+			case 't':
+				opts->nCanon = DKIM_SIGN_RELAXED_SIMPLE;
+				break;
+			case 'u':
+				opts->nCanon = DKIM_SIGN_SIMPLE_RELAXED;
+				break;
+			default:
+				FreeMakeArgs(argv);
+				return (1);
+			}
+			break;
+		case 'l': /*- body length tag */
+			opts->nIncludeBodyLengthTag = 1;
+			break;
+		case 'q': /*- query method tag */
+			opts->nIncludeQueryMethod = 1;
+			break;
+		case 't': /*- timestamp tag */
+			opts->nIncludeTimeStamp = 1;
+			break;
+		case 'h':
+			opts->nIncludeCopiedHeaders = 1;
+			break;
+		case 'i':	/*- identity */
+			if (*optarg == '-') /* do not use i= tag */
+				opts->szIdentity[0] = '\0';
+			else
+				str_copyb(opts->szIdentity, optarg, sizeof(opts->szIdentity) - 1);
+			break;
+		case 'x': /*- expire time */
+			if (*optarg == '-')
+				opts->expireTime = 0;
+			else
+				opts->expireTime = starttime + atoi(optarg);
+			break;
+#ifdef HAVE_EVP_SHA256
+		case 'z': /*- sign w/ sha1, sha256 or both */
+			switch (*optarg)
+			{
+			case '1':
+				opts->nHash = DKIM_HASH_SHA1;
+				break;
+			case '2':
+				opts->nHash = DKIM_HASH_SHA256;
+				break;
+			case '3':
+				opts->nHash = DKIM_HASH_SHA1_AND_256;
+				break;
+			default:
+				FreeMakeArgs(argv);
+				return (1);
+			}
+			break;
+#endif
+		default:
+			FreeMakeArgs(argv);
+			return (1);
+		} /*- switch (ch) */
+	} /*- while (1) */
+	FreeMakeArgs(argv);
+	return (0);
+}
+
+int
+main(int argc, char *argv[])
+{
+	int             errfd, pim[2];
+	int             wstat;
+	int             resDKIMSSP = -1, resDKIMADSP = -1, useSSP = 0, useADSP = 0, accept3ps = 0;
+	int             sCount = 0, sSize = 0;
+	int             ret = 0, origRet = DKIM_MAX_ERROR, i, nSigCount = 0, len, token_len;
+	unsigned long   pid;
+	char           *selector, *p;
+	stralloc        dkimfn = {0};
+	DKIMSignOptions opts = { 0 };
+	DKIMVerifyDetails *pDetails;
+	DKIMVerifyOptions vopts = { 0 };
+
+	starttime = now();
+	sig_blocknone();
+	umask(033);
+	if (!(p = env_get("ERROR_FD")))
+		errfd = CUSTOM_ERR_FD;
+	else
+		scan_int(p, &errfd);
+	substdio_fdbuf(&sserr, write, errfd, errbuf, sizeof(errbuf));
+	if (chdir(auto_qmail) == -1)
+		die(61, 0);
+	dkimqueue = env_get("DKIMQUEUE");
+	if (dkimqueue && *dkimqueue)
+		binqqargs[0] = dkimqueue;
+	dkimsign = env_get("DKIMSIGN");
+	dkimverify = env_get("DKIMVERIFY");
+	p = (env_get("RELAYCLIENT") || env_get("AUTHINFO")) ? "" : 0;
+	if (dkimverify && p && env_get("RELAYCLIENT_NODKIMVERIFY")) {
+		execv(*binqqargs, binqqargs);
+		die(120, 0);
+	}
+	if (!dkimsign && !dkimverify && p) {
+		if (!(dkimsign = env_get("DKIMKEY"))) {
+			if (!stralloc_copys(&dkimfn, "domainkeys/%/default"))
+				die(51, 0);
+			if (!stralloc_0(&dkimfn))
+				die(51, 0);
+			dkimsign = dkimfn.s;
+		}
+	}
+	if (dkimsign) {
+		/* selector */
+		p = dkimsign;
+		selector = p;
+		while (*p) {
+			if (*p == '/' && *(p + 1))
+				selector = p + 1;
+			p++;
+		}
+		str_copyb(opts.szSelector, selector, sizeof(opts.szSelector) - 1);
+
+		if (dkim_setoptions(&opts, env_get("DKIMSIGNOPTIONS"))) {
+			custom_error("Z", "Invalid DKIMSIGNOPTIONS (#4.3.0)", 0);
+			_exit(88);
+		}
+		p = env_get("DKIMIDENTITY");
+		if (p && *p)
+			str_copyb(opts.szIdentity, p, sizeof(opts.szIdentity) - 1);
+		p = env_get("DKIMEXPIRE");
+		if (p && *p)
+			opts.expireTime = starttime + atol(p);
+		else
+		if (p)
+			opts.expireTime = 0;
+		opts.pfnHeaderCallback = SignThisHeader;
+		if (DKIMSignInit(&ctxt, &opts) != DKIM_SUCCESS) { /*- failed to initialize signature */
+			custom_error("Z", "dkim initialization failed (#4.3.0)", 0);
+			_exit(88);
+		}
+	} else {
+		char           *x;
+
+		if (!dkimverify)
+			dkimverify = "";
+		if (!(x = env_get("SIGN_PRACTICE")))
+			x = "adsp";
+		if (!str_diffn("adsp", x, 4)) {
+			useADSP = 1;
+			accept3ps = 1;
+		} else
+		if (!str_diffn("ssp", x, 3)) {
+			useSSP = 1;
+			accept3ps = 1;
+		} else
+		if (!str_diffn("local", x, 5)) {
+			useSSP = 0;
+			useADSP = 0;
+			accept3ps = 1;
+		}
+		if (useADSP)
+			vopts.nCheckPractices = useADSP;
+		else
+		if (useSSP)
+			vopts.nCheckPractices = useSSP;
+		else
+			vopts.nCheckPractices = 0;
+		vopts.nAccept3ps = accept3ps;
+		vopts.pfnSelectorCallback = NULL;	/*- SelectorCallback; */
+		if (env_get("UNSIGNED_FROM"))
+			vopts.nAllowUnsignedFromHeaders = 1;
+		vopts.nSubjectRequired = env_get("UNSIGNED_SUBJECT") ? 0 : 1;
+		DKIMVerifyInit(&ctxt, &vopts);		/*- this is always successful */
+	}
+	/*- Initialization */
+	mypid = getpid();
+	uid = getuid();
+	datetime_tai(&dt, starttime);
+	sig_pipeignore();
+	sig_miscignore();
+	sig_alarmcatch(sigalrm);
+	sig_bugcatch(sigbug);
+	alarm(DEATH);
+	pidopen(); /*- fd = messfd */
+	if ((readfd = open_read(pidfn)) == -1)
+		die(63, dkimsign ? 1 : 2);
+	if (unlink(pidfn) == -1)
+		die(63, dkimsign ? 1 : 2);
+	substdio_fdbuf(&ssout, write, messfd, outbuf, sizeof(outbuf));
+	substdio_fdbuf(&ssin, read, 0, inbuf, sizeof(inbuf));
+	for (ret = 0;;) {
+		register int    n;
+		register char  *x;
+
+		if ((n = substdio_feed(&ssin)) < 0) {
+			(dkimsign ? DKIMSignFree : DKIMVerifyFree) (&ctxt);
+			die_read();
+		}
+		if (!n)
+			break;
+		x = substdio_PEEK(&ssin);
+		if (!ret) {
+			if ((ret = (dkimsign ? DKIMSignProcess : DKIMVerifyProcess) (&ctxt, x, n)) == DKIM_INVALID_CONTEXT)
+				(dkimsign ? DKIMSignFree : DKIMVerifyFree) (&ctxt);
+			maybe_die_dkim(ret);
+		}
+		if (substdio_put(&ssout, x, n) == -1) {
+			(dkimsign ? DKIMSignFree : DKIMVerifyFree) (&ctxt);
+			die_write();
+		}
+		substdio_SEEK(&ssin, n);
+	}
+	if (substdio_flush(&ssout) == -1) {
+		(dkimsign ? DKIMSignFree : DKIMVerifyFree) (&ctxt);
+		die_write();
+	}
+	if (dkimsign || dkimverify) {
+		if (dkimsign) {
+			char           *p;
+
+			if (!(p = DKIMSignGetDomain(&ctxt))) {
+				DKIMSignFree(&ctxt);
+				maybe_die_dkim(DKIM_INVALID_CONTEXT);
+			}
+			write_signature(p, dkimsign); /*- calls DKIMSignFree(&ctxt) */
+		} else
+		if (dkimverify) {
+			char            szPolicy[512];
+
+			if (!ret) {
+				if ((ret = DKIMVerifyResults(&ctxt, &sCount, &sSize)) != DKIM_SUCCESS)
+					maybe_die_dkim(ret);
+				if ((ret = DKIMVerifyGetDetails(&ctxt, &nSigCount, &pDetails, szPolicy)) != DKIM_SUCCESS)
+					maybe_die_dkim(ret);
+				else
+				for (ret = DKIM_FAIL,i = 0; i < nSigCount; i++) {
+					if (pDetails[i].nResult >= 0) {
+						ret = 0;
+					} else {
+						if (ret == DKIM_FAIL)
+							ret = pDetails[i].nResult;
+					}
+				}
+				if (!nSigCount)
+					ret = DKIM_NO_SIGNATURES;
+			}
+			/*- what to do if DKIM Verification fails */
+			if (checkPractice(ret)) {
+				char           *domain;
+				int             skip_nosignature_domain = 0;
+
+				origRet = ret;
+				if ((domain = DKIMVerifyGetDomain(&ctxt))) {
+					if (!(p = env_get("SIGNATUREDOMAINS"))) {
+						if (control_readfile(&sigdomains, "signaturedomains", 0) == -1)
+							die(55, 2);
+					} else
+					if (!stralloc_copys(&sigdomains, p))
+						die(51, 2);
+					for (len = 0, p = sigdomains.s;len < sigdomains.len;) {
+						len += ((token_len = str_len(p)) + 1); /*- next domain */
+						if (!case_diffb(p, token_len, domain)) {
+							ret = origRet;
+							skip_nosignature_domain = 1;
+							useADSP = 0;
+							useSSP = 0;
+							break;
+						}
+						p = sigdomains.s + len;
+					}
+					if (!skip_nosignature_domain) {
+						if (!(p = env_get("NOSIGNATUREDOMAINS"))) {
+							if (control_readfile(&nsigdomains, "nosignaturedomains", 0) == -1)
+								die(55, 2);
+						} else
+						if (!stralloc_copys(&nsigdomains, p))
+							die(51, 2);
+						for (len = 0, p = nsigdomains.s;len < nsigdomains.len;) {
+							len += ((token_len = str_len(p)) + 1); /*- next domain */
+							if (*p == '*' || !case_diffb(p, token_len, domain)) {
+								ret = DKIM_NEUTRAL;
+								useADSP = 0;
+								useSSP = 0;
+								break;
+							}
+							p = nsigdomains.s + len;
+						}
+					}
+				}
+				if (!domain || !*domain)
+					; /*- do nothing ? */
+				else
+				if (useADSP) {
+					resDKIMADSP = checkADSP(domain);
+					if (sCount > 0) {
+						if (resDKIMADSP == DKIM_ADSP_UNKNOWN || resDKIMADSP == DKIM_ADSP_ALL)
+							ret = (sCount == sSize ? DKIM_SUCCESS : DKIM_PARTIAL_SUCCESS);
+					} 
+					/* if the message should be signed, return fail */
+					if (resDKIMADSP == DKIM_ADSP_DISCARDABLE)
+						ret = DKIM_FAIL;
+					else
+						ret = DKIM_NEUTRAL;
+				} else
+				if (useSSP) {
+					int             bTestingPractices = 0;
+					char           *domain;
+
+					if ((domain = DKIMVerifyGetDomain(&ctxt)))
+						resDKIMSSP = checkSSP(domain, &bTestingPractices);
+					if (sCount > 0) {
+						if ((resDKIMSSP == DKIM_SSP_UNKNOWN || resDKIMSSP == DKIM_SSP_ALL))
+							ret = (sCount == sSize ? DKIM_SUCCESS : DKIM_PARTIAL_SUCCESS);
+					}
+					// if the SSP is testing, return neutral
+					if (bTestingPractices)
+						ret = DKIM_NEUTRAL;
+					/* if the message should be signed, return fail */
+					if (resDKIMSSP == DKIM_SSP_ALL || resDKIMSSP == DKIM_SSP_STRICT)
+						ret = DKIM_FAIL;
+					else
+						ret = DKIM_NEUTRAL;
+				}
+			}
+			DKIMVerifyFree(&ctxt);
+			writeHeaderNexit(ret, origRet, resDKIMSSP, resDKIMADSP, useSSP, useADSP);
+		} /*- if (dkimverify) */
+	}
+	if (pipe(pim) == -1)
+		die(59, 0);
+	switch (pid = vfork())
+	{
+	case -1:
+		close(pim[0]);
+		close(pim[1]);
+		die(58, 0);
+	case 0:
+		close(pim[1]);
+		if (fd_move(0, pim[0]) == -1)
+			die(120, 0);
+		execv(*binqqargs, binqqargs);
+		die(120, 0);
+	}
+	close(pim[0]);
+	substdio_fdbuf(&ssin, read, readfd, inbuf, sizeof(inbuf));
+	substdio_fdbuf(&ssout, write, pim[1], outbuf, sizeof(outbuf));
+	if (substdio_bput(&ssout, dkimoutput.s, dkimoutput.len) == -1) /*- write DKIM signature */
+		die_write();
+	switch (substdio_copy(&ssout, &ssin))
+	{
+	case -2:
+		die_read();
+	case -3:
+		die_write();
+	}
+	if (substdio_flush(&ssout) == -1)
+		die_write();
+	close(pim[1]);
+	if (wait_pid(&wstat, pid) != pid)
+		die(57, 0);
+	if (wait_crashed(wstat))
+		die(57, 0);
+	die(wait_exitcode(wstat), 0);
+	/*- Not Reached */
+	exit(0);
+}
+
+void
+getversion_qmail_dkim_c()
+{
+	static char    *x = "$Id: qmail-dkim.c,v 1.49 2018-08-08 23:58:01+05:30 Cprogrammer Exp mbhangui $";
+
+	x++;
+}
diff -Naur netqmail-1.06.org/qmail.h netqmail-1.06/qmail.h
--- netqmail-1.06.org/qmail.h	1998-06-15 16:23:16.000000000 +0530
+++ netqmail-1.06/qmail.h	2018-04-03 17:28:43.668318639 +0530
@@ -3,11 +3,13 @@
 
 #include "substdio.h"
 
+#define CUSTOM_ERR_FD 4
 struct qmail {
   int flagerr;
   unsigned long pid;
   int fdm;
   int fde;
+  int fdc;
   substdio ss;
   char buf[1024];
 } ;
diff -Naur netqmail-1.06.org/qmail-inject.c netqmail-1.06/qmail-inject.c
--- netqmail-1.06.org/qmail-inject.c	1998-06-15 16:23:16.000000000 +0530
+++ netqmail-1.06/qmail-inject.c	2018-04-03 17:28:43.669318659 +0530
@@ -55,7 +55,7 @@
 
 void put(s,len) char *s; int len;
 { if (flagqueue) qmail_put(&qqt,s,len); else substdio_put(subfdout,s,len); }
-void puts(s) char *s; { put(s,str_len(s)); }
+void my_puts(s) char *s; { put(s,str_len(s)); }
 
 void perm() { _exit(100); }
 void temp() { _exit(111); }
@@ -549,16 +549,16 @@
 
   if (i == tocclist.len) return;
 
-  puts("Mail-Followup-To: ");
+  my_puts("Mail-Followup-To: ");
   i = tocclist.len;
   while (i--) {
     if (!stralloc_copy(&sa,&tocclist.sa[i])) die_nomem();
     if (!stralloc_0(&sa)) die_nomem();
     if (!quote2(&sa2,sa.s)) die_nomem();
     put(sa2.s,sa2.len);
-    if (i) puts(",\n  ");
+    if (i) my_puts(",\n  ");
   }
-  puts("\n");
+  my_puts("\n");
 }
 
 void finishheader()
@@ -580,9 +580,9 @@
    if (!stralloc_0(&sa)) die_nomem();
    if (!quote2(&sa2,sa.s)) die_nomem();
 
-   puts("Return-Path: <");
+   my_puts("Return-Path: <");
    put(sa2.s,sa2.len);
-   puts(">\n");
+   my_puts(">\n");
   }
 
  /* could check at this point whether there are any recipients */
@@ -594,23 +594,23 @@
    if (!htypeseen[H_R_DATE])
     {
      if (!newfield_datemake(starttime)) die_nomem();
-     puts("Resent-");
+     my_puts("Resent-");
      put(newfield_date.s,newfield_date.len);
     }
    if (!htypeseen[H_R_MESSAGEID])
     {
      if (!newfield_msgidmake(control_idhost.s,control_idhost.len,starttime)) die_nomem();
-     puts("Resent-");
+     my_puts("Resent-");
      put(newfield_msgid.s,newfield_msgid.len);
     }
    if (!htypeseen[H_R_FROM])
     {
      defaultfrommake();
-     puts("Resent-");
+     my_puts("Resent-");
      put(defaultfrom.s,defaultfrom.len);
     }
    if (!htypeseen[H_R_TO] && !htypeseen[H_R_CC])
-     puts("Resent-Cc: recipient list not shown: ;\n");
+     my_puts("Resent-Cc: recipient list not shown: ;\n");
   }
  else
   {
@@ -630,7 +630,7 @@
      put(defaultfrom.s,defaultfrom.len);
     }
    if (!htypeseen[H_TO] && !htypeseen[H_CC])
-     puts("Cc: recipient list not shown: ;\n");
+     my_puts("Cc: recipient list not shown: ;\n");
    finishmft();
   }
 
diff -Naur netqmail-1.06.org/qmail-lspawn.c netqmail-1.06/qmail-lspawn.c
--- netqmail-1.06.org/qmail-lspawn.c	1998-06-15 16:23:16.000000000 +0530
+++ netqmail-1.06/qmail-lspawn.c	2018-04-03 17:28:43.669318659 +0530
@@ -1,4 +1,5 @@
 #include "fd.h"
+#include "env.h"
 #include "wait.h"
 #include "prot.h"
 #include "substdio.h"
@@ -170,6 +171,7 @@
 char *s; char *r; int at;
 {
  int f;
+ char *ptr;
 
  if (!(f = fork()))
   {
@@ -226,7 +228,10 @@
    if (prot_uid(uid) == -1) _exit(QLX_USAGE);
    if (!getuid()) _exit(QLX_ROOT);
 
-   execv(*args,args);
+	if(!(ptr = env_get("QMAILLOCAL")))
+		execv(*args, args);
+	else
+		execv(ptr, args);
    if (error_temp(errno)) _exit(QLX_EXECSOFT);
    _exit(QLX_EXECHARD);
   }
diff -Naur netqmail-1.06.org/qmail-pop3d.c netqmail-1.06/qmail-pop3d.c
--- netqmail-1.06.org/qmail-pop3d.c	2007-12-01 01:52:54.000000000 +0530
+++ netqmail-1.06/qmail-pop3d.c	2018-04-03 17:28:43.670318679 +0530
@@ -45,7 +45,7 @@
 {
   substdio_put(&ssout,buf,len);
 }
-void puts(s) char *s;
+void my_puts(s) char *s;
 {
   substdio_puts(&ssout,s);
 }
@@ -55,9 +55,9 @@
 }
 void err(s) char *s;
 {
-  puts("-ERR ");
-  puts(s);
-  puts("\r\n");
+  my_puts("-ERR ");
+  my_puts(s);
+  my_puts("\r\n");
   flush();
 }
 
@@ -73,7 +73,7 @@
 void err_nosuch() { err("unable to open that message"); }
 void err_nounlink() { err("unable to unlink all deleted messages"); }
 
-void okay(arg) char *arg; { puts("+OK \r\n"); flush(); }
+void okay(arg) char *arg; { my_puts("+OK \r\n"); flush(); }
 
 void printfn(fn) char *fn;
 {
@@ -153,11 +153,11 @@
  
   total = 0;
   for (i = 0;i < numm;++i) if (!m[i].flagdeleted) total += m[i].size;
-  puts("+OK ");
+  my_puts("+OK ");
   put(strnum,fmt_uint(strnum,numm));
-  puts(" ");
+  my_puts(" ");
   put(strnum,fmt_ulong(strnum,total));
-  puts("\r\n");
+  my_puts("\r\n");
   flush();
 }
 
@@ -171,9 +171,9 @@
 
 void pop3_last(arg) char *arg;
 {
-  puts("+OK ");
+  my_puts("+OK ");
   put(strnum,fmt_uint(strnum,last));
-  puts("\r\n");
+  my_puts("\r\n");
   flush();
 }
 
@@ -222,10 +222,10 @@
 int flaguidl;
 {
   put(strnum,fmt_uint(strnum,i + 1));
-  puts(" ");
+  my_puts(" ");
   if (flaguidl) printfn(m[i].fn);
   else put(strnum,fmt_ulong(strnum,m[i].size));
-  puts("\r\n");
+  my_puts("\r\n");
 }
 
 void dolisting(arg,flaguidl) char *arg; int flaguidl;
@@ -234,7 +234,7 @@
   if (*arg) {
     i = msgno(arg);
     if (i == -1) return;
-    puts("+OK ");
+    my_puts("+OK ");
     list(i,flaguidl);
   }
   else {
@@ -242,7 +242,7 @@
     for (i = 0;i < numm;++i)
       if (!m[i].flagdeleted)
 	list(i,flaguidl);
-    puts(".\r\n");
+    my_puts(".\r\n");
   }
   flush();
 }
diff -Naur netqmail-1.06.org/qmail-popup.c netqmail-1.06/qmail-popup.c
--- netqmail-1.06.org/qmail-popup.c	2007-12-01 01:52:54.000000000 +0530
+++ netqmail-1.06/qmail-popup.c	2018-04-03 17:28:43.670318679 +0530
@@ -38,7 +38,7 @@
 char ssinbuf[128];
 substdio ssin = SUBSTDIO_FDBUF(saferead,0,ssinbuf,sizeof ssinbuf);
 
-void puts(s) char *s;
+void my_puts(s) char *s;
 {
   substdio_puts(&ssout,s);
 }
@@ -48,9 +48,9 @@
 }
 void err(s) char *s;
 {
-  puts("-ERR ");
-  puts(s);
-  puts("\r\n");
+  my_puts("-ERR ");
+  my_puts(s);
+  my_puts("\r\n");
   flush();
 }
 
@@ -66,7 +66,7 @@
 void err_wantuser() { err("USER first"); }
 void err_authoriz(arg) char *arg; { err("authorization first"); }
 
-void okay(arg) char *arg; { puts("+OK \r\n"); flush(); }
+void okay(arg) char *arg; { my_puts("+OK \r\n"); flush(); }
 void pop3_quit(arg) char *arg; { okay(0); die(); }
 
 
@@ -127,10 +127,10 @@
   s += fmt_ulong(s,(unsigned long) now());
   *s++ = '@';
   *s++ = 0;
-  puts("+OK <");
-  puts(unique);
-  puts(hostname);
-  puts(">\r\n");
+  my_puts("+OK <");
+  my_puts(unique);
+  my_puts(hostname);
+  my_puts(">\r\n");
   flush();
 }
 void pop3_user(arg) char *arg;
diff -Naur netqmail-1.06.org/qmail-pw2u.c netqmail-1.06/qmail-pw2u.c
--- netqmail-1.06.org/qmail-pw2u.c	1998-06-15 16:23:16.000000000 +0530
+++ netqmail-1.06/qmail-pw2u.c	2018-04-03 17:28:43.670318679 +0530
@@ -1,3 +1,4 @@
+#include <unistd.h>
 #include <sys/types.h>
 #include <sys/stat.h>
 #include "substdio.h"
diff -Naur netqmail-1.06.org/qmail-qmtpd.c netqmail-1.06/qmail-qmtpd.c
--- netqmail-1.06.org/qmail-qmtpd.c	1998-06-15 16:23:16.000000000 +0530
+++ netqmail-1.06/qmail-qmtpd.c	2018-04-03 17:28:43.670318679 +0530
@@ -1,3 +1,5 @@
+#include <unistd.h>
+#include <unistd.h>
 #include "stralloc.h"
 #include "substdio.h"
 #include "qmail.h"
diff -Naur netqmail-1.06.org/qmail-rspawn.c netqmail-1.06/qmail-rspawn.c
--- netqmail-1.06.org/qmail-rspawn.c	1998-06-15 16:23:16.000000000 +0530
+++ netqmail-1.06/qmail-rspawn.c	2018-04-03 17:28:43.671318699 +0530
@@ -1,3 +1,4 @@
+#include "env.h"
 #include "fd.h"
 #include "wait.h"
 #include "substdio.h"
@@ -82,7 +83,7 @@
 char *s; char *r; int at;
 {
  int f;
- char *(args[5]);
+ char *ptr, *(args[5]);
 
  args[0] = "qmail-remote";
  args[1] = r + at + 1;
@@ -95,7 +96,10 @@
    if (fd_move(0,fdmess) == -1) _exit(111);
    if (fd_move(1,fdout) == -1) _exit(111);
    if (fd_copy(2,1) == -1) _exit(111);
-   execvp(*args,args);
+   if(!(ptr = env_get("QMAILREMOTE")))
+      execvp(*args, args);
+   else
+      execvp(ptr, args);
    if (error_temp(errno)) _exit(111);
    _exit(100);
   }
diff -Naur netqmail-1.06.org/qmail-send.c netqmail-1.06/qmail-send.c
--- netqmail-1.06.org/qmail-send.c	1998-06-15 16:23:16.000000000 +0530
+++ netqmail-1.06/qmail-send.c	2018-04-03 17:28:43.671318699 +0530
@@ -754,7 +754,7 @@
     { log1("warning: trouble injecting bounce message, will try later\n"); return 0; }
 
    strnum2[fmt_ulong(strnum2,id)] = 0;
-   log2("bounce msg ",strnum2);
+   my_log2("bounce msg ",strnum2);
    strnum2[fmt_ulong(strnum2,qp)] = 0;
    log3(" qp ",strnum2,"\n");
   }
@@ -794,8 +794,8 @@
   for (c = 0;c < CHANNELS;++c) {
     strnum2[fmt_ulong(strnum2,(unsigned long) concurrencyused[c])] = 0;
     strnum3[fmt_ulong(strnum3,(unsigned long) concurrency[c])] = 0;
-    log2(chanstatusmsg[c],strnum2);
-    log2("/",strnum3);
+    my_log2(chanstatusmsg[c],strnum2);
+    my_log2("/",strnum3);
   }
   if (flagexitasap) log1(" exitasap");
   log1("\n");
@@ -859,7 +859,7 @@
 
  strnum2[fmt_ulong(strnum2,d[c][i].delid)] = 0;
  strnum3[fmt_ulong(strnum3,jo[j].id)] = 0;
- log2("starting delivery ",strnum2);
+ my_log2("starting delivery ",strnum2);
  log3(": msg ",strnum3,tochan[c]);
  logsafe(recip);
  log1("\n");
@@ -1352,14 +1352,14 @@
 	 fnmake_info(id);
          log3("warning: trouble writing to ",fn.s,"\n"); goto fail;
 	}
-       log2("info msg ",strnum3);
+       my_log2("info msg ",strnum3);
        strnum2[fmt_ulong(strnum2,(unsigned long) st.st_size)] = 0;
-       log2(": bytes ",strnum2);
+       my_log2(": bytes ",strnum2);
        log1(" from <"); logsafe(todoline.s + 1);
        strnum2[fmt_ulong(strnum2,pid)] = 0;
-       log2("> qp ",strnum2);
+       my_log2("> qp ",strnum2);
        strnum2[fmt_ulong(strnum2,uid)] = 0;
-       log2(" uid ",strnum2);
+       my_log2(" uid ",strnum2);
        log1("\n");
        break;
      case 'T':
diff -Naur netqmail-1.06.org/qmail-showctl.c netqmail-1.06/qmail-showctl.c
--- netqmail-1.06.org/qmail-showctl.c	1998-06-15 16:23:16.000000000 +0530
+++ netqmail-1.06/qmail-showctl.c	2018-04-03 17:28:43.671318699 +0530
@@ -112,7 +112,7 @@
   substdio_puts(subfdout,"\n");
   substdio_puts(subfdout,fn);
   substdio_puts(subfdout,": ");
-  switch(control_readfile(&line,fn)) {
+  switch(control_readfile(&line,fn, 0)) {
     case 0:
       substdio_puts(subfdout,"(Default.) ");
       substdio_puts(subfdout,def);
diff -Naur netqmail-1.06.org/qmail-smtpd.c netqmail-1.06/qmail-smtpd.c
--- netqmail-1.06.org/qmail-smtpd.c	2007-12-01 01:52:54.000000000 +0530
+++ netqmail-1.06/qmail-smtpd.c	2018-04-03 17:28:43.671318699 +0530
@@ -25,6 +25,7 @@
 #include "commands.h"
 
 #define MAXHOPS 100
+static char     strnum[FMT_ULONG];
 unsigned int databytes = 0;
 int timeout = 1200;
 
@@ -218,6 +219,7 @@
 
 
 int seenmail = 0;
+int rcptcount = 0;
 int flagbarf; /* defined if seenmail */
 stralloc mailfrom = {0};
 stralloc rcptto = {0};
@@ -261,6 +263,7 @@
   if (!stralloc_cats(&rcptto,"T")) die_nomem();
   if (!stralloc_cats(&rcptto,addr.s)) die_nomem();
   if (!stralloc_0(&rcptto)) die_nomem();
+  rcptcount++;
   out("250 ok\r\n");
 }
 
diff -Naur netqmail-1.06.org/qregex.c netqmail-1.06/qregex.c
--- netqmail-1.06.org/qregex.c	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/qregex.c	2018-04-03 17:28:43.672318720 +0530
@@ -0,0 +1,239 @@
+/*
+ * $Log: qregex.c,v $
+ * Revision 1.13  2007-12-20 13:51:04+05:30  Cprogrammer
+ * removed compiler warning
+ *
+ * Revision 1.12  2005-08-23 17:41:36+05:30  Cprogrammer
+ * regex to be turned on only of QREGEX is defined to non-zero value
+ *
+ * Revision 1.11  2005-04-02 19:07:25+05:30  Cprogrammer
+ * use internal wildmat version
+ *
+ * Revision 1.10  2005-01-22 00:39:04+05:30  Cprogrammer
+ * added missing error handling
+ *
+ * Revision 1.9  2004-10-22 20:29:45+05:30  Cprogrammer
+ * added RCS id
+ *
+ * Revision 1.8  2004-09-21 23:48:18+05:30  Cprogrammer
+ * made matchregex() visible
+ * introduced dotChar (configurable dot char)
+ *
+ * Revision 1.7  2004-02-05 18:48:48+05:30  Cprogrammer
+ * changed curregex to static
+ *
+ * Revision 1.6  2003-12-23 23:22:53+05:30  Cprogrammer
+ * implicitly use wildcard if address starts with '@'
+ *
+ * Revision 1.5  2003-12-22 18:33:12+05:30  Cprogrammer
+ * added address_match()
+ *
+ * Revision 1.4  2003-12-22 13:21:08+05:30  Cprogrammer
+ * added text and pattern as part of error message
+ *
+ * Revision 1.3  2003-12-22 10:04:04+05:30  Cprogrammer
+ * conditional compilation of qregex
+ *
+ * Revision 1.2  2003-12-21 15:32:18+05:30  Cprogrammer
+ * added regerror
+ *
+ * Revision 1.1  2003-12-20 13:17:16+05:30  Cprogrammer
+ * Initial revision
+ *
+ * qregex (v2)
+ * $Id: qregex.c,v 1.13 2007-12-20 13:51:04+05:30 Cprogrammer Stab mbhangui $
+ *
+ * Author  : Evan Borgstrom (evan at unixpimps dot org)
+ * Created : 2001/12/14 23:08:16
+ * Modified: $Date: 2007-12-20 13:51:04+05:30 $
+ * Revision: $Revision: 1.13 $
+ *
+ * Do POSIX regex matching on addresses for anti-relay / spam control.
+ * It logs to the maillog
+ * See the qregex-readme file included with this tarball.
+ * If you didn't get this file in a tarball please see the following URL:
+ *  http://www.unixpimps.org/software/qregex
+ *
+ * qregex.c is released under a BSD style copyright.
+ * See http://www.unixpimps.org/software/qregex/copyright.html
+ *
+ * Note: this revision follows the coding guidelines set forth by the rest of
+ *       the qmail code and that described at the following URL.
+ *       http://cr.yp.to/qmail/guarantee.html
+ * 
+ */
+#include "case.h"
+#include "scan.h"
+#include "stralloc.h"
+#include "constmap.h"
+#include "substdio.h"
+#include "byte.h"
+#include "env.h"
+#include <sys/types.h>
+#include <regex.h>
+#include <unistd.h>
+
+static int      wildmat_match(stralloc *, int, struct constmap *, int, stralloc *);
+static int      regex_match(stralloc *, int, stralloc *);
+int             wildmat_internal(char *, char *);
+
+static char     sserrbuf[512];
+static substdio sserr = SUBSTDIO_FDBUF(write, 2, sserrbuf, sizeof(sserrbuf));
+static char     dotChar = '@';
+
+int
+address_match(stralloc *addr, int bhfok, stralloc *bhf,
+	struct constmap *mapbhf, int bhpok, stralloc *bhp)
+{
+	char           *ptr;
+	int             x = 0;
+
+	case_lowerb(addr->s, addr->len); /*- convert into lower case */
+	if ((ptr = env_get("QREGEX")))
+		scan_int(ptr, &x);
+	if (ptr && x)
+		return (regex_match(addr, bhfok, bhf));
+	else
+		return (wildmat_match(addr, bhfok, mapbhf, bhpok, bhp));
+}
+
+int
+matchregex(char *text, char *regex)
+{
+	regex_t         qreg;
+	char            errbuf[512];
+	int             retval = 0;
+
+#define REGCOMP(X,Y)    regcomp(&X, Y, REG_EXTENDED|REG_ICASE)
+	/*- build the regex */
+	if ((retval = REGCOMP(qreg, regex)) != 0)
+	{
+		regerror(retval, &qreg, errbuf, sizeof(errbuf));
+		regfree(&qreg);
+		if (substdio_puts(&sserr, text) == -1)
+			return (-retval);
+		if (substdio_puts(&sserr, ": ") == -1)
+			return (-retval);
+		if (substdio_puts(&sserr, regex) == -1)
+			return (-retval);
+		if (substdio_puts(&sserr, ": ") == -1)
+			return (-retval);
+		if (substdio_puts(&sserr, errbuf) == -1)
+			return (-retval);
+		if (substdio_puts(&sserr, "\n") == -1)
+			return (-retval);
+		if (substdio_flush(&sserr) == -1)
+			return (-retval);
+		return (-retval);
+	}
+	/*- execute the regex */
+#define REGEXEC(X,Y)    regexec(&X, Y, (size_t) 0, (regmatch_t *) 0, (int) 0)
+	retval = REGEXEC(qreg, text);
+	regfree(&qreg);
+	return (retval == REG_NOMATCH ? 0 : 1);
+}
+
+static int
+wildmat_match(stralloc * addr, int mapfile, struct constmap *ptrmap, int patfile, stralloc *wildcard)
+{
+	int             i = 0;
+	int             j = 0;
+	int             k = 0;
+	char            subvalue;
+
+	if (mapfile)
+	{
+		if (constmap(ptrmap, addr->s, addr->len - 1))
+			return 1;
+		if ((j = byte_rchr(addr->s, addr->len, dotChar)) < addr->len)
+		{
+			if (constmap(ptrmap, addr->s + j, addr->len - j - 1))
+				return 1;
+		}
+	}
+	/*- Include control file control/xxxxpatterns and evaluate with Wildmat check */
+	if (patfile && wildcard)
+	{
+		i = 0;
+		for (j = 0; j < wildcard->len; ++j)
+		{
+			if (!wildcard->s[j])
+			{
+				subvalue = wildcard->s[i] != '!';
+				if (!subvalue)
+					i++;
+				if ((k != subvalue) && wildmat_internal(addr->s, wildcard->s + i))
+					k = subvalue;
+				i = j + 1;
+			}
+		}
+		return k;
+	}
+	return (0);
+}
+
+static int
+regex_match(stralloc * addr, int mapfile, stralloc *map)
+{
+	int             i = 0;
+	int             j = 0;
+	int             k = 0;
+	int             negate = 0, match;
+	static stralloc curregex = { 0 };
+
+	match = 0;
+	if (mapfile)
+	{
+		while (j < map->len)
+		{
+			i = j;
+			while ((map->s[i] != '\0') && (i < map->len))
+				i++;
+			if (map->s[j] == '!')
+			{
+				negate = 1;
+				j++;
+			}
+			if (*(map->s + j) == dotChar)
+			{
+				if (!stralloc_copys(&curregex, ".*"))
+					return(-1);
+				if (!stralloc_catb(&curregex, map->s + j, (i - j)))
+					return(-1);
+			} else
+			if (!stralloc_copyb(&curregex, map->s + j, (i - j)))
+				return(-1);
+			if (!stralloc_0(&curregex))
+				return(-1);
+			if((k = matchregex(addr->s, curregex.s)) == 1)
+			{
+				if (negate)
+					return(0);
+				match = 1;
+			}
+			j = i + 1;
+			negate = 0;
+		}
+	}
+	return (match);
+}
+
+void
+setdotChar(c)
+	char            c;
+{
+	dotChar = c;
+	return;
+}
+
+void
+getversion_qregex_c()
+{
+	static char    *x = "$Id: qregex.c,v 1.13 2007-12-20 13:51:04+05:30 Cprogrammer Stab mbhangui $";
+
+#ifdef INDIMAIL
+	x = sccsidh;
+#else
+	x++;
+#endif
+}
diff -Naur netqmail-1.06.org/qregex.h netqmail-1.06/qregex.h
--- netqmail-1.06.org/qregex.h	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/qregex.h	2018-04-03 17:28:43.672318720 +0530
@@ -0,0 +1,24 @@
+/*
+ * $Log: qregex.h,v $
+ * Revision 1.3  2004-09-21 23:49:02+05:30  Cprogrammer
+ * added matchregex() and setdotChar()
+ *
+ * Revision 1.2  2003-12-22 18:35:26+05:30  Cprogrammer
+ * added address_match() function
+ *
+ * Revision 1.1  2003-12-20 13:17:45+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
+/*
+ * simple header file for the matchregex prototype 
+ */
+#ifndef _QREGEX_H_
+#define _QREGEX_H_
+#include "constmap.h"
+#include "stralloc.h"
+
+int             address_match(stralloc *, int, stralloc *, struct constmap *, int, stralloc *);
+int             matchregex(char *, char *);
+void            setdotChar(char);
+#endif
diff -Naur netqmail-1.06.org/qsutil.c netqmail-1.06/qsutil.c
--- netqmail-1.06.org/qsutil.c	1998-06-15 16:23:16.000000000 +0530
+++ netqmail-1.06/qsutil.c	2018-04-03 17:28:43.672318720 +0530
@@ -12,7 +12,7 @@
  substdio_putflush(&sserr,sa->s,sa->len); }
 void log1(s1) char *s1; {
  substdio_putsflush(&sserr,s1); }
-void log2(s1,s2) char *s1; char *s2; {
+void my_log2(s1,s2) char *s1; char *s2; {
  substdio_putsflush(&sserr,s1);
  substdio_putsflush(&sserr,s2); }
 void log3(s1,s2,s3) char *s1; char *s2; char *s3; {
diff -Naur netqmail-1.06.org/qsutil.h netqmail-1.06/qsutil.h
--- netqmail-1.06.org/qsutil.h	1998-06-15 16:23:16.000000000 +0530
+++ netqmail-1.06/qsutil.h	2018-04-03 17:28:43.672318720 +0530
@@ -2,7 +2,7 @@
 #define QSUTIL_H
 
 extern void log1();
-extern void log2();
+extern void my_log2();
 extern void log3();
 extern void logsa();
 extern void nomem();
diff -Naur netqmail-1.06.org/readwrite.h netqmail-1.06/readwrite.h
--- netqmail-1.06.org/readwrite.h	1998-06-15 16:23:16.000000000 +0530
+++ netqmail-1.06/readwrite.h	2018-04-03 17:28:43.672318720 +0530
@@ -1,7 +1,6 @@
 #ifndef READWRITE_H
 #define READWRITE_H
 
-extern int read();
-extern int write();
+#include <unistd.h>
 
 #endif
diff -Naur netqmail-1.06.org/scan.h netqmail-1.06/scan.h
--- netqmail-1.06.org/scan.h	1998-06-15 16:23:16.000000000 +0530
+++ netqmail-1.06/scan.h	2018-04-03 17:28:43.673318740 +0530
@@ -2,6 +2,7 @@
 #define SCAN_H
 
 extern unsigned int scan_uint();
+extern unsigned int scan_int();
 extern unsigned int scan_xint();
 extern unsigned int scan_nbbint();
 extern unsigned int scan_ushort();
diff -Naur netqmail-1.06.org/scan_ulong.c netqmail-1.06/scan_ulong.c
--- netqmail-1.06.org/scan_ulong.c	1998-06-15 16:23:16.000000000 +0530
+++ netqmail-1.06/scan_ulong.c	2018-04-03 17:28:43.673318740 +0530
@@ -9,3 +9,43 @@
     { result = result * 10 + c; ++pos; }
   *u = result; return pos;
 }
+
+unsigned int
+scan_int(s, i)
+	register char  *s;
+	register int   *i;
+{
+	register unsigned int pos;
+	register int result;
+	register unsigned char c;
+	int             sign;
+
+	pos = 0;
+	result = 0;
+	sign = 1;
+	/*-
+	 * determine sign of the number
+	 */
+	switch (s[0])
+	{
+		case '\0':
+			return 0;
+		case '-':
+			++pos;
+			sign = -1;
+			break;
+		case '+':
+			++pos;
+			sign = 1;
+			break;
+		default:
+			break;
+	}
+	while ((c = (unsigned char)(s[pos] - '0')) < 10)
+	{
+		result = result * 10 + c;
+		++pos;
+	}
+	*i = result * sign;
+	return pos;
+}
diff -Naur netqmail-1.06.org/scan_xlong.c netqmail-1.06/scan_xlong.c
--- netqmail-1.06.org/scan_xlong.c	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/scan_xlong.c	2018-04-03 17:28:43.673318740 +0530
@@ -0,0 +1,47 @@
+/*
+ * $Log: scan_xlong.c,v $
+ * Revision 1.2  2005-06-15 22:35:48+05:30  Cprogrammer
+ * added RCS version information
+ *
+ * Revision 1.1  2005-06-15 22:11:59+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
+#include "scan.h"
+
+static int
+fromhex(unsigned char c)
+{
+	if (c >= '0' && c <= '9')
+		return c - '0';
+	else
+	if (c >= 'A' && c <= 'F')
+		return c - 'A' + 10;
+	else
+	if (c >= 'a' && c <= 'f')
+		return c - 'a' + 10;
+	return -1;
+}
+
+unsigned int
+scan_xlong(char *src, unsigned long *dest)
+{
+	register const char *tmp = src;
+	register int    l = 0;
+	register unsigned char c;
+	while ((c = fromhex(*tmp)) < 16)
+	{
+		l = (l << 4) + c;
+		++tmp;
+	}
+	*dest = l;
+	return tmp - src;
+}
+
+void
+getversion_scan_xlong_c()
+{
+	static char    *x = "$Id: scan_xlong.c,v 1.2 2005-06-15 22:35:48+05:30 Cprogrammer Stab mbhangui $";
+
+	x++;
+}
diff -Naur netqmail-1.06.org/socket_v4mappedprefix.c netqmail-1.06/socket_v4mappedprefix.c
--- netqmail-1.06.org/socket_v4mappedprefix.c	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/socket_v4mappedprefix.c	2018-04-03 17:28:43.673318740 +0530
@@ -0,0 +1,9 @@
+/*
+ * $Log: socket_v4mappedprefix.c,v $
+ * Revision 1.1  2005-06-15 22:12:51+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
+#ifdef IPV6
+unsigned char V4mappedprefix[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff };
+#endif
diff -Naur netqmail-1.06.org/socket_v6any.c netqmail-1.06/socket_v6any.c
--- netqmail-1.06.org/socket_v6any.c	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/socket_v6any.c	2018-04-03 17:28:43.674318760 +0530
@@ -0,0 +1,9 @@
+/*
+ * $Log: socket_v6loopback.c,v $
+ * Revision 1.1  2005-06-15 22:13:07+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
+#ifdef IPV6
+const unsigned char V6any[16]={0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
+#endif
diff -Naur netqmail-1.06.org/softwarelicense1-1.html netqmail-1.06/softwarelicense1-1.html
--- netqmail-1.06.org/softwarelicense1-1.html	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/softwarelicense1-1.html	2018-04-03 17:28:43.674318760 +0530
@@ -0,0 +1,59 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
+<html>
+<head>
+<title>Yahoo! DomainKeys Public License Agreement v1.0</title>
+<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
+</head>
+
+<body>
+Yahoo! DomainKeys Public License Agreement v1.1<br>
+(this &quot;Agreement&quot;)
+<p>Copyright (c) 2004, Yahoo! Inc.<br>
+ All rights reserved.</p>
+
+<br>
+<a href=http://domainkeys.sourceforge.net/license/softwarelicense1-1.html>(Available online)</a>
+<br>
+
+
+<p>This Agreement is between Licensor and You.  You agree to be bound by all the terms and conditions set forth below, and, subject to those terms and conditions, You may use the intellectual property described below. </p>
+<p>1.    LICENSE GRANT. </p>
+<p>1.1. Subject to the terms and conditions of this Agreement, each DomainKeys Developer hereby grants You a royalty-free, perpetual, worldwide, sublicensable, non-exclusive license to use, reproduce, modify, publicly display, publicly perform, and distribute the Licensed Code.</p>
+<p>1.2. Subject to the terms and conditions of this Agreement, Licensor hereby grants You a royalty-free, perpetual, worldwide, sublicensable, non-exclusive license under its rights to the Yahoo! Patent Claims to make, use, sell, offer for sale, and/or import the Licensed Code for the sole purpose of implementing a sender verification solution in connection with e-mail. </p>
+<p>2.    DEFINITIONS. </p>
+<p>2.1. &quot;Contributions&quot; means any modifications to the Licensed Code, and/or any portions thereof, that are distributed under this Agreement.  A Contribution includes, without limitation, any addition to or deletion from the contents of a file containing any Licensed Code, or any new file that contains any part of the Licensed Code.</p>
+<p>2.2. &quot;DomainKeys Developer(s)&quot; means Yahoo, Inc. (&quot;Yahoo!&quot;), Licensor, and/or any other individual or entity who distributes code under this Agreement.</p>
+<p>2.3. &quot;Licensed Code&quot; means the Original Code, any Contributions (whether made by You or any DomainKeys Developer other than You), and the combination of Original Code and any such Contributions.</p>
+<p>2.4. &quot;Licensor&quot; means Yahoo! or any other individual or entity that elects to use this Agreement to license intellectual property to any licensee.</p>
+<p>2.5. &quot;Original Code&quot; means the source code and binary code that is based on the Specifications and distributed by or on behalf of Yahoo! under this Agreement for the sole purpose of implementing a sender verification solution in connection with e-mail, including any updates or upgrades to such code made available by Yahoo!.</p>
+<p>2.6. &quot;Specifications&quot; means the specification having submission ID &quot;draft-delany-domainkeys-base-01.txt&quot; dated Aug 2004 published through the IETF (Internet Engineering Task Force). The Specifications may be found at the following link: <br>
+<a href="http://antispam.yahoo.com/domainkeys/draft-delany-domainkeys-base-02.txt">http://antispam.yahoo.com/domainkeys/draft-delany-domainkeys-base-02.txt</a></p>
+<p>
+ 2.7. &quot;Yahoo! Patent Claims&quot; shall mean those claims of all Yahoo! foreign and domestic patents and patent applications that base their priority on U.S. Provisional Patent Application Ser. Nos. 60/497,794, filed Aug. 26, 2003, or 60/553,300, filed Mar. 15, 2004, or U.S. Patent Application Ser. Nos. 10/671,319, filed Sep. 24, 2003, or 10/805,181, filed Mar. 19, 2004.  </p>
+<p>2.8. &quot;You&quot; or &quot;Your&quot; means an individual, company, or other legal entity exercising any rights under this Agreement.  Any individual who accepts the terms and conditions of this Agreement on behalf of a company or other legal entity represents and warrants that the individual has the authority to enter into this Agreement on behalf of the company or other legal entity. </p>
+<p>3.    TERMS. </p>
+<p>3.1. You agree not to assert against Yahoo!, any other DomainKeys Developer or any of their respective licensees under Section 3.4, a patent infringement claim based on the manufacture, use, sale, offer for sale and/or importation of any of the specific portions of a hardware or software implementation expressly required to be compliant with the Specifications for the sole purpose of implementing a sender verification solution in connection with e-mail (&quot;Licensed Code IP Claim&quot;).</p>
+<p>3.2. To indicate your assent to the terms and conditions of this Agreement and in order to obtain a license to use, reproduce, modify, publicly display, publicly perform, distribute, and sublicense Licensed Code, You must:</p>
+<p>(a) include, attach or preserve the following prominently displayed statement in the Licensed Code: &quot;This code incorporates intellectual property owned by Yahoo! and licensed pursuant to the Yahoo! DomainKeys Public License Agreement.&quot;; </p>
+<p>(b) preserve the copyright and other proprietary notices and disclaimers of DomainKeys Developers as they appear in the Licensed Code; and  </p>
+<p>(c) if the Licensed Code developed by You is distributed in source form, You must identify Yourself, in the source code of such Licensed Code, as the originator of any modifications in a manner that reasonably allows subsequent DomainKeys Developers or their licensees to identify the originator of the modifications.</p>
+<p>3.3. You will not use the name of Yahoo! to endorse or promote any products, services, or Licensed Code without specific prior written permission of Yahoo!.  &quot;DomainKeys&quot; is a trademark of Yahoo!.  However, You may state Your Licensed Code is &quot;DomainKeys compliant&quot;, &quot;supports DomainKeys&quot;, or is &quot;DomainKeys-enabled&quot;, without citation to Yahoo!.  You must create Your own product or service names or trademarks for Your Licensed Code and You agree not to use the term &quot;DomainKeys&quot; in or as part of a name or trademark for Your Licensed Code.</p>
+<p>3.4. You may choose to distribute Licensed Code or modifications under this Agreement or a different agreement, provided that:</p>
+<p>(a) a copy of this Agreement or the different agreement is included with each copy of the Licensed Code or modifications along with the following prominently displayed statement: &quot;By using, reproducing, modifying, publicly displaying, publicly performing, distributing, and/or sublicensing this code as permitted, you agree to the terms and conditions of the Yahoo! DomainKeys Public License Agreement or other agreement contained herein.&quot;; and</p>
+<p>(b) if distributed under a different agreement, such different agreement contains terms and conditions that (i) provide no fewer rights, privileges and immunities to DomainKeys Developers than the terms and conditions of this Agreement, including, without limitation, Sections 1.2, 3.1, 3.4, 3.7, 4.1, 4.2, and 4.3, except that You may alter the terms and conditions of Section 1.1 and (ii) apply such terms and conditions to the Licensed Code and/or modifications made by You.</p>
+<p>3.5. You acknowledge that Licensed Code may be subject to U.S. export restriction and other applicable national and international laws.  You agree to comply with all export, re-export, or import restrictions, laws, or regulations. </p>
+<p>3.6. Yahoo!, and only Yahoo!, may, from time to time and at its sole discretion, update or modify the terms of this Agreement.  If Yahoo! makes any such modifications, You may continue under the terms and conditions of this Agreement or agree to the updated or modified terms and conditions.  For the most recent version of this Agreement please contact Yahoo!.</p>
+<p>3.7. This Agreement and the rights hereunder will terminate: <br>
+ (a) automatically without notice from Yahoo!, if You at any time during the term of this Agreement assert any Licensed Code IP Claim against Yahoo!; </p>
+<p>(b) upon written notice from Yahoo!, if You at any time during the term of this Agreement assert any Licensed Code IP Claim against any DomainKeys Developer (other than Yahoo!) or any licensees of any DomainKeys Developer; or </p>
+<p>(c) where (a) or (b) do not apply, automatically without notice from Yahoo!, if You fail to comply with any term(s) of this Agreement and fail to cure such breach within 30 days of You becoming aware of such breach. </p>
+<p>3.8. This Agreement constitutes the entire agreement between the parties with respect to the subject matter hereof.  This Agreement shall be governed by and construed under the laws of the United States and the State of California without giving effect to California conflict of law provisions or to construction provisions favoring either party.  All actions arising out of or relating to this Agreement that involve Yahoo! as a party will be adjudicated exclusively by the Superior Court of the State of California for the County of Santa Clara or the United States District Court for the Northern District of California. </p>
+<p>3.9. In the event that any provision of this Agreement is deemed to be invalid, such invalidity shall not affect the remainder of this Agreement.</p>
+<p>4.    <b>LEGAL DISCLAIMERS. </b></p>
+<p>4.1. <b>THE YAHOO! PATENT CLAIMS, THIS AGREEMENT, LICENSED CODE, THE DOMAINKEYS TRADEMARK, AND THE SPECIFICATIONS ARE PROVIDED ON AN &quot;AS IS&quot; BASIS, WITHOUT REPRESENTATIONS, WARRANTIES OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING, WITHOUT LIMITATION, ANY REPRESENTATIONS, WARRANTIES OR CONDITIONS OF TITLE, NON-INFRINGEMENT, MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE.</b>  You are solely responsible for determining the appropriateness of exercising any rights under this Agreement and using the Specifications, Licensed Code, and the DomainKeys trademark and assume all risks associated in connection therewith, including, but not limited to, the risks and costs of program errors, compliance with applicable laws, damage to or loss of data, programs or equipment, and unavailability or interruption of operations. </p>
+<p>4.2. You expressly acknowledge and agree that no assurances are provided by DomainKeys Developers with respect to the validity of the Yahoo! Patent Claims or that the Specifications, Licensed Code, the DomainKeys trademark or any implementations related to the Specifications, Licensed Code or the DomainKeys trademark do not infringe or misappropriate the patent, trademark or other intellectual property rights of any other entity.  DomainKeys Developers disclaim any liability to You for claims brought by any other person or entity based on infringement or misappropriation of intellectual property rights or otherwise.  As a condition to exercising the rights and licenses granted hereunder, You hereby assume sole responsibility to secure any other intellectual property rights needed. </p>
+<p>4.3. <b>DOMAINKEYS DEVELOPERS SHALL NOT HAVE ANY LIABILITY FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING WITHOUT LIMITATION LOST PROFITS), HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE EXERCISE OF ANY RIGHTS UNDER THIS AGREEMENT, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGES, AND EVEN IF THE REMEDIES PROVIDED FOR IN THIS AGREEMENT FAIL OF THEIR ESSENTIAL PURPOSE.</b></p>
+
+</body>
+</html>
+
diff -Naur netqmail-1.06.org/spawn-filter.9 netqmail-1.06/spawn-filter.9
--- netqmail-1.06.org/spawn-filter.9	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/spawn-filter.9	2018-04-03 17:28:43.674318760 +0530
@@ -0,0 +1,103 @@
+.TH spawn-filter 8
+.SH NAME
+spawn-filter \- Helper for running filters for qmail-local and qmail-remote
+.SH SYNOPSIS
+.B spawn-filter args
+.SH DESCRIPTION
+.B spawn-filter
+is a utility to help qmail run any filter during local or remote delivery. It
+can run any filter which expects to read mess on fd 0 and writes back the message on fd 1.
+The filter can be turned on individually for local and remote mails by defining
+.B QMAILLOCAL
+and
+.B QMAILREMOTE
+environment variables respectively in
+.B qmail-send
+supervise or rc script. If spawn-filter is invoked as qmail-local, it executes the
+original
+.B qmail-local
+after runing the mail through the filter. If spawn-filter is invoked as qmail-remote, it
+executes the original
+.B qmail-remote
+after running the mail through the filter. Hence QMAILLOCAL should be set as QMAILHOME/bin/spawn-filter
+for filtering local mails and QMAILREMOTE as QMAILHOME/bin/spawn-filter for filtering
+remote mails.
+
+Filters can be run by setting the environment variable
+.B FILTERARGS
+or by using a control file
+.BR filterargs.
+The environment variable overrides the control file.
+.B spawn-filter
+uses /bin/sh to run the filter (with arguments) specified by the FILTERARGS environment variable or the control file
+.BR filterargs .
+The environment variable FILTERARGS apply to both local and remote mails. For individual domain level control,
+it is best to set using the control file filterargs.
+
+.TP 5
+.I filterargs
+The format of this file is of the form
+.B domain:args
+for both local and remote mails.
+.B domain:remote:args
+for remote mails and
+.B domain:local:args
+for local mails.
+
+.EX
+indimail.org:remote:QMAILHOME/bin/dk-filter
+.EE
+
+.TP 0
+The sequence in which the filter program is run is given below
+
+.TP 5
+1. create two pipes and fork
+.TP 5
+2. dup write end of the first pipe to descriptor 1, dup write end of the second pipe to descriptor 2 in the child and exec the filter program
+.TP 5
+3. dup read end of the pipe to descriptor 0 in parent and exec qmail-local for local mails and qmail-remote for remote mails.
+.TP 5
+4. Wait for filter to exit and read read end of second pipe for any error messages.
+.TP 5
+5. Report success or failure
+.TP 0
+
+This gives the ability for the any filter program to read the mail message from descriptor 0 before
+passing it to qmail-local/qmail-remote through the pipe.
+
+.B spawn-filter
+will attempt to make the descriptor 0 seekable if the environment variable MAKE_SEEKABLE
+is defined. This may be necessary for certain filter programs which could do lseek().
+
+.B spawn-filter
+sets the environment variable
+.B DOMAIN
+to the recipient domain. This can be conveniently used in programs/scripts which get invoked by
+setting
+.B FILTERARGS
+environment variable or by rules in the control file
+.BR filterargs .
+
+.SH "EXIT CODES"
+.B spawn-filter
+exits 111 for any error or if it is not able to exec
+QMAILHOME/bin/qmail-local (for local mails) or
+QMAILHOME/bin/qmail-remote (for remote mails).
+
+.SH "SEE ALSO"
+qmail-lspawn(8),
+qmail-rspawn(8),
+qmail-local(8),
+qmail-remote(8),
+qmail-smtpd(8),
+qmail-control(5),
+qmail-queue(8)
+
+.SH "AUTHORS"
+
+Manvendra Bhangui.
+.SH PROBLEMS
+Problems with
+.B spawn-filter
+should be forwarded to "Manvendra Bhangui" <mbhangui@gmail.com>
diff -Naur netqmail-1.06.org/spawn-filter.c netqmail-1.06/spawn-filter.c
--- netqmail-1.06.org/spawn-filter.c	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/spawn-filter.c	2018-04-03 17:28:43.675318780 +0530
@@ -0,0 +1,546 @@
+/*
+ * netqmail-version without spam filter
+ *
+ * $Log: spawn-filter.c,v $
+ * Revision 1.41  2009-04-03 11:42:48+05:30  Cprogrammer
+ * create pipe for error messages
+ *
+ * Revision 1.40  2009-04-02 15:17:54+05:30  Cprogrammer
+ * unset QMAILLOCAL in qmail-remote and unset QMAILREMOTE in qmail-local
+ *
+ * Revision 1.39  2008-06-12 08:40:55+05:30  Cprogrammer
+ * added rulesfile argument
+ *
+ * Revision 1.38  2008-05-25 17:16:43+05:30  Cprogrammer
+ * made message more readable by adding a blank space
+ *
+ * Revision 1.37  2007-12-20 13:51:54+05:30  Cprogrammer
+ * avoid loops with FILTERARGS, SPAMFILTERARGS
+ * removed compiler warning
+ *
+ * Revision 1.36  2006-06-07 14:11:28+05:30  Cprogrammer
+ * added SPAMEXT, SPAMHOST, SPAMSENDER, QQEH environment variable
+ * unset FILTERARGS before calling filters
+ *
+ * Revision 1.35  2006-01-22 10:14:45+05:30  Cprogrammer
+ * BUG fix for spam mails wrongly getting blackholed
+ *
+ * Revision 1.34  2005-08-23 17:36:48+05:30  Cprogrammer
+ * gcc 4 compliance
+ * delete sender in spam notification
+ *
+ * Revision 1.33  2005-04-02 19:07:47+05:30  Cprogrammer
+ * use internal wildmat version
+ *
+ * Revision 1.32  2004-11-22 19:50:53+05:30  Cprogrammer
+ * include regex.h after sys/types.h to avoid compilation prob on RH 7.3
+ *
+ * Revision 1.31  2004-10-22 20:30:35+05:30  Cprogrammer
+ * added RCS id
+ *
+ * Revision 1.30  2004-10-21 21:56:21+05:30  Cprogrammer
+ * change for two additional arguments to strerr_die()
+ *
+ * Revision 1.29  2004-10-11 14:06:14+05:30  Cprogrammer
+ * use control_readulong instead of control_readint
+ *
+ * Revision 1.28  2004-09-22 23:14:20+05:30  Cprogrammer
+ * replaced atoi() with scan_int()
+ *
+ * Revision 1.27  2004-09-08 10:54:49+05:30  Cprogrammer
+ * incorrect exit code in report() function for remote
+ * mails. Caused qmail-rspawn to report "Unable to run qmail-remote"
+ *
+ * Revision 1.26  2004-07-17 21:23:31+05:30  Cprogrammer
+ * change qqeh code in qmail-remote
+ *
+ * Revision 1.25  2004-07-15 23:40:46+05:30  Cprogrammer
+ * fixed compilation warning
+ *
+ * Revision 1.24  2004-07-02 16:15:25+05:30  Cprogrammer
+ * override control files rejectspam, spamredirect by
+ * environment variables REJECTSPAM and SPAMREDIRECT
+ * allow patterns in domain specification in the control files
+ * spamfilterargs, filterargs, rejectspam and spamredirect
+ *
+ * Revision 1.23  2004-06-03 22:58:34+05:30  Cprogrammer
+ * fixed compilation problem without indimail
+ *
+ * Revision 1.22  2004-05-23 22:18:17+05:30  Cprogrammer
+ * added envrules filename as argument
+ *
+ * Revision 1.21  2004-05-19 23:15:07+05:30  Cprogrammer
+ * added comments
+ *
+ * Revision 1.20  2004-05-12 22:37:47+05:30  Cprogrammer
+ * added check DATALIMIT check
+ *
+ * Revision 1.19  2004-05-03 22:17:36+05:30  Cprogrammer
+ * use QUEUE_BASE instead of auto_qmail
+ *
+ * Revision 1.18  2004-02-13 14:51:24+05:30  Cprogrammer
+ * added envrules
+ *
+ * Revision 1.17  2004-01-20 06:56:56+05:30  Cprogrammer
+ * unset FILTERARGS for notifications
+ *
+ * Revision 1.16  2004-01-20 01:52:08+05:30  Cprogrammer
+ * report string length corrected
+ *
+ * Revision 1.15  2004-01-10 09:44:36+05:30  Cprogrammer
+ * added comment for exit codes of bogofilter
+ *
+ * Revision 1.14  2004-01-08 00:32:49+05:30  Cprogrammer
+ * use TMPDIR environment variable for temporary directory
+ * send spam reports to central spam logger
+ *
+ * Revision 1.13  2003-12-30 00:44:42+05:30  Cprogrammer
+ * set argv[0] from spamfilterprog
+ *
+ * Revision 1.12  2003-12-22 18:34:25+05:30  Cprogrammer
+ * replaced spfcheck() with address_match()
+ *
+ * Revision 1.11  2003-12-20 01:35:06+05:30  Cprogrammer
+ * added wait_pid to prevent zombies
+ *
+ * Revision 1.10  2003-12-17 23:33:39+05:30  Cprogrammer
+ * improved logic for getting remote/local tokens
+ *
+ * Revision 1.9  2003-12-16 10:38:24+05:30  Cprogrammer
+ * fixed incorrect address being returned if filterargs contained local: or
+ * remote: directives
+ *
+ * Revision 1.8  2003-12-15 20:46:19+05:30  Cprogrammer
+ * added case 100 to bounce mail
+ *
+ * Revision 1.7  2003-12-15 13:51:44+05:30  Cprogrammer
+ * code to run additional filters using /bin/sh
+ *
+ * Revision 1.6  2003-12-14 11:36:18+05:30  Cprogrammer
+ * added option to blackhole spammers
+ *
+ * Revision 1.5  2003-12-13 21:08:46+05:30  Cprogrammer
+ * extensive rewrite
+ * common report() function for local/remote mails to report errors
+ *
+ * Revision 1.4  2003-12-12 20:20:55+05:30  Cprogrammer
+ * use -a option to prevent using header addresses
+ *
+ * Revision 1.3  2003-12-09 23:37:16+05:30  Cprogrammer
+ * change for spawn-filter to be called as qmail-local or qmail-remote
+ *
+ * Revision 1.2  2003-12-08 23:48:23+05:30  Cprogrammer
+ * new function getDomainToken() to retrieve domain specific values
+ * read rejectspam and spamredirect only if SPAMEXITCODE is set
+ *
+ * Revision 1.1  2003-12-07 13:02:00+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
+#include "fmt.h"
+#include "str.h"
+#include "strerr.h"
+#include "env.h"
+#include "substdio.h"
+#include "subfd.h"
+#include "stralloc.h"
+#include "error.h"
+#include "control.h"
+#include "wait.h"
+#include "qregex.h"
+#include "auto_qmail.h"
+#include <regex.h>
+#include <unistd.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <fcntl.h>
+
+#define REGCOMP(X,Y)    regcomp(&X, Y, REG_EXTENDED|REG_ICASE)
+#define REGEXEC(X,Y)    regexec(&X, Y, (size_t) 0, (regmatch_t *) 0, (int) 0)
+
+static int      mkTempFile(int);
+static void     report(int, char *, char *, char *, char *, char *, char *);
+char           *getDomainToken(char *, stralloc *);
+static int      run_mailfilter(char *, char *, char **);
+int             wildmat_internal(char *, char *);
+static int      check_size(char *);
+
+static int      remotE;
+stralloc        sender = { 0 };
+stralloc        recipient = { 0 };
+
+static int
+check_size(char *size)
+{
+	char           *x;
+	unsigned long   databytes = -1, msgsize;
+
+	if (!(x = env_get("DATABYTES")))
+	{
+		if (control_readulong(&databytes, "databytes") == -1)
+			report(111, "spawn-filter: Unable to read databytes: ", error_str(errno), ". (#4.3.0)", 0, 0, 0);
+	} else
+		scan_ulong(x, &databytes);
+	if (databytes == -1)
+		return (0);
+	scan_ulong(size, &msgsize);
+	if (msgsize > databytes)
+		return(1);
+	else
+		return(0);
+}
+
+static void
+report(int errCode, char *s1, char *s2, char *s3, char *s4, char *s5, char *s6)
+{
+	if (!remotE) /*- strerr_die does not return */
+		strerr_die(errCode, s1, s2, s3, s4, s5, s6, 0, 0, (struct strerr *) 0);
+	/*- h - hard, s - soft */
+	if (substdio_put(subfdoutsmall, errCode == 111 ? "s" : "h", 1) == -1)
+		_exit(111);
+	if (s1 && substdio_puts(subfdoutsmall, s1) == -1)
+		_exit(111);
+	if (s2 && substdio_puts(subfdoutsmall, s2) == -1)
+		_exit(111);
+	if (s3 && substdio_puts(subfdoutsmall, s3) == -1)
+		_exit(111);
+	if (s4 && substdio_puts(subfdoutsmall, s4) == -1)
+		_exit(111);
+	if (s5 && substdio_puts(subfdoutsmall, s5) == -1)
+		_exit(111);
+	if (s6 && substdio_puts(subfdoutsmall, s6) == -1)
+		_exit(111);
+	if (substdio_put(subfdoutsmall, "\0", 1) == -1)
+		_exit(111);
+	if (substdio_puts(subfdoutsmall, 
+		errCode == 111 ?  "Zspawn-filter said: Message deferred" : "DGiving up on spawn-filter\n") == -1)
+		_exit(111);
+	if (substdio_put(subfdoutsmall, "\0", 1) == -1)
+		_exit(111);
+	substdio_flush(subfdoutsmall);
+	/*- For qmail-rspawn to stop complaining unable to run qmail-remote */
+	_exit(0);
+}
+
+void
+set_environ(char *host, char *sender, char *recipient)
+{
+	if (!env_put2("DOMAIN", host)) 
+		report(111, "spawn-filter: out of mem: ", error_str(errno), ". (#4.3.0)", 0, 0, 0);
+	if (!env_put2("_SENDER", sender))
+		report(111, "spawn-filter: out of mem: ", error_str(errno), ". (#4.3.0)", 0, 0, 0);
+	if (!env_put2("_RECIPIENT", recipient))
+		report(111, "spawn-filter: out of mem: ", error_str(errno), ". (#4.3.0)", 0, 0, 0);
+	return;
+}
+
+static int
+run_mailfilter(char *domain, char *mailprog, char **argv)
+{
+	char            strnum[FMT_ULONG];
+	pid_t           filt_pid;
+	int             pipefd[2], pipefe[2];
+	int             wstat, filt_exitcode, len = 0;
+	char           *filterargs;
+	static stralloc filterdefs = { 0 };
+	static char     errstr[1024];
+	char            inbuf[1024];
+	char            ch;
+	static substdio errbuf;
+
+	if (!(filterargs = env_get("FILTERARGS")))
+	{
+		if (control_readfile(&filterdefs, "control/filterargs", 0) == -1)
+			report(111, "spawn-filter: Unable to read filterargs: ", error_str(errno), ". (#4.3.0)", 0, 0, 0);
+		filterargs = getDomainToken(domain, &filterdefs);
+	}
+	if (!filterargs)
+	{
+		execv(mailprog, argv);
+		report(111, "spawn-filter: could not exec ", mailprog, ": ", error_str(errno), ". (#4.3.0)", 0);
+		_exit(111); /*- To make compiler happy */
+	}
+	if (pipe(pipefd) == -1)
+		report(111, "spawn-filter: Trouble creating pipes: ", error_str(errno), ". (#4.3.0)", 0, 0, 0);
+	if (pipe(pipefe) == -1)
+		report(111, "spawn-filter: Trouble creating pipes: ", error_str(errno), ". (#4.3.0)", 0, 0, 0);
+	switch ((filt_pid = fork()))
+	{
+	case -1:
+		report(111, "spawn-filter: Trouble creating child filter: ", error_str(errno), ". (#4.3.0)", 0, 0, 0);
+	case 0: /*- Filter Program */
+		set_environ(domain, sender.s, recipient.s);
+		/*- Mail content read from fd 0 */
+		if (mkTempFile(0))
+			report(111, "spawn-filter: lseek error: ", error_str(errno), ". (#4.3.0)", 0, 0, 0);
+		/*- stdout will go here */
+		if (dup2(pipefd[1], 1) == -1 || close(pipefd[0]) == -1)
+			report(111, "spawn-filter: dup2 error: ", error_str(errno), ". (#4.3.0)", 0, 0, 0);
+		if (pipefd[1] != 1)
+			close(pipefd[1]);
+		/*- stderr will go here */
+		if (dup2(pipefe[1], 2) == -1 || close(pipefe[0]) == -1)
+			report(111, "spawn-filter: dup2 error: ", error_str(errno), ". (#4.3.0)", 0, 0, 0);
+		if (pipefe[1] != 2)
+			close(pipefe[1]);
+		/*- Avoid loop if program(s) defined by FILTERARGS call qmail-inject, etc */
+		if (!env_unset("FILTERARGS") || !env_unset("SPAMFILTER"))
+			report(111, "spawn-filter: out of mem: ", error_str(errno), ". (#4.3.0)", 0, 0, 0);
+		execl("/bin/sh", "IndiMailfilter", "-c", filterargs, (char *) 0);
+		report(111, "spawn-filter: could not exec /bin/sh: ",  filterargs, ": ", error_str(errno), ". (#4.3.0)", 0);
+	default:
+		close(pipefe[1]);
+		close(pipefd[1]);
+		if (dup2(pipefd[0], 0))
+		{
+			close(pipefd[0]);
+			close(pipefe[0]);
+			wait_pid(&wstat, filt_pid);
+			report(111, "spawn-filter: dup2 error: ", error_str(errno), ". (#4.3.0)", 0, 0, 0);
+		}
+		if (pipefd[0] != 0)
+			close(pipefd[0]);
+		if (mkTempFile(0))
+		{
+			close(0);
+			close(pipefe[0]);
+			wait_pid(&wstat, filt_pid);
+			report(111, "spawn-filter: lseek error: ", error_str(errno), ". (#4.3.0)", 0, 0, 0);
+		}
+		break;
+	}
+	/*- Process message if exit code is 0, bounce if 100 */
+	if (wait_pid(&wstat, filt_pid) != filt_pid)
+	{
+		close(0);
+		close(pipefe[0]);
+		report(111, "spawn-filter: waitpid surprise: ", error_str(errno), ". (#4.3.0)", 0, 0, 0);
+	}
+	if (wait_crashed(wstat))
+	{
+		close(0);
+		close(pipefe[0]);
+		report(111, "spawn-filter: filter crashed: ", error_str(errno), ". (#4.3.0)", 0, 0, 0);
+	}
+	switch (filt_exitcode = wait_exitcode(wstat))
+	{
+	case 0:
+		execv(mailprog, argv);
+		report(111, "spawn-filter: could not exec ", mailprog, ": ", error_str(errno), ". (#4.3.0)", 0);
+	case 100:
+		report(100, "Mail Rejected (#5.7.1)", 0, 0, 0, 0, 0);
+	default:
+		substdio_fdbuf(&errbuf, read, pipefe[0], inbuf, sizeof(inbuf));
+		for (len = 0; substdio_bget(&errbuf, &ch, 1) && len < (sizeof(errstr) - 1); len++)
+			errstr[len] = ch;
+		errstr[len] = 0;
+		strnum[fmt_ulong(strnum, filt_exitcode)] = 0;
+		report(111, filterargs, ": (spawn-filter) exit code: ", strnum, *errstr ? ": " : 0, *errstr ? errstr : 0, ". (#4.3.0)");
+	}
+	/*- Not reached */
+	return(111);
+}
+
+char           *
+getDomainToken(char *domain, stralloc *sa)
+{
+	regex_t         qreg;
+	int             len, n, retval;
+	char           *ptr, *p;
+	char            errbuf[512];
+
+	for (len = 0, ptr = sa->s;len < sa->len;)
+	{
+		len += ((n = str_len(ptr)) + 1);
+		for (p = ptr;*p && *p != ':';p++);
+		if (*p == ':')
+		{
+			*p = 0;
+			/*- build the regex */
+			if ((retval = str_diff(ptr, domain)))
+			{
+				if (env_get("QREGEX"))
+				{
+					if ((retval = REGCOMP(qreg, ptr)) != 0)
+					{
+						regerror(retval, &qreg, errbuf, sizeof(errbuf));
+						regfree(&qreg);
+						report(111, "spawn-filter: ", ptr, ": ", errbuf, ". (#4.3.0)", 0);
+					}
+					retval = REGEXEC(qreg, domain);
+					regfree(&qreg);
+				} else
+					retval = !wildmat_internal(domain, ptr);
+			}
+			*p = ':';
+			if (!retval) /*- match occurred for domain or wildcard */
+			{
+				/* check for local/remote directives */
+				if (remotE)
+				{
+					if (!str_diffn(p + 1, "remote:", 7))
+						return (p + 8);
+					if (!str_diffn(p + 1, "local:", 6))
+					{
+						ptr = sa->s + len;
+						continue; /*- skip local directives for remote mails */
+					}
+				} else
+				{
+					if (!str_diffn(p + 1, "local:", 6))
+						return (p + 7);
+					if (!str_diffn(p + 1, "remote:", 7))
+					{
+						ptr = sa->s + len;
+						continue; /*- skip remote directives for remote mails */
+					}
+				}
+				return (p + 1);
+			}
+		}
+		ptr = sa->s + len;
+	}
+	return ((char *) 0);
+}
+
+int
+mkTempFile(int seekfd)
+{
+	char            inbuf[2048], outbuf[2048], strnum[FMT_ULONG];
+	char           *tmpdir;
+	static stralloc tmpFile = {0};
+	struct substdio _ssin;
+	struct substdio _ssout;
+	int             fd;
+
+	if (lseek(seekfd, 0, SEEK_SET) == 0)
+		return (0);
+	if (errno == EBADF)
+	{
+		strnum[fmt_ulong(strnum, seekfd)] = 0;
+		report(111, "spawn-filter: fd ", strnum, ": ", error_str(errno), ". (#4.3.0)", 0);
+	}
+	if (!(tmpdir = env_get("TMPDIR")))
+		tmpdir = "/tmp";
+	if (!stralloc_copys(&tmpFile, tmpdir))
+		report(111, "spawn-filter: out of mem: ", error_str(errno), ". (#4.3.0)", 0, 0, 0);
+	if (!stralloc_cats(&tmpFile, "/qmailFilterXXX"))
+		report(111, "spawn-filter: out of mem: ", error_str(errno), ". (#4.3.0)", 0, 0, 0);
+	if (!stralloc_catb(&tmpFile, strnum, fmt_ulong(strnum, (unsigned long) getpid())))
+		report(111, "spawn-filter: out of mem: ", error_str(errno), ". (#4.3.0)", 0, 0, 0);
+	if (!stralloc_0(&tmpFile))
+		report(111, "spawn-filter: out of mem: ", error_str(errno), ". (#4.3.0)", 0, 0, 0);
+	if ((fd = open(tmpFile.s, O_RDWR | O_EXCL | O_CREAT, 0600)) == -1)
+		report(111, "spawn-filter: ", tmpFile.s, ": ", error_str(errno), ". (#4.3.0)", 0);
+	unlink(tmpFile.s);
+	substdio_fdbuf(&_ssout, write, fd, outbuf, sizeof(outbuf));
+	substdio_fdbuf(&_ssin, read, seekfd, inbuf, sizeof(inbuf));
+	switch (substdio_copy(&_ssout, &_ssin))
+	{
+	case -2: /*- read error */
+		report(111, "spawn-filter: read error: ", error_str(errno), ". (#4.3.0)", 0, 0, 0);
+	case -3: /*- write error */
+		report(111, "spawn-filter: write error: ", error_str(errno), ". (#4.3.0)", 0, 0, 0);
+	}
+	if (substdio_flush(&_ssout) == -1)
+		report(111, "spawn-filter: write error: ", error_str(errno), ". (#4.3.0)", 0, 0, 0);
+	if (dup2(fd, seekfd) == -1)
+		report(111, "spawn-filter: dup2 error: ", error_str(errno), ". (#4.3.0)", 0, 0, 0);
+	if (lseek(seekfd, 0, SEEK_SET) != 0)
+		report(111, "spawn-filter: lseek: ", error_str(errno), ". (#4.3.0)", 0, 0, 0);
+	return (0);
+}
+
+int
+main(int argc, char **argv)
+{
+	char           *ptr, *mailprog, *domain, *errStr = 0, *size = "0", *qqeh, *ext;
+	char            sizebuf[FMT_ULONG];
+	struct stat     statbuf;
+	int             len;
+
+	len = str_len(argv[0]);
+	for (ptr = argv[0] + len;*ptr != '/' && ptr != argv[0];ptr--);
+	if (*ptr && *ptr == '/')
+		ptr++;
+	ptr += 6;
+	if (*ptr == 'l') /*- qmail-local Filter */
+	{
+		mailprog = "bin/qmail-local";
+		domain = argv[7];
+		ext = argv[6];
+		qqeh = argv[10];
+		remotE = 0;
+		if (!env_unset("QMAILREMOTE"))
+			report(111, "spawn-filter: out of mem: ", error_str(errno), ". (#4.3.0)", 0, 0, 0);
+		if (!fstat(0, &statbuf)) 
+		{
+			sizebuf[fmt_ulong(sizebuf, statbuf.st_size)] = 0;
+			size = sizebuf;
+		} else
+			size = "0";
+		/*- sender */
+		if (!stralloc_copys(&sender, argv[8]))
+			report(111, "spawn-filter: out of mem: ", error_str(errno), ". (#4.3.0)", 0, 0, 0);
+		if (!stralloc_0(&sender))
+			report(111, "spawn-filter: out of mem: ", error_str(errno), ". (#4.3.0)", 0, 0, 0);
+		if (!env_unset("QMAILREMOTE"))
+			report(111, "spawn-filter: out of mem: ", error_str(errno), ". (#4.3.0)", 0, 0, 0);
+		/*- recipient */
+		if (*ext) /*- EXT */
+		{
+			if (!stralloc_copys(&recipient, ext))
+				report(111, "spawn-filter: out of mem: ", error_str(errno), ". (#4.3.0)", 0, 0, 0);
+		} else /*- user */
+			if (!stralloc_copys(&recipient, argv[2]))
+				report(111, "spawn-filter: out of mem: ", error_str(errno), ". (#4.3.0)", 0, 0, 0);
+		if (!stralloc_cats(&recipient, "@"))
+			report(111, "spawn-filter: out of mem: ", error_str(errno), ". (#4.3.0)", 0, 0, 0);
+		if (!stralloc_cats(&recipient, domain))
+			report(111, "spawn-filter: out of mem: ", error_str(errno), ". (#4.3.0)", 0, 0, 0);
+		if (!stralloc_0(&recipient))
+			report(111, "spawn-filter: out of mem: ", error_str(errno), ". (#4.3.0)", 0, 0, 0);
+	} else
+	if (*ptr == 'r') /*- qmail-remote Filter */
+	{
+		mailprog = "bin/qmail-remote";
+		domain = argv[1];
+		ext = argv[5];
+		qqeh = argv[3];
+		size = argv[4];
+		remotE = 1;
+		if (!env_unset("QMAILLOCAL"))
+			report(111, "spawn-filter: out of mem: ", error_str(errno), ". (#4.3.0)", 0, 0, 0);
+		/*- sender */
+		if (!stralloc_copys(&sender, argv[2]))
+			report(111, "spawn-filter: out of mem: ", error_str(errno), ". (#4.3.0)", 0, 0, 0);
+		if (!stralloc_0(&sender))
+			report(111, "spawn-filter: out of mem: ", error_str(errno), ". (#4.3.0)", 0, 0, 0);
+		/*- recipient */
+		if (!stralloc_copys(&recipient, argv[5]))
+			report(111, "spawn-filter: out of mem: ", error_str(errno), ". (#4.3.0)", 0, 0, 0);
+		if (!stralloc_0(&recipient))
+			report(111, "spawn-filter: out of mem: ", error_str(errno), ". (#4.3.0)", 0, 0, 0);
+	} else
+	{
+		report(111, "spawn-filter: Incorrect usage. ", argv[0], " (#4.3.0)", 0, 0, 0);
+		_exit(111);
+	}
+	if (chdir(auto_qmail) == -1)
+		report(111, "spawn-filter: Unable to switch to ", auto_qmail, ": ", error_str(errno), ". (#4.3.0)", 0);
+	/*- DATABYTES Check */
+	if (check_size(size))
+		report(100, "sorry, that message size exceeds my databytes limit (#5.3.4)", 0, 0, 0, 0, 0);
+	run_mailfilter(domain, mailprog, argv);
+	report(111, "spawn-filter: could not exec ", mailprog, ": ", error_str(errno), ". (#4.3.0)", 0);
+	/*- Not reached */
+	return(0);
+}
+
+void
+getversion_qmail_spawn_filter_c()
+{
+	static char    *x = "$Id: spawn-filter.c,v 1.41 2009-04-03 11:42:48+05:30 Cprogrammer Stab mbhangui $";
+
+	x++;
+}
diff -Naur netqmail-1.06.org/str_cpyb.c netqmail-1.06/str_cpyb.c
--- netqmail-1.06.org/str_cpyb.c	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/str_cpyb.c	2018-04-03 17:28:43.675318780 +0530
@@ -0,0 +1,53 @@
+/*
+ * $Log: str_cpyb.c,v $
+ * Revision 1.2  2004-10-22 20:30:54+05:30  Cprogrammer
+ * added RCS id
+ *
+ * Revision 1.1  2004-08-15 19:52:35+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
+#include "str.h"
+
+unsigned int
+str_copyb(s, t, max)
+	register char  *s;
+	register char  *t;
+	unsigned int    max;
+{
+	register int    len;
+
+	len = 0;
+	while (max-- > 0)
+	{
+		if (!(*s = *t))
+			return len;
+		++s;
+		++t;
+		++len;
+		if (!(*s = *t))
+			return len;
+		++s;
+		++t;
+		++len;
+		if (!(*s = *t))
+			return len;
+		++s;
+		++t;
+		++len;
+		if (!(*s = *t))
+			return len;
+		++s;
+		++t;
+		++len;
+	}
+	return len;
+}
+
+void
+getversion_str_cpyb_c()
+{
+	static char    *x = "$Id: str_cpyb.c,v 1.2 2004-10-22 20:30:54+05:30 Cprogrammer Stab mbhangui $";
+
+	x++;
+}
diff -Naur netqmail-1.06.org/str_cspn.c netqmail-1.06/str_cspn.c
--- netqmail-1.06.org/str_cspn.c	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/str_cspn.c	2018-04-03 17:28:43.675318780 +0530
@@ -0,0 +1,40 @@
+/*
+ * $Log: str_cspn.c,v $
+ * Revision 1.1  2011-07-12 20:42:00+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
+#include "str.h"
+/*
+ * Span the complement of string s2.
+ */
+size_t
+str_cspn(s1, s2)
+	const char *s1;
+	register const char *s2;
+{
+	register const char *p, *spanp;
+	register char c, sc;
+
+	/*
+	 * Stop as soon as we find any character from s2.  Note that there
+	 * must be a NUL in s2; it suffices to stop when we find that, too.
+	 */
+	for (p = s1;;) {
+		c = *p++;
+		spanp = s2;
+		do {
+			if ((sc = *spanp++) == c)
+				return (p - 1 - s1);
+		} while (sc != 0);
+	}
+	/* NOTREACHED */
+}
+
+void
+getversion_str_cspn_c()
+{
+	static char    *x = "$Id: str_cspn.c,v 1.1 2011-07-12 20:42:00+05:30 Cprogrammer Exp mbhangui $";
+
+	x++;
+}
diff -Naur netqmail-1.06.org/str.h netqmail-1.06/str.h
--- netqmail-1.06.org/str.h	1998-06-15 16:23:16.000000000 +0530
+++ netqmail-1.06/str.h	2018-04-03 17:28:43.676318800 +0530
@@ -8,6 +8,8 @@
 extern unsigned int str_chr();
 extern unsigned int str_rchr();
 extern int str_start();
+#include <sys/types.h>
+extern size_t str_cspn();
 
 #define str_equal(s,t) (!str_diff((s),(t)))
 
diff -Naur netqmail-1.06.org/surblfilter.9 netqmail-1.06/surblfilter.9
--- netqmail-1.06.org/surblfilter.9	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/surblfilter.9	2018-04-03 17:28:43.676318800 +0530
@@ -0,0 +1,80 @@
+.TH surblfilter 8
+.SH NAME
+surblfilter \- qmail SURBL blocklist interface
+.SH SYNOPSIS
+.B surblfilter
+[
+.B \-v
+]
+[
+.B \-c
+]
+[
+.B \-t
+]
+.SH DESCRIPTION
+\fBSURBL\fRs are lists of web sites that have appeared in unsolicited messages. Unlike most lists,
+SURBLs are not lists of message senders.
+
+Web sites seen in unsolicited messages tend to be more stable than the rapidly changing botnet
+IP addresses used to send the vast majority of them. Sender lists like zen.spamhaus.org can be
+used in a first stage filter to help identify 80% to 90% of unsolicited messages. SURBLs can
+help find about 75% of the otherwise difficult, remaining unsolicited messages in a second
+stage filter. Used together with sender lists, SURBLs have proven to be a highly-effective way
+to detect 95% of unsolicited messages.
+
+\fBsurblfilter\fR reads an rfc822 email on stdin, extracts URL and checks them against SURBL.
+\fBsurblfilter\fR can be used as a filter using \fBqmail-qfilter(1)\fR. It can also be used
+as a qmail-queue(8) frontend by setting QMAILQUEUE environment variable to a wrapper
+QMAILHOME/bin/surblqueue. You can define \fBSURBLQUEUE\fR environment variable to make
+\fBsurblqueue\fR execute something other than \fBqmail-queue\fR(8).
+
+\fBsurblfilter\fR uses \fBQMAILRCPTS\fR environment variable to get the recipient list. You can
+whitelist recipients by having the email addresses in \fIsurblrcpt\fR control file. You can
+change the name of this control file by setting \fBSURBLRCPT\fR environment variable.
+.PP
+\fBsurblfilter\fR uses the control file \fIsurbldomainwhite\fR to whitelist a domain.
+
+.PP
+The default SURBL list that is used is \fBmulti.surbl.org\fR. You can use a different list
+by setting the \fIsurbldomain\fR control file.
+
+.PP
+\fBsurblfilter\fR caches results in QMAILHOME/control/cache. The filename represents the domain.
+If a file as permission 0600, it means that the domain was blacklisted. The entries are
+cached for a default of 300 seconds. You can change this by setting \fIcachelifetime\fR
+control file. This directory should be owned by the uid set for running qmail-smtpd(8).
+
+\fBsurblfilter\fR removes all leading host names, subdomains, www., randomized subdomains, etc. In
+order to determine the level of domain check, it uses the control files \fBlevel3-tlds\fR and
+\fBlevel2-tlds\fR. For any domain found in \fBlevel3-tlds\fR, it checks the domain at level4. For any
+domain found in \fBlevel2-tlds\fR, it checks the domain at level3. For all domains not found in
+these two control files, it checks the domain at level2. Please look at http://www.surbl.org/guidelines
+
+for more details.
+
+.SH OPTIONS
+.PP
+.TP
+\fB-v\fR
+Use debug mode
+
+.TP
+\fB-c\fR
+Do not cache results
+
+.TP
+\fB-t\fR
+Do dns text query to get the reason. This option will slow \fBsurblfilter\fR. Remember that
+last octet of the IP address obtained for the domain gives you the reason for the block
+
+.SH RETURN VALUE
+\fBsurbfilter\fR returns 88 if the domain is blocked and prints the reason on standard error.
+This allows for qmail-smtpd(8) to print a permanent error during a SMTP session.
+It returns 111 for all temporary errors. It returns 0 if the message does not contain any
+domain blocked by SURBL
+
+.SH "SEE ALSO"
+qmail-smtpd(8),
+qmail-queue(8),
+qmail-qfilter(1)
diff -Naur netqmail-1.06.org/surblfilter.c netqmail-1.06/surblfilter.c
--- netqmail-1.06.org/surblfilter.c	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/surblfilter.c	2018-04-03 17:28:43.677318820 +0530
@@ -0,0 +1,881 @@
+/*
+ * $Log: surblfilter.c,v $
+ * Revision 1.3  2011-07-13 22:11:13+05:30  Cprogrammer
+ * skip surblrcpt if QMAILRCPTS is not defined
+ *
+ * Revision 1.2  2011-07-13 22:02:13+05:30  Cprogrammer
+ * added surblrcpt functionality
+ *
+ * Revision 1.1  2011-07-13 20:56:34+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
+#include <unistd.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <ctype.h>
+#include <time.h>
+#include <sys/stat.h>
+
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#ifdef DARWIN
+#include <nameser8_compat.h>
+#endif
+#include <arpa/nameser.h>
+#include <resolv.h>
+#include <netdb.h>
+
+#include "alloc.h"
+#include "sgetopt.h"
+#include "error.h"
+#include "scan.h"
+#include "str.h"
+#include "case.h"
+#include "constmap.h"
+#include "auto_qmail.h"
+#include "stralloc.h"
+#include "env.h"
+#include "control.h"
+#include "strerr.h"
+#include "substdio.h"
+#include "getln.h"
+#include "byte.h"
+#include "dns.h"
+#include "ip.h"
+#include "ipalloc.h"
+#include "mess822.h"
+#include "base64.h"
+
+#define FATAL "surblfilter: fatal: "
+
+char           *dns_text(char *);
+
+stralloc        line = { 0 };
+int             debug = 0, do_text = 0, do_cache = 1;
+static int      cachelifetime = 300;
+stralloc        whitelist = { 0 };
+stralloc        surbldomain = { 0 };
+
+/*- SURBL: RCPT whitelist. */
+stralloc        srw = { 0 };
+int             srwok = 0;
+struct constmap mapsrw;
+
+/*- 2 level tld */
+stralloc        l2 = { 0 };
+int             l2ok = 0;
+struct constmap mapl2;
+/*- 3 level tld */
+stralloc        l3 = { 0 };
+int             l3ok = 0;
+struct constmap mapl3;
+
+static char     ssinbuf[1024];
+static substdio ssin = SUBSTDIO_FDBUF(read, 0, ssinbuf, sizeof ssinbuf);
+static char     ssoutbuf[512];
+static substdio ssout = SUBSTDIO_FDBUF(write, 1, ssoutbuf, sizeof ssoutbuf);
+static char     sserrbuf[512];
+static substdio sserr = SUBSTDIO_FDBUF(write, 2, sserrbuf, sizeof(sserrbuf));
+
+void
+out(char *str)
+{
+	if (!str || !*str)
+		return;
+	if (substdio_puts(&ssout, str) == -1)
+		strerr_die2sys(111, FATAL, "write: ");
+	return;
+}
+
+void
+print_debug(char *arg1, char *arg2, char *arg3)
+{
+	if (!debug)
+		return;
+	if (arg1 && substdio_puts(&sserr, arg1) == -1)
+		_exit(1);
+	if (arg2 && substdio_puts(&sserr, arg2) == -1)
+		_exit(1);
+	if (arg3 && substdio_puts(&sserr, arg3) == -1)
+		_exit(1);
+	if ((arg1 || arg2 || arg3) && substdio_puts(&sserr, "\n"))
+		_exit(1);
+	if (substdio_flush(&sserr) == -1)
+		_exit(1);
+}
+
+void
+die_write()
+{
+	strerr_die2sys(111, FATAL, "write: ");
+	return;
+}
+
+void
+flush()
+{
+	if (substdio_flush(&ssout) == -1)
+		strerr_die2sys(111, FATAL, "write: ");
+	return;
+}
+
+void
+logerr(char *s)
+{
+	if (substdio_puts(&sserr, s) == -1)
+		_exit(1);
+}
+
+void
+logerrf(char *s)
+{
+	if (substdio_puts(&sserr, s) == -1)
+		_exit(1);
+	if (substdio_flush(&sserr) == -1)
+		_exit(1);
+}
+
+void
+my_error(char *s1, char *s2, int exit_val)
+{
+	logerr(s1);
+	if (s2) {
+		logerr(": ");
+		logerr(s2);
+	}
+	if (exit_val > 0) {
+		logerr(": ");
+		logerr(error_str(errno));
+	}
+	logerrf("\n");
+	_exit(exit_val > 0 ? exit_val : 0 - exit_val);
+}
+
+void
+die_nomem()
+{
+	substdio_flush(&ssout);
+	substdio_puts(&sserr, "surblfilter: out of memory\n");
+	substdio_flush(&sserr);
+	_exit(1);
+}
+
+void
+die_soft()
+{
+	substdio_flush(&ssout);
+	substdio_puts(&sserr, "surblfilter: DNS temporary failure\n");
+	substdio_flush(&sserr);
+	_exit(1);
+}
+
+void
+die_hard()
+{
+	substdio_flush(&ssout);
+	substdio_puts(&sserr, "surblfilter: DNS permanent failure\n");
+	substdio_flush(&sserr);
+	_exit(1);
+}
+
+void
+die_control()
+{
+	substdio_flush(&ssout);
+	substdio_puts(&sserr, "surblfilter: unable to read controls\n");
+	substdio_flush(&sserr);
+	_exit(1);
+}
+
+static unsigned short
+getshort(unsigned char *cp)
+{
+	return (cp[0] << 8) | cp[1];
+}
+
+static char *
+strdup(const char *str)
+{
+	size_t siz;
+	char *copy;
+
+	siz = str_len((char *) str) + 1;
+	if (!(copy = alloc(siz)))
+		return((char *) 0);
+	byte_copy(copy, siz, (char *) str);
+	return(copy);
+}
+
+/*
+ * we always return a null-terminated string which has been malloc'ed.  The string
+ * is always in the tag=value form.  If a temporary or permanent error occurs,
+ * the string will be exactly "e=perm;" or "e=temp;".
+ * Note that it never returns NULL.
+ */
+char           *
+dns_text(char *dn)
+{
+	u_char          response[PACKETSZ + PACKETSZ + 1];	/* response */
+	int             responselen;			/* buffer length */
+	int             rc;						/* misc variables */
+	int             ancount, qdcount;		/* answer count and query count */
+	u_short         type, rdlength;			/* fields of records returned */
+	u_char         *eom, *cp;
+	u_char          buf[PACKETSZ + PACKETSZ + 1];		/* we're storing a TXT record here, not just a DNAME */
+	u_char         *bufptr;
+
+	for (rc = 0, responselen = PACKETSZ;rc < 2;rc++) {
+		if ((responselen = res_query(dn, C_IN, T_TXT, response, responselen)) < 0) {
+			if (h_errno == TRY_AGAIN)
+				return strdup("e=temp;");
+			else
+				return strdup("e=perm;");
+		}
+		if (responselen <= PACKETSZ)
+			break;
+		else
+		if (responselen >= (2 * PACKETSZ))
+			return strdup("e=perm;");
+	}
+	qdcount = getshort(response + 4);	/* http://crynwr.com/rfc1035/rfc1035.html#4.1.1. */
+	ancount = getshort(response + 6);
+	eom = response + responselen;
+	cp = response + HFIXEDSZ;
+	while (qdcount-- > 0 && cp < eom) {
+		rc = dn_expand(response, eom, cp, (char *) buf, MAXDNAME);
+		if (rc < 0)
+			return strdup("e=perm;");
+		cp += rc + QFIXEDSZ;
+	}
+	while (ancount-- > 0 && cp < eom) {
+		if ((rc = dn_expand(response, eom, cp, (char *) buf, MAXDNAME)) < 0)
+			return strdup("e=perm;");
+		cp += rc;
+		if (cp + RRFIXEDSZ >= eom)
+			return strdup("e=perm;");
+		type = getshort(cp + 0);	/* http://crynwr.com/rfc1035/rfc1035.html#4.1.3. */
+		rdlength = getshort(cp + 8);
+		cp += RRFIXEDSZ;
+		if (type != T_TXT) {
+			cp += rdlength;
+			continue;
+		}
+		bufptr = buf;
+		while (rdlength && cp < eom) {
+			unsigned int    cnt;
+
+			cnt = *cp++;		/* http://crynwr.com/rfc1035/rfc1035.html#3.3.14. */
+			if (bufptr - buf + cnt + 1 >= (2 * PACKETSZ))
+				return strdup("e=perm;");
+			if (cp + cnt > eom)
+				return strdup("e=perm;");
+			byte_copy((char *) bufptr, cnt, (char *) cp);
+			rdlength -= cnt + 1;
+			bufptr += cnt;
+			cp += cnt;
+			*bufptr = '\0';
+		}
+		return (char *) strdup((char *) buf);
+	}
+	return strdup("e=perm;");
+}
+
+static char    *
+uri_decode(char *str, size_t str_len, char **strend)
+{
+	size_t          i = 0, j = 0, found;
+	int             pasthostname = 0;
+	char           *str_bits = "\r\n\t \'\"<>()";
+
+	for (i = 0; i < str_len; i++, j++) {
+		if (str[i] == '%' || (!pasthostname && str[i] == '=')) {
+			if (i + 2 < str_len) {
+				if (isxdigit(str[i + 1]) && isxdigit(str[i + 2])) {
+					int             c1 = str[i + 1];
+					int             c2 = str[i + 2];
+					int             num = (	/* first character */
+											  ((c1 & 0xF)	/* take right half */
+											   +(9 * (c1 >> 6)))	/* add 9 if character is a-f or A-F */
+											  <<4	/* pack into the left half of the byte */
+						) | (	/* second character */
+								(c2 & 0xF)
+								+ (9 * (c2 >> 6))
+						);		/* leave it as the left half */
+					str[j] = tolower(num);
+					i += 2;
+					continue;
+				}
+			}
+		}
+		if (!pasthostname && (str[i] == '?' || str[i] == '/' || str[i] == '\\'))
+			pasthostname = 1;
+		if (i + 1 < str_len) {
+			if (str[i] == '=' && str[i + 1] == '\n') {
+				j -= 1;
+				i += 1;
+				continue;
+			}
+		}
+		if (i + 2 < str_len) {
+			if (str[i] == '=' && str[i + 1] == '\r' && str[i + 2] == '\n') {
+				j -= 1;
+				i += 2;
+				continue;
+			}
+		}
+		found = str_chr(str_bits, str[i]);
+		if (str_bits[found])
+			break;
+		str[j] = tolower(str[i]);
+	}
+	str[j] = '\0';
+	*strend = str + j + 1;
+	return str;
+}
+
+/*
+ * Returns:
+ * -1 on error
+ *  0 if domain wasn't cached
+ *  1 if domain was cached, and not blacklisted
+ *  2 if domain was cached, and blacklisted.
+ *
+ * text != NULL: host blacklisted, text == reason.
+ */
+static int
+cachefunc(char *uri, size_t urilen, char **text, int flag)
+{
+	static char     inbuf[2048];
+	static stralloc cachefile = { 0 }, reason = { 0 };
+	int             fd, i, n, textlen, match;
+	struct stat     st;
+	substdio        ss;
+
+	if (!do_cache)
+		return (0);
+	if (uri[i = str_chr(uri, '/')]) {
+		errno = EINVAL;
+		return (-1);
+	}
+	if (!stralloc_copys(&cachefile, "control/cache", 13))
+		die_nomem();
+	if (!stralloc_0(&cachefile))
+		die_nomem();
+	if (access(cachefile.s, F_OK))
+		return (0);
+	cachefile.len--;
+	if (!stralloc_append(&cachefile, "/"))
+		die_nomem();
+	if (!stralloc_cats(&cachefile, uri))
+		die_nomem();
+	if (!stralloc_0(&cachefile))
+		die_nomem();
+	if (flag) { /*- add the cache */
+		if (!access(cachefile.s, F_OK))
+			return (0);
+		if ((fd = open(cachefile.s, O_CREAT|O_WRONLY, *text ? 0600 : 0644)) == -1)
+			my_error(cachefile.s, 0, 2);
+		if (*text) {
+			textlen = str_len(*text);
+			if ((n = write(fd, *text, textlen)) == -1) {
+				close(fd);
+				my_error("write", 0, 1);
+			}
+		}
+		if (close(fd))
+			my_error(cachefile.s, 0, 1);
+	} else {
+		if (stat(cachefile.s, &st) == -1) {
+			if (errno == ENOENT)
+				return (0);
+			my_error("stat", 0, 1);
+			return -1;
+		}
+		if (time(0) > st.st_mtime + cachelifetime) {
+			if (unlink(cachefile.s)) {
+				my_error("unlink", 0, 1);
+				return -1;
+			}
+			return (0);
+		}
+		if ((fd = open(cachefile.s, O_RDONLY)) == -1)
+			my_error(cachefile.s, 0, 2);
+		substdio_fdbuf(&ss, read, fd, inbuf, sizeof(inbuf));
+		if (getln(&ss, &reason, &match, '\n') == -1) {
+			close(fd);
+			return -1;
+		}
+		*text = reason.s;
+		close(fd);
+		return (((st.st_mode & 07777) == 0600) ? 2 : 1);
+	}
+	return (0);
+}
+
+static int
+getdnsip(stralloc *ip, stralloc *domain, int *code)
+{
+	char            x[IPFMT];
+	ipalloc         ia = { 0 };
+	int             len;
+
+	if (!stralloc_copys(ip, ""))
+		die_nomem();
+	switch(dns_ip(&ia, domain))
+	{
+	case DNS_MEM:
+		die_nomem();
+	case DNS_SOFT:
+		die_soft();
+	case DNS_HARD:
+		return 0;
+	case 1:
+		if (ia.len <= 0)
+			die_soft();
+	}
+	if (code)
+		*code = *(&ia.ix->ip.d[3]);
+	len = ip_fmt(x, &ia.ix->ip);
+	if (!stralloc_copyb(ip, x, len))
+		die_nomem();
+	return 0;
+}
+
+/*- SURBL: Check surbl rcpt whitelist.  */
+int
+srwcheck(char *arg, int len)
+{
+	int             j;
+
+	if (!srwok)
+		return 0;
+	if (constmap(&mapsrw, arg, len))
+		return 1;
+	if ((j = byte_rchr(arg, len, '@')) < (len - 1)) {
+		if (constmap(&mapsrw, arg + j, len - j))
+			return 1;
+	}
+	return 0;
+}
+
+int
+l2check(char *arg, int len)
+{
+	if (!l2ok)
+		return (0);
+	if (constmap(&mapl2, arg, len))
+		return 1;
+	return (0);
+}
+
+int
+l3check(char *arg, int len)
+{
+	if (!l3ok)
+		return (0);
+	if (constmap(&mapl3, arg, len))
+		return 1;
+	return (0);
+}
+
+/*
+ * Returns -1 on error.
+ * Returns 0 if host does not exist.
+ * Returns 1 if host exists.
+ */
+static int
+checkwhitelist(char *hostname, int hostlen)
+{
+	int             len;
+	char           *ptr;
+
+	for (ptr = whitelist.s, len = 0;len < whitelist.len;) {
+		if (!str_diffn(hostname, ptr, hostlen))
+			return (1);
+		len += (str_len(ptr) + 1);
+		ptr = whitelist.s + len;
+	}
+	return (0);
+}
+
+static int
+getreason(int code, char **text)
+{
+	static stralloc reason = { 0 };
+
+	if (!stralloc_copyb(&reason, "blacklisted by ", 15))
+		die_nomem();
+	if (code & 64 && !stralloc_cats(&reason, debug ? "prolocation/jwspamspy" : "[jp]"))
+		die_nomem();
+	if (code & 32 && !stralloc_cats(&reason, debug ? "abusebutler " : "[ab]"))
+		die_nomem();
+	if (code & 16 && !stralloc_cats(&reason, debug ? "outblaze " : "[ob]"))
+		die_nomem();
+	if (code & 8 && !stralloc_cats(&reason, debug ? "phising " : "[ph]"))
+		die_nomem();
+	if (code & 2 && !stralloc_cats(&reason, debug ? "spamcop " : "[sc]"))
+		die_nomem();
+	if (code & 4 && !stralloc_cats(&reason, debug ? "w.stearns " : "[ws]"))
+		die_nomem();
+	if (!stralloc_0(&reason))
+		die_nomem();
+	*text = reason.s;
+	return (code >= 2);
+}
+
+static int
+checksurbl(char *uri, int urilen, char *surbldomain, char **text)
+{
+	static stralloc ip = { 0 };
+	static stralloc host = { 0 };
+	int             i, code = 0;
+
+	if ((i = checkwhitelist(uri, urilen)) == -1)
+		return -1;
+	else
+	if (i)
+		return (0);
+	if (stralloc_copys(&host, uri) == 0)
+		die_nomem();
+	if (stralloc_append(&host, ".") == 0)
+		die_nomem();
+	if (stralloc_cats(&host, surbldomain) == 0)
+		die_nomem();
+	if (!stralloc_0(&host))
+		die_nomem();
+	if (getdnsip(&ip, &host, &code) == -1)
+		return -1;
+	if (do_text && ip.len > 0) {
+		if (text) {
+			if ((*text = dns_text(host.s)))
+				return 2;
+		}
+		return 1;
+	}
+	if (code > 1)
+		return (getreason(code, text) ? 2 : 0);
+	return 0;
+}
+
+static int
+num_domains(const char *s)
+{
+	int             r = *s ? 1 : 0;
+
+	while (*s) {
+		if (*s++ == '.')
+			++r;
+	}
+	return r;
+}
+
+static char *
+remove_subdomains(char *orig, int output_domains)
+{
+	char           *s = orig + str_len((char *) orig);
+	int             dots = 0;
+
+	while (s > orig) {
+		if (*s == '.')
+			++dots;
+		if (dots == output_domains) {
+			++s;
+			break;
+		}
+		--s;
+	}
+	return s;
+}
+
+/*
+ * Returns 0 if URI was erronous.
+ *         1 if URI was not blacklisted.
+ *         2 if URI was blacklisted.
+ */
+static int
+checkuri(char **ouri, char **text, size_t textlen)
+{
+	char           *uri = *ouri, *uriend, *ptr;
+	char            ipuri[IPFMT];
+	size_t          urilen = 0;
+	ip_addr         ip;
+	int             cached, blacklisted, i, level;
+
+	if (case_diffb(uri, 4, "http"))
+		return 0;
+	uri += 4;
+
+	/*- Check and skip http[s]?:[/\\][/\\]?  */
+	if (*uri == 's')
+		uri++;
+	if (*uri == ':' && (uri[1] == '/' || uri[1] == '\\'))
+		uri += 2;
+	else 
+		return 0;
+	if (*uri == '/' || *uri == '\\')
+		uri++;
+	if (!isalpha(*uri) && !isdigit(*uri))
+		return 0;
+	uri_decode(uri, textlen, &uriend);
+	*ouri = uriend;
+	print_debug("Full    URI: ", uri, 0);
+	uri[(urilen = str_cspn(uri, "/\\?"))] = '\0';
+	if (uri[i = str_chr(uri, '@')])
+		uri += (i + 1);
+	uri[i = str_chr(uri, ':')] = 0;
+	if (ip_scan(uri, &ip)) {
+		ip_fmt(ipuri, &ip);
+		uri = ipuri;
+		print_debug("Proper IP: ", uri, 0);
+	} else {
+		urilen = str_len(uri);
+		print_debug("Full domain: ", uri, 0);
+		level = num_domains(uri);
+		if (level > 2) {
+			ptr = remove_subdomains(uri, 3);
+			if (l3check(ptr, str_len(ptr)))
+				uri = remove_subdomains(uri, 4);
+			else {
+				ptr = remove_subdomains(uri, 2);
+				if (l2check(ptr, str_len(ptr)))
+					uri = remove_subdomains(uri, 3);
+				else
+					uri = remove_subdomains(uri, 2);
+			}
+		} else
+		if (level > 1) {
+			ptr = remove_subdomains(uri, 2);
+			if (l2check(ptr, str_len(ptr)))
+				uri = remove_subdomains(uri, 3);
+			else
+				uri = remove_subdomains(uri, 2);
+		}
+		print_debug("       Part: ", uri, 0);
+	}
+	urilen = str_len(uri);
+	cached = 1;
+	blacklisted = 0;
+	switch (cachefunc(uri, urilen, text, 0))
+	{
+	case 0:
+		cached = 0;
+		break;
+	case 1:
+		blacklisted = 0;
+		break;
+	case 2:
+		blacklisted = 1;
+		break;
+	}
+	if (cached == 0) {
+		switch (checksurbl(uri, urilen, surbldomain.s, text))
+		{
+		case -1:
+			return -1;
+		case 0:
+			blacklisted = 0;
+			*text = (char *) 0;
+			print_debug(uri, ": not blacklisted", 0);
+			break;
+		case 1:
+			*text = "No reason given";
+			blacklisted = 1;
+			print_debug(uri, ": blacklisted. reason - ", *text);
+			break;
+		case 2:
+			blacklisted = 2;
+			print_debug(uri, ": blacklisted. reason - ", *text);
+			break;
+		}
+		cachefunc(uri, urilen, text, 1);
+	}
+	return (blacklisted);
+}
+
+#define DEF_SURBL_DOMAIN "multi.surbl.org"
+
+static int      do_surbl = 1;
+
+static void
+setup()
+{
+	char           *x, *y, *rcpt;
+	int             i;
+
+	if ((rcpt = env_get("QMAILRCPTS"))) {
+		if ((srwok = control_readfile(&srw, "control/surblrcpt", 0)) == -1)
+			die_control();
+		if (srwok && !constmap_init(&mapsrw, srw.s, srw.len, 0))
+			die_nomem();
+	}
+	for (x = y = rcpt, i = 0;rcpt && *x;x++, i++) {
+		if (*x == '\n') {
+			*x = 0;
+			if (srwcheck(y, i)) {
+				do_surbl = 0;
+				return;
+			}
+			y = x + 1;
+			*x = '\n';
+			i = 0;
+		}
+	}
+	if ((l2ok = control_readfile(&l2, "control/level2-tlds", 0)) == -1)
+		die_control();
+	if (l2ok && !constmap_init(&mapl2, l2.s, l2.len, 0))
+		die_nomem();
+	if ((l3ok = control_readfile(&l3, "control/level3-tlds", 0)) == -1)
+		die_control();
+	if (l3ok && !constmap_init(&mapl3, l3.s, l3.len, 0))
+		die_nomem();
+	switch (control_readline(&surbldomain, "control/surbldomain"))
+	{
+	case -1:
+		die_control();
+	case 0:
+		if (!stralloc_copys(&surbldomain, DEF_SURBL_DOMAIN))
+			die_nomem();
+		/*- flow through */
+	case 1:
+		if (!stralloc_0(&surbldomain))
+			die_nomem();
+	}
+	if ((x = env_get("CACHELIFETIME")))
+		scan_int(x, &cachelifetime);
+	else
+	if (control_readint(&cachelifetime, "control/cachelifetime") == -1)
+		die_control();
+	if (control_readfile(&whitelist, "control/surbldomainwhite", 0) == -1)
+		die_control();
+	return;
+}
+
+int
+main(int argc, char **argv)
+{
+	stralloc        base64out = { 0 }, boundary = { 0 };
+	stralloc       *ptr;
+	char           *x, *reason = 0;
+	int             opt, in_header = 1, i, total_bl = 0, blacklisted, match, html_plain_text,
+					base64_decode, found_content_type = 0;
+
+	if (!(x = env_get("SURBL")))
+		do_surbl = 0;
+	while ((opt = getopt(argc, argv, "vtc")) != opteof) {
+		switch (opt) {
+		case 'c':
+			do_cache = 0;
+			break;
+		case 'v':
+			debug = 1;
+			break;
+		case 't':
+			do_text = 1;
+			break;
+		}
+	}
+	if (chdir(auto_qmail) == -1)
+		die_control();
+	if (do_surbl)
+		setup();
+	for (html_plain_text = base64_decode = 0;;) {
+		if (getln(&ssin, &line, &match, '\n') == -1)
+			my_error("getln: ", 0, 1);
+		if (!match && line.len == 0)
+			break;
+		if (substdio_put(&ssout, line.s, line.len))
+			die_write();
+		if (!do_surbl)
+			continue;
+		if (in_header) {
+			if (!str_diffn(line.s, "Content-Type: ", 14)) {
+				found_content_type = 1;
+			}
+			if (found_content_type) {
+				for (i = 0;i < line.len; i++) {
+					if (case_startb(line.s + i, line.len - i, "boundary=")) {
+						if (line.s[i + 9] == '\"' && line.s[line.len -2] == '\"')
+						{
+							if (!stralloc_copyb(&boundary, line.s + i + 10, line.len -i - 12))
+								die_nomem();
+						} else
+						if (!stralloc_copyb(&boundary, line.s + i + 9, line.len - i - 10))
+							die_nomem();
+						if (!stralloc_0(&boundary))
+							die_nomem();
+						boundary.len--;
+					}
+				}
+			}
+			if (!mess822_ok(&line))
+				in_header = 0;
+		} else {
+			if (!str_diffn(line.s, "Content-Type: ", 14)) {
+				if (!str_diffn(line.s + 14, "message/rfc822", 14) ||
+					!str_diffn(line.s + 14, "text/html", 9) ||
+					!str_diffn(line.s + 14, "text/plain", 10))
+						html_plain_text = 1;
+				else
+						html_plain_text = 0;
+			}
+			if (html_plain_text && !str_diffn(line.s, "Content-Transfer-Encoding: ", 27)) {
+				if (!str_diffn(line.s + 27, "base64", 6))
+					base64_decode = 1;
+				else
+					base64_decode = 0;
+			}
+			if (line.len == 1)
+				continue;
+			if (base64_decode) {
+				if (!str_diffn(line.s, "Content-", 8))
+					continue;
+				if (!str_diffn(line.s + 2, boundary.s, boundary.len)) {
+					base64_decode = 0;
+					continue;
+				}
+				if (b64decode((const unsigned char *) line.s, line.len - 1, &base64out) == -1)
+					die_nomem();
+				ptr = &base64out;
+			} else
+				ptr = &line;
+			for (blacklisted = -1, i = 0;i < ptr->len; i++) {
+				if (case_startb(line.s + i, ptr->len - i, "http:")) {
+					x = ptr->s + i;
+					switch (checkuri(&x, &reason, ptr->len - i))
+					{
+					case -1:
+						my_error("checkuri", 0, 111);
+					case 0: /*- no valid uri in line */
+						blacklisted = 0;
+						break;
+					case 1:
+					case 2:
+						blacklisted = 1;
+						break;
+					}
+				}
+				if (blacklisted == 1) {
+					total_bl++;
+					break;
+				}
+			}
+		}
+	} /*- for (html_plain_text = base64_decode = 0;;) { */
+	if (substdio_flush(&ssout) == -1)
+		die_write();
+	if (do_surbl && total_bl) {
+		logerrf("Dmessage contains an URL listed in SURBL blocklist");
+		_exit (88); /*- custom error */
+	}
+	return (0);
+}
+
+void
+getversion_surblfilter_c()
+{
+	static char    *x = "$Id: surblfilter.c,v 1.4 2011-07-13 22:28:32+05:30 Cprogrammer Exp mbhangui $";
+
+	x++;
+}
diff -Naur netqmail-1.06.org/surblqueue.sh netqmail-1.06/surblqueue.sh
--- netqmail-1.06.org/surblqueue.sh	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/surblqueue.sh	2018-04-03 17:28:43.677318820 +0530
@@ -0,0 +1,32 @@
+# I should be called by qmail-smtpd or anything that calls qmail-queue
+#
+if [ -f /bin/mktemp ] ; then
+	MKTEMP=/bin/mktemp
+elif [ -f /usr/bin/mktemp ] ; then
+	MKTEMP=/usr/bin/mktemp
+else
+	MKTEMP=mktemp
+fi
+out=`$MKTEMP -t surblXXXXXXXXXX`
+if [ $? -ne 0 ] ; then
+	echo "mktemp: unable to create temp files" 1>&2
+	exit 111
+fi
+#
+# Redirect standard error to 4 so that qmail_open() will pick up the error
+#
+QMAIL/bin/surblfilter > $out 2>&4
+status=$?
+if [ $status -eq 0 ] ; then
+	exec 0<$out
+	/bin/rm -f $out
+	# use SURBLQUEUE to execute queue program (thanks Roberto Puzzanghera)
+	if [ "$SURBLQUEUE" != "" -a -x "$SURBLQUEUE" ]; then
+		exec $SURBLQUEUE
+	else
+		exec QMAIL/bin/qmail-queue
+	fi
+else
+	/bin/rm -f $out
+	exit $status
+fi
diff -Naur netqmail-1.06.org/tai.h netqmail-1.06/tai.h
--- netqmail-1.06.org/tai.h	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/tai.h	2018-04-03 17:28:43.677318820 +0530
@@ -0,0 +1,34 @@
+/*
+ * $Log: tai.h,v $
+ * Revision 1.3  2004-10-11 14:15:10+05:30  Cprogrammer
+ * added function prototypes
+ *
+ * Revision 1.2  2004-09-19 22:49:23+05:30  Cprogrammer
+ * added tai_unix macro
+ *
+ * Revision 1.1  2004-06-16 01:20:25+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
+#ifndef TAI_H
+#define TAI_H
+
+#include "uint64.h"
+
+struct tai
+{
+	uint64          x;
+};
+
+#define tai_unix(t,u) ((void) ((t)->x = 4611686018427387914ULL + (uint64) (u)))
+#define tai_approx(t) ((double) ((t)->x))
+#define tai_less(t,u) ((t)->x < (u)->x)
+#define TAI_PACK 8
+
+void            tai_now(struct tai *);
+void            tai_add();
+void            tai_sub(struct tai *, struct tai *, struct tai *);
+void            tai_pack(char *, struct tai *);
+void            tai_unpack(char *, struct tai *);
+
+#endif
diff -Naur netqmail-1.06.org/TARGETS netqmail-1.06/TARGETS
--- netqmail-1.06.org/TARGETS	1998-06-15 16:23:16.000000000 +0530
+++ netqmail-1.06/TARGETS	2019-05-22 11:21:14.576878324 +0530
@@ -1,3 +1,4 @@
+dktest
 auto-ccld.sh
 make-load
 find-systype
@@ -385,3 +386,44 @@
 man
 setup
 check
+qmail-dk
+qmail-dkim
+qmail-dkim.o
+qmail-dk.o
+libdkim.a
+dkimbase.o
+dkimdns.o
+dkim.o
+dkimsign.o
+dkimverify.o
+dkim
+dkim.o
+dkim.8
+qmail-dkim.8
+qmail-dkim.0
+str_cpyb.o
+dkimfuncs.o
+MakeArgs.o
+spawn-filter spawn-filter.o qregex.o wildmat.o
+spawn-filter.8
+qmail-dk.0 spawn-filter.0
+dk-filter echo.o echo dk-filter.0 dk-filter.8
+case_startb.o
+mess822_ok.o
+scan_xlong.o
+socket_v4mappedprefix.o
+socket_v6any.o
+str_cspn.o
+surblfilter.o
+surblfilter
+surblfilter.8
+uint64.h
+surblqueue
+surblfilter.0
+base64sub.o
+qmail-dk.8
+dktest.o
+dktrace.o
+dknewkey
+dktest.8
+time_t_size.h
diff -Naur netqmail-1.06.org/time_t_size.c netqmail-1.06/time_t_size.c
--- netqmail-1.06.org/time_t_size.c	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/time_t_size.c	2019-05-22 11:20:59.525581024 +0530
@@ -0,0 +1,8 @@
+#include <stdio.h>
+#include <time.h>
+int
+main()
+{
+	printf("#define SIZEOF_TIME_T %d\n", sizeof(time_t));
+	return (0);
+}
diff -Naur netqmail-1.06.org/tryulong64.c netqmail-1.06/tryulong64.c
--- netqmail-1.06.org/tryulong64.c	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/tryulong64.c	2018-04-03 17:28:43.678318840 +0530
@@ -0,0 +1,47 @@
+/*
+ * $Log: tryulong64.c,v $
+ * Revision 1.1  2004-05-14 00:45:23+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
+void
+main()
+{
+	unsigned long   u;
+	u = 1;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	if (!u)
+		_exit(1);
+	_exit(0);
+}
diff -Naur netqmail-1.06.org/uint64.h1 netqmail-1.06/uint64.h1
--- netqmail-1.06.org/uint64.h1	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/uint64.h1	2018-04-03 17:28:43.678318840 +0530
@@ -0,0 +1,12 @@
+/*
+ * $Log: uint64.h1,v $
+ * Revision 1.1  2004-10-22 15:00:08+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
+#ifndef UINT64_H
+#define UINT64_H
+
+typedef unsigned long uint64;
+
+#endif
diff -Naur netqmail-1.06.org/uint64.h2 netqmail-1.06/uint64.h2
--- netqmail-1.06.org/uint64.h2	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/uint64.h2	2018-04-03 17:28:43.678318840 +0530
@@ -0,0 +1,12 @@
+/*
+ * $Log: uint64.h2,v $
+ * Revision 1.1  2004-10-22 15:00:36+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
+#ifndef UINT64_H
+#define UINT64_H
+
+typedef unsigned long long uint64;
+
+#endif
diff -Naur netqmail-1.06.org/wildmat.c netqmail-1.06/wildmat.c
--- netqmail-1.06.org/wildmat.c	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/wildmat.c	2018-04-03 17:28:43.678318840 +0530
@@ -0,0 +1,173 @@
+/*-** wildmat.c.orig	Wed Dec  3 11:46:31 1997
+ * $Revision: 1.6 $
+ * Do shell-style pattern matching for ?, \, [], and * characters.
+ * Might not be robust in face of malformed patterns; e.g., "foo[a-"
+ * could cause a segmentation violation.  It is 8bit clean.
+ * 
+ * Written by Rich $alz, mirror!rs, Wed Nov 26 19:03:17 EST 1986.
+ * Rich $alz is now <rsalz@osf.org>.
+ * April, 1991:  Replaced mutually-recursive calls with in-line code
+ * for the star character.
+ *
+ * Special thanks to Lars Mathiesen <thorinn@diku.dk> for the ABORT code.
+ * This can greatly speed up failing wildcard patterns.  For example:
+ * pattern: -*-*-*-*-*-*-12-*-*-*-m-*-*-*
+ * text 1:  -adobe-courier-bold-o-normal--12-120-75-75-m-70-iso8859-1
+ * text 2:  -adobe-courier-bold-o-normal--12-120-75-75-X-70-iso8859-1
+ * Text 1 matches with 51 calls, while text 2 fails with 54 calls.  Without
+ * the ABORT code, it takes 22310 calls to fail.  Ugh.  The following
+ * explanation is from Lars:
+ * The precondition that must be fulfilled is that DoMatch will consume
+ * at least one character in text.  This is true if *p is neither '*' no
+ * '\0'.)  The last return has ABORT instead of FALSE to avoid quadratic
+ * behaviour in cases like pattern "*a*b*c*d" with text "abcxxxxx".  With
+ * FALSE, each star-loop has to run to the end of the text; with ABORT
+ * only the last one does.
+ * 
+ * Once the control of one instance of DoMatch enters the star-loop, that
+ * instance will return either TRUE or ABORT, and any calling instance
+ * will therefore return immediately after (without calling recursively
+ * again).  In effect, only one star-loop is ever active.  It would be
+ * possible to modify the code to maintain this context explicitly,
+ * eliminating all recursive calls at the cost of some complication and
+ * loss of clarity (and the ABORT stuff seems to be unclear enough by
+ * itself).  I think it would be unwise to try to get this into a
+ * released version unless you have a good test data base to try it out
+ * on.
+ */
+#define TRUE			 1
+#define FALSE			 0
+#define ABORT			-1
+
+
+/*- What character marks an inverted character class?  */
+#define NEGATE_CLASS		'^'
+/*- Is "*" a common pattern?  */
+#define OPTIMIZE_JUST_STAR
+/*- Do tar(1) matching rules, which ignore a trailing slash?  */
+#undef MATCH_TAR_PATTERN
+
+
+/*- Match text and p, return TRUE, FALSE, or ABORT.  */
+static int
+DoMatch(text, p)
+	register char  *text;
+	register char  *p;
+{
+	register int    last;
+	register int    matched;
+	register int    reverse;
+
+	for (; *p; text++, p++)
+	{
+		if (*text == '\0' && *p != '*')
+			return ABORT;
+		switch (*p)
+		{
+		case '\\': /*- Literal match with following character.  */
+			p++;
+			/*- FALLTHROUGH */
+		default:
+			if (*text != *p)
+				return FALSE;
+			continue;
+		case '?': /*- Match anything. */
+			continue;
+		case '*':
+			/*- Consecutive stars act just like one.  */
+			while (*++p == '*')
+				continue;
+			/*- Trailing star matches everything.  */
+			if (*p == '\0')
+				return TRUE;
+			while (*text)
+				if ((matched = DoMatch(text++, p)) != FALSE)
+					return matched;
+			return ABORT;
+		case '[':
+			reverse = p[1] == NEGATE_CLASS ? TRUE : FALSE;
+			/*- Inverted character class.  */
+			if (reverse)
+				p++;
+			matched = FALSE;
+			if (p[1] == ']' || p[1] == '-')
+			{
+				if (*++p == *text)
+					matched = TRUE;
+			}
+			for (last = *p; *++p && *p != ']'; last = *p)
+			{
+				/*- This next line requires a good C compiler.  */
+				if (*p == '-' && p[1] != ']' ? *text <= *++p && *text >= last : *text == *p)
+					matched = TRUE;
+			}
+			if (matched == reverse)
+				return FALSE;
+			continue;
+		}
+	}
+
+#ifdef	MATCH_TAR_PATTERN
+	if (*text == '/')
+		return TRUE;
+#endif /*- MATCH_TAR_ATTERN */
+	return *text == '\0';
+}
+
+
+/*- User-level routine.  Returns TRUE or FALSE.  */
+int
+wildmat_internal(text, p)
+	char           *text;
+	char           *p;
+{
+#ifdef	OPTIMIZE_JUST_STAR
+	if (p[0] == '*' && p[1] == '\0')
+		return TRUE;
+#endif /*- OPTIMIZE_JUST_STAR */
+	return DoMatch(text, p) == TRUE;
+}
+
+#if	defined(TEST)
+include < stdio.h >
+/*- Yes, we use gets not fgets.  Sue me.  */
+
+int
+main()
+{
+	char            p[80];
+	char            text[80];
+
+	printf("Wildmat tester.  Enter pattern, then strings to test.\n");
+	printf("A blank line gets prompts for a new pattern; a blank pattern\n");
+	printf("exits the program.\n");
+	for (;;)
+	{
+		printf("\nEnter pattern:  ");
+		(void) fflush(stdout);
+		if (gets(p) == NULL || p[0] == '\0')
+			break;
+		for (;;)
+		{
+			printf("Enter text:  ");
+			(void) fflush(stdout);
+			if (gets(text) == NULL)
+				exit(0);
+			/*- Blank line; go back and get a new pattern.  */
+			if (text[0] == '\0')
+				break;
+			printf("      %s\n", wildmat_internal(text, p) ? "YES" : "NO");
+		}
+	}
+	exit(0);
+	/*- NOTREACHED */
+}
+#endif /*- defined(TEST) */
+
+void
+getversion_wildmat_internal_c()
+{
+	static char    *x = "$Id: wildmat.c,v 1.6 2008-08-03 18:26:33+05:30 Cprogrammer Stab mbhangui $";
+	x++;
+	x--;
+}
