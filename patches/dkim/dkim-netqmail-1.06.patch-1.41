diff -Naur netqmail-1.06.org/alloc.c netqmail-1.06/alloc.c
--- netqmail-1.06.org/alloc.c	1998-06-15 16:23:16.000000000 +0530
+++ netqmail-1.06/alloc.c	2022-12-09 22:58:50.000000000 +0530
@@ -1,6 +1,6 @@
 #include "alloc.h"
 #include "error.h"
-extern char *malloc();
+extern void *malloc();
 extern void free();
 
 #define ALIGNMENT 16 /* XXX: assuming that this alignment is enough */
diff -Naur netqmail-1.06.org/auto-int8.c netqmail-1.06/auto-int8.c
--- netqmail-1.06.org/auto-int8.c	1998-06-15 16:23:16.000000000 +0530
+++ netqmail-1.06/auto-int8.c	2022-12-09 22:58:50.000000000 +0530
@@ -7,7 +7,7 @@
 char buf1[256];
 substdio ss1 = SUBSTDIO_FDBUF(write,1,buf1,sizeof(buf1));
 
-void puts(s)
+void my_puts(s)
 char *s;
 {
   if (substdio_puts(&ss1,s) == -1) _exit(111);
@@ -30,11 +30,11 @@
   scan_8long(value,&num);
   strnum[fmt_ulong(strnum,num)] = 0;
 
-  puts("int ");
-  puts(name);
-  puts(" = ");
-  puts(strnum);
-  puts(";\n");
+  my_puts("int ");
+  my_puts(name);
+  my_puts(" = ");
+  my_puts(strnum);
+  my_puts(";\n");
   if (substdio_flush(&ss1) == -1) _exit(111);
   _exit(0);
 }
diff -Naur netqmail-1.06.org/auto-int.c netqmail-1.06/auto-int.c
--- netqmail-1.06.org/auto-int.c	1998-06-15 16:23:16.000000000 +0530
+++ netqmail-1.06/auto-int.c	2022-12-09 22:58:50.000000000 +0530
@@ -7,7 +7,7 @@
 char buf1[256];
 substdio ss1 = SUBSTDIO_FDBUF(write,1,buf1,sizeof(buf1));
 
-void puts(s)
+void my_puts(s)
 char *s;
 {
   if (substdio_puts(&ss1,s) == -1) _exit(111);
@@ -30,11 +30,11 @@
   scan_ulong(value,&num);
   strnum[fmt_ulong(strnum,num)] = 0;
 
-  puts("int ");
-  puts(name);
-  puts(" = ");
-  puts(strnum);
-  puts(";\n");
+  my_puts("int ");
+  my_puts(name);
+  my_puts(" = ");
+  my_puts(strnum);
+  my_puts(";\n");
   if (substdio_flush(&ss1) == -1) _exit(111);
   _exit(0);
 }
diff -Naur netqmail-1.06.org/auto-str.c netqmail-1.06/auto-str.c
--- netqmail-1.06.org/auto-str.c	1998-06-15 16:23:16.000000000 +0530
+++ netqmail-1.06/auto-str.c	2022-12-09 22:58:50.000000000 +0530
@@ -5,7 +5,7 @@
 char buf1[256];
 substdio ss1 = SUBSTDIO_FDBUF(write,1,buf1,sizeof(buf1));
 
-void puts(s)
+void my_puts(s)
 char *s;
 {
   if (substdio_puts(&ss1,s) == -1) _exit(111);
@@ -25,20 +25,20 @@
   value = argv[2];
   if (!value) _exit(100);
 
-  puts("char ");
-  puts(name);
-  puts("[] = \"\\\n");
+  my_puts("char ");
+  my_puts(name);
+  my_puts("[] = \"\\\n");
 
   while (ch = *value++) {
-    puts("\\");
+    my_puts("\\");
     octal[3] = 0;
     octal[2] = '0' + (ch & 7); ch >>= 3;
     octal[1] = '0' + (ch & 7); ch >>= 3;
     octal[0] = '0' + (ch & 7);
-    puts(octal);
+    my_puts(octal);
   }
 
-  puts("\\\n\";\n");
+  my_puts("\\\n\";\n");
   if (substdio_flush(&ss1) == -1) _exit(111);
   _exit(0);
 }
diff -Naur netqmail-1.06.org/base64.h netqmail-1.06/base64.h
--- netqmail-1.06.org/base64.h	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/base64.h	2022-12-09 22:58:50.000000000 +0530
@@ -0,0 +1,14 @@
+/*
+ * $Log: base64.h,v $
+ * Revision 1.3  2004-06-18 22:55:43+05:30  Cprogrammer
+ * added RCS log
+ *
+ */
+#ifndef BASE64_H
+#define BASE64_H
+#include "stralloc.h"
+
+extern int b64decode(const unsigned char *, int, stralloc *);
+extern int b64encode(stralloc *, stralloc *);
+
+#endif
diff -Naur netqmail-1.06.org/base64sub.c netqmail-1.06/base64sub.c
--- netqmail-1.06.org/base64sub.c	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/base64sub.c	2022-12-09 22:58:50.000000000 +0530
@@ -0,0 +1,170 @@
+/*
+ * $Log: base64sub.c,v $
+ * Revision 1.6  2010-03-03 09:33:16+05:30  Cprogrammer
+ * renamed base64 to base64sub
+ *
+ * Revision 1.5  2004-10-22 20:18:37+05:30  Cprogrammer
+ * added RCS id
+ *
+ * Revision 1.4  2004-09-19 14:36:11+05:30  Cprogrammer
+ * corrected number of bytes in stralloc variable 'out'
+ *
+ * Revision 1.3  2004-07-30 17:36:47+05:30  Cprogrammer
+ * fixed bugs in b64decode()
+ *
+ * Revision 1.2  2004-07-17 21:16:27+05:30  Cprogrammer
+ * added RCS log
+ *
+ */
+#include "base64.h"
+#include "stralloc.h"
+#include "substdio.h"
+#include "str.h"
+
+static char    *b64alpha = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
+#define B64PAD '='
+
+/*
+ * returns 0 ok, 1 illegal, -1 problem 
+ */
+
+int
+b64decode(in, l, out)
+	const unsigned char *in;
+	int             l;
+	stralloc       *out;		/*- not null terminated */
+{
+	int             p = 0;
+	int             n;
+	unsigned int    x;
+	int             i, j;
+	char           *s;
+	unsigned char   b[3];
+
+	if (l == 0)
+	{
+		if (!stralloc_copys(out, ""))
+			return -1;
+		return 0;
+	}
+	while (in[l - 1] == B64PAD)
+	{
+		p++;
+		l--;
+	}
+	n = (l + p) / 4;
+	out->len = (n * 3) - p;
+	if (!stralloc_ready(out, out->len))
+		return -1;
+	s = out->s;
+	for (i = 0; i < n - 1; i++)
+	{
+		x = 0;
+		for (j = 0; j < 4; j++)
+		{
+			if (in[j] >= 'A' && in[j] <= 'Z')
+				x = (x << 6) + (unsigned int) (in[j] - 'A' + 0);
+			else
+			if (in[j] >= 'a' && in[j] <= 'z')
+				x = (x << 6) + (unsigned int) (in[j] - 'a' + 26);
+			else
+			if (in[j] >= '0' && in[j] <= '9')
+				x = (x << 6) + (unsigned int) (in[j] - '0' + 52);
+			else
+			if (in[j] == '+')
+				x = (x << 6) + 62;
+			else
+			if (in[j] == '/')
+				x = (x << 6) + 63;
+			else
+			if (in[j] == '=')
+				x = (x << 6);
+		}
+		s[2] = (unsigned char) (x & 255);
+		x >>= 8;
+		s[1] = (unsigned char) (x & 255);
+		x >>= 8;
+		s[0] = (unsigned char) (x & 255);
+		x >>= 8;
+		s += 3;
+		in += 4;
+	}
+	x = 0;
+	for (j = 0; j < 4; j++)
+	{
+		if (in[j] >= 'A' && in[j] <= 'Z')
+			x = (x << 6) + (unsigned int) (in[j] - 'A' + 0);
+		else
+		if (in[j] >= 'a' && in[j] <= 'z')
+			x = (x << 6) + (unsigned int) (in[j] - 'a' + 26);
+		else
+		if (in[j] >= '0' && in[j] <= '9')
+			x = (x << 6) + (unsigned int) (in[j] - '0' + 52);
+		else
+		if (in[j] == '+')
+			x = (x << 6) + 62;
+		else
+		if (in[j] == '/')
+			x = (x << 6) + 63;
+		else
+		if (in[j] == '=')
+			x = (x << 6);
+	}
+	b[2] = (unsigned char) (x & 255);
+	x >>= 8;
+	b[1] = (unsigned char) (x & 255);
+	x >>= 8;
+	b[0] = (unsigned char) (x & 255);
+	x >>= 8;
+	for (i = 0; i < 3 - p; i++)
+		s[i] = b[i];
+	out->len = (n * 3) - p;
+	return 0;
+}
+
+int
+b64encode(in, out)
+	stralloc       *in;
+	stralloc       *out;		/*- not null terminated */
+{
+	unsigned char   a, b, c;
+	int             i;
+	char           *s;
+
+	if (in->len == 0)
+	{
+		if (!stralloc_copys(out, ""))
+			return -1;
+		return 0;
+	}
+	if (!stralloc_ready(out, in->len / 3 * 4 + 4))
+		return -1;
+	s = out->s;
+	for (i = 0; i < in->len; i += 3)
+	{
+		a = in->s[i];
+		b = i + 1 < in->len ? in->s[i + 1] : 0;
+		c = i + 2 < in->len ? in->s[i + 2] : 0;
+		*s++ = b64alpha[a >> 2];
+		*s++ = b64alpha[((a & 3) << 4) | (b >> 4)];
+		if (i + 1 >= in->len)
+			*s++ = B64PAD;
+		else
+			*s++ = b64alpha[((b & 15) << 2) | (c >> 6)];
+
+		if (i + 2 >= in->len)
+			*s++ = B64PAD;
+		else
+			*s++ = b64alpha[c & 63];
+	}
+	out->len = s - out->s;
+	return 0;
+}
+
+void
+getversion_base64sub_c()
+{
+	static char    *x = "$Id: base64sub.c,v 1.6 2010-03-03 09:33:16+05:30 Cprogrammer Stab mbhangui $";
+
+	x++;
+}
diff -Naur netqmail-1.06.org/caldate.h netqmail-1.06/caldate.h
--- netqmail-1.06.org/caldate.h	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/caldate.h	2022-12-09 22:58:50.000000000 +0530
@@ -0,0 +1,24 @@
+/*
+ * $Log: caldate.h,v $
+ * Revision 1.3  2004-10-09 23:20:20+05:30  Cprogrammer
+ * added function prototypes
+ *
+ * Revision 1.2  2004-06-18 22:57:44+05:30  Cprogrammer
+ * added RCS log
+ *
+ */
+#ifndef CALDATE_H
+#define CALDATE_H
+
+struct caldate
+{
+	long            year;
+	int             month;
+	int             day;
+};
+
+void            caldate_frommjd(struct caldate *, long, int *, int *);
+long            caldate_mjd(struct caldate *);
+unsigned int    caldate_fmt(char *, struct caldate *);
+
+#endif
diff -Naur netqmail-1.06.org/caltime.h netqmail-1.06/caltime.h
--- netqmail-1.06.org/caltime.h	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/caltime.h	2022-12-09 22:58:50.000000000 +0530
@@ -0,0 +1,30 @@
+/*
+ * $Log: caltime.h,v $
+ * Revision 1.3  2004-10-09 23:20:26+05:30  Cprogrammer
+ * added function prototypes
+ *
+ * Revision 1.2  2004-06-18 22:57:47+05:30  Cprogrammer
+ * added RCS log
+ *
+ */
+#ifndef CALTIME_H
+#define CALTIME_H
+
+#include "caldate.h"
+#include "tai.h"
+
+struct caltime
+{
+	struct caldate  date;
+	int             hour;
+	int             minute;
+	int             second;
+	long            offset;
+};
+
+void            caltime_tai(struct caltime *, struct tai *);
+void            caltime_utc(struct caltime *, struct tai *, int *, int *);
+
+unsigned int    caltime_fmt(char *, struct caltime *);
+
+#endif
diff -Naur netqmail-1.06.org/case_startb.c netqmail-1.06/case_startb.c
--- netqmail-1.06.org/case_startb.c	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/case_startb.c	2022-12-09 22:58:50.000000000 +0530
@@ -0,0 +1,49 @@
+/*
+ * $Log: case_startb.c,v $
+ * Revision 1.3  2004-10-22 20:23:18+05:30  Cprogrammer
+ * added RCS id
+ *
+ * Revision 1.2  2004-07-17 21:17:13+05:30  Cprogrammer
+ * added RCS log
+ *
+ */
+#include "case.h"
+
+int
+case_startb(s, len, t)
+	register char  *s;
+	unsigned int    len;
+	register char  *t;
+{
+	register unsigned char x;
+	register unsigned char y;
+
+	for (;;)
+	{
+		y = *t++ - 'A';
+		if (y <= 'Z' - 'A')
+			y += 'a';
+		else
+			y += 'A';
+		if (!y)
+			return 1;
+		if (!len)
+			return 0;
+		--len;
+		x = *s++ - 'A';
+		if (x <= 'Z' - 'A')
+			x += 'a';
+		else
+			x += 'A';
+		if (x != y)
+			return 0;
+	}
+}
+
+void
+getversion_case_startb_c()
+{
+	static char    *x = "$Id: case_startb.c,v 1.3 2004-10-22 20:23:18+05:30 Cprogrammer Stab mbhangui $";
+
+	x++;
+}
diff -Naur netqmail-1.06.org/conf-cc netqmail-1.06/conf-cc
--- netqmail-1.06.org/conf-cc	1998-06-15 16:23:16.000000000 +0530
+++ netqmail-1.06/conf-cc	2022-12-09 22:58:50.000000000 +0530
@@ -1,3 +1,3 @@
-cc -O2
+cc -O2 -g
 
 This will be used to compile .c files.
diff -Naur netqmail-1.06.org/config.h netqmail-1.06/config.h
--- netqmail-1.06.org/config.h	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/config.h	2023-01-27 09:50:12.000000000 +0530
@@ -0,0 +1,9 @@
+/* config.h.  Generated from config.h.in by configure.  */
+/* config.h.in.  Generated from configure.in by autoheader.  */
+
+/* Define to 1 if you have the <arpa/nameser.h> header file. */
+
+/* Define to 1 if you have the <dlfcn.h> header file. */
+
+/* HAVE_EVP_SHA256 */
+#define HAVE_EVP_SHA256 1
diff -Naur netqmail-1.06.org/conf-ld netqmail-1.06/conf-ld
--- netqmail-1.06.org/conf-ld	1998-06-15 16:23:16.000000000 +0530
+++ netqmail-1.06/conf-ld	2022-12-09 22:58:50.000000000 +0530
@@ -1,3 +1,3 @@
-cc -s
+cc -g
 
 This will be used to link .o files into an executable.
diff -Naur netqmail-1.06.org/control.c netqmail-1.06/control.c
--- netqmail-1.06.org/control.c	1998-06-15 16:23:16.000000000 +0530
+++ netqmail-1.06/control.c	2023-01-31 22:15:31.000000000 +0530
@@ -85,6 +85,82 @@
  return 1;
 }
 
+int
+control_readulong(i, fn)
+	unsigned long  *i;
+	char           *fn;
+{
+	unsigned long   u;
+
+	switch (control_readline(&line, fn))
+	{
+	case 0:
+		return 0;
+	case -1:
+		return -1;
+	}
+	if (!stralloc_0(&line))
+		return -1;
+	if (!scan_ulong(line.s, &u))
+		return 0;
+	*i = u;
+	return 1;
+}
+
+/*
+ * read entire file in variable sa
+ * without any interpretation (e.g. comments)
+ * To be used in case a file contains '#' character
+ * in the first column (which control_readfile() will
+ * skip
+ */
+int
+control_readnativefile(sa, fn, mode)
+	stralloc       *sa;
+	char           *fn;
+	int             mode;
+{
+	substdio        ss;
+	int             fd, match;
+
+	if (!stralloc_copys(sa, ""))
+		return -1;
+	if ((fd = open_read(fn)) == -1)
+	{
+		if (errno == error_noent)
+			return(0);
+		return -1;
+	}
+	substdio_fdbuf(&ss, read, fd, inbuf, sizeof(inbuf));
+	for (;;)
+	{
+		if (getln(&ss, &line, &match, '\n') == -1)
+			break;
+		if (!match && !line.len)
+		{
+			close(fd);
+			return 1;
+		}
+		if (mode) /* for qmail-dk */
+		{
+			striptrailingwhitespace(&line);
+			if (!stralloc_0(&line))
+				break;
+			if (line.s[0] && !stralloc_cat(sa, &line))
+				break;
+		} else
+		if (!stralloc_cat(sa, &line))
+			break;
+		if (!match)
+		{
+			close(fd);
+			return 1;
+		}
+	}
+	close(fd);
+	return -1;
+}
+
 int control_readfile(sa,fn,flagme)
 stralloc *sa;
 char *fn;
diff -Naur netqmail-1.06.org/control.h netqmail-1.06/control.h
--- netqmail-1.06.org/control.h	1998-06-15 16:23:16.000000000 +0530
+++ netqmail-1.06/control.h	2022-12-09 22:58:50.000000000 +0530
@@ -3,8 +3,10 @@
 
 extern int control_init();
 extern int control_readline();
+extern int control_readulong();
 extern int control_rldef();
 extern int control_readint();
+extern int control_readnativefile();
 extern int control_readfile();
 
 #endif
diff -Naur netqmail-1.06.org/dk-filter.9 netqmail-1.06/dk-filter.9
--- netqmail-1.06.org/dk-filter.9	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/dk-filter.9	2023-06-30 19:15:47.866617148 +0530
@@ -0,0 +1,139 @@
+.TH dk-filter 8
+
+.SH NAME
+dk-filter \- sign/verify using DK/DKIM (SSP/ADSP optionally) and deliver a
+mail message for delivery
+
+.SH SYNOPSIS
+\fBFILTERARGS=QMAILHOME/bin/dk-filter\fR
+
+.SH DESCRIPTION
+\fBdk-filter\fR is a qfilter which can be set as a filter for
+\fBspawn-filter\fR(8) or \fBqmail-qfilter\fR(1). The filter can be set
+either as \fBFILTERARGS\fR or in the control file \fBfilterargs\fR.
+
+\fBdk-filter\fR supports DK/DKIM signing and verification and can
+optionally use \fBSender Signing Practice (SSP)\fR or \fBAuthor Domain
+Signing Practice\fR. It uses the libdkim and OpenSSL libraries. To sign a
+message, set the \fBDKIMSIGN\fR environment variable (for DKIM signing) or
+\fBDKSIGIN\fR environment variable (for DK signing) to the pathname of the
+private key that will be used to sign the message. If there is a %
+character in the environment variable, it is removed and replaced by the
+domain name in the From: header. If, after substituting the %, that file
+does not exist, @controldir@/domainkeys/%/default will be used as the key.
+If again, after substituting the % sign, the file does not exist,
+@controldir@/domainkeys/default will be used as the key. After all
+substitutions, if the key file does not exist, the message will not be
+signed. If there is no % and the file does not exist, the message will be
+rejected with error 32. The default private key
+@controldir@/domainkeys/default can be overriden by the
+\fBDKIM_DEFAULT_KEY\fR environment variable.
+
+The selector (s=) will be taken from the basename of the file. The private
+key should be created by \fBdknewkey(8)\fR with RSA or ED25519 encryption
+method.
+
+You can set various DK options in getopt style, by setting the environment
+variable DKSIGNOPTIONS
+
+.nf
+b \fI<advice_length>\fR    Length of Advice
+c \fI<canonicalization>\fR simple, nofws
+s \fI<privkeyfile>\fR      Private key
+h                    show headers included
+r                    Skip Duplicate Headers
+.fi
+
+.EX
+DKSIGNOPTIONS="-h -r -c nofws"
+sets the h= tag, skips duplicate headers and sets nofws canonicalization
+.EE
+
+You can set various DKIM options in getopt style, by setting the
+environment variable DKIMSIGNOPTIONS
+
+.nf
+c <canonicalization> r for relaxed [DEFAULT], s - simple,
+                     t relaxed/simple, u - simple/relaxed
+l                    include body length tag
+q                    include query method tag;
+t                    include a timestamp tag
+h                    include copied headers. This adds the z= tag
+                     containing a copy of the message's original
+                     headers.
+i <identity>         the identity, if not provided it will not be included
+x <expire_time>      the expire time in seconds since epoch
+                     ( DEFAULT = current time + 604800)
+                     if set to - then it will not be included
+z <hash>             1 for sha1, 2 for sha256, 3 for both
+s <privkeyfile>
+y <selector>
+.fi
+
+.EX
+DKIMSIGNOPTIONS="-c r -q"
+sets relaxed canonicalization and include query method tag
+.EE
+
+When signing \fBdk-filter\fR uses the domain found in the Return-Path,
+Sender, From headers to set the domain tag. If not it uses the value
+of \fBBOUNCEDOMAIN\fR or \fBDKIMDOMAIN\fR environment variable.
+\fBBOUNCEDOMAIN\fR or \fBDKIMDOMAIN\fR can be set to an email address or a
+domain (without the at sign).
+
+In addition to \fBDKIMSIGN\fR environment variable, you can have the domain
+and the pathname of the private key in the control file \fIdkimkeys\fR
+which has the following format
+
+.EX
+domain:private_key_path:envstr
+.EE
+
+.fi
+Here \fIenvstr\fR is a string of environment variable additions or
+removals. e.g.
+
+.EX
+QREGEX=1,DKIMSIGNOPTIONS=-z 4
+.EX
+
+.fi
+If an entry for \fIdomain\fR exists in \fIdkimkeys\fR, the value of
+\fBDKIMSIGN\fR environment variable is ignored. You can disable
+\fIdkimkeys\fR by setting \fBNODKIMKEYS\fR environment variable.
+
+
+To verify a message, set the \fBDKIMVERIFY\fR or \fBDKVERIFY\fR environment
+variables. \fBdk-filter\fR always inserts the \fBDKIM-Status\fR or
+\fBDomainKey-Status\fR header, so that messages can be rejected later at
+delivery time, or in the mail reader. In that case you may set
+\fBDKIMVERIFY\fR or \fBDKVERIFY\fR to an empty string. The exit code of
+\fBdk-filter\fR can be fine tuned by setting \fBDKIMVERIFY\fR environment
+variable. See \fBdkim(8)\fR for a detailed description on setting the
+\fBDKIMVERIFY\fR environment variable.
+
+\fBdk-filter\fR does not use any signing practice by default. You can
+override this by setting the SIGN_PRACTICE to ssp or adsp (lowercase).
+
+If neither of these environment variables (DKIMSIGN, DKSIGN, DKIMVERIFY,
+DKVERIFY) are defined, dk-filter will do signing by default.
+
+You can set environment variable NODK to disable domainkeys and set NODKIM
+environment variable to disable DKIM.
+
+\fBdk-filter\fR can insert an additional DKIM-signature if
+\fBDKIMSIGNEXTRA\fR is set. This is useful for inserting both RSA and
+ED25519 signature when signing. As an example you can have \fBDKIMSIGN\fR
+pointing to a RSA private key, \fBDKIMSIGNOPTIONS\fR having "-z 2" along
+with other options if any. Additionally set \fBDKIMSIGNEXTRA\fR pointing to
+an ed25519 private key and set \fBDKIMSIGNOPTIONSEXTRA\fR to have "-z 4"
+along with other options if any.
+
+.SH "EXIT CODES"
+0 for success, non-zero failure
+
+.SH "SEE ALSO"
+qmail-qfilter(1),
+dknewkey(8),
+dkim(8),
+spawn-filter(8)
diff -Naur netqmail-1.06.org/dk-filter.sh netqmail-1.06/dk-filter.sh
--- netqmail-1.06.org/dk-filter.sh	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/dk-filter.sh	2023-06-30 19:17:50.384818250 +0530
@@ -0,0 +1,456 @@
+#
+# $Id: dk-filter.sh,v 1.37 2023-02-17 20:17:51+05:30 Cprogrammer Exp mbhangui $
+#
+get_dkimkeys()
+{
+	domain=$1
+	if [ ! -f $CONTROLDIR/dkimkeys ] ; then
+		return 0
+	fi
+	(
+	awk -F: '{print $1" "$2" "$3}' $CONTROLDIR/dkimkeys | while read line
+	do
+		set $line
+		echo $domain | grep -E "$1" >/dev/null
+		if [ $? -eq 0 ] ; then
+			echo $2
+			shift 2
+			if [ $# -gt 0 ] ; then
+				echo "$*" | tr , \\n | while read "line"
+				do
+					var=$(echo $line | cut -d= -f1)
+					val=$(echo $line | cut -d= -f2-)
+					if [ -n "$val" ] ; then
+						echo "export $var=\"$val\"" 1>&3
+					else
+						unset $var
+					fi
+				done
+			fi
+			break
+		fi
+	done
+	)
+}
+
+#
+# replace % with domain in private key filename
+# sets keyfn
+#
+replace_percent()
+{
+	percent_found=0
+	echo $1|grep "%" >/dev/null 2>&1
+	if [ $? -eq 0 ] ; then
+		percent_found=1
+	fi
+	if [ $percent_found -eq 1 ] ; then
+		if [ -n "$BOUNCEDOMAIN" -a -z "$_SENDER" ] ; then
+			keyfn=$(echo $1 | sed "s{%{$BOUNCEDOMAIN{g")
+			if [ ! -f $keyfn ] ; then # remove % and check if file exists
+				t=$(echo $1 | sed "s{/%{{g")
+				if [ -f $t ] ; then
+					keyfn=$t
+				fi
+			fi
+		elif [ -n " $_SENDER" ] ; then
+			# replace '%' in filename with domain
+			domain=$(echo $_SENDER | cut -d@ -f2)
+			keyfn=$(echo $1 | sed "s{%{$domain{g")
+			if [ ! -f $keyfn ] ; then # remove % and check if file exists
+				t=$(echo $1 | sed "s{/%{{g")
+				if [ -f $t ] ; then
+					keyfn=$t
+				fi
+			fi
+		else
+			keyfn=$1
+		fi
+	else
+		keyfn=$1
+	fi
+}
+
+dkim_setoptions()
+{
+	# DKIMSIGNOPTIONS="-z 1 -x - -y $dkimselector -s $dkimkeyfn"
+	set -- $(getopt lqthb:c:d:i:x:z:y:s: "$1")
+	bopt=0
+	xopt=0
+	zopt=0
+	yopt=0
+	sopt=0
+	dkimopts="$prefix/bin/dkim"
+	while [ $1 != -- ]
+	do
+		case $1 in
+		-l)
+		dkimopts="$dkimopts -l"
+		;;
+		-q)
+		dkimopts="$dkimopts -q"
+		;;
+		-t)
+		dkimopts="$dkimopts -t"
+		;;
+		-h)
+		dkimopts="$dkimopts -h"
+		;;
+
+		-b)
+		bopt=1
+		dkimopts="$dkimopts -b $2"
+		shift
+		;;
+
+		-c)
+		dkimopts="$dkimopts -c $2"
+		shift
+		;;
+
+		-d)
+		dkimopts="$dkimopts -d $2"
+		shift
+		;;
+
+		-i)
+		dkimopts="$dkimopts -i $2"
+		shift
+		;;
+
+		-x)
+		xopt=1
+		dkimopts="$dkimopts -x $2"
+		shift
+		;;
+
+		-z)
+		zopt=1
+		dkimopts="$dkimopts -z $2"
+		shift
+		;;
+
+		-y)
+		yopt=1
+		dkimopts="$dkimopts -y $2"
+		shift
+		;;
+
+		-s)
+		sopt=1
+		dkimopts="$dkimopts -s $2"
+		shift
+		;;
+		esac
+		shift   # next flag
+	done
+	if [ $zopt -eq 0 ] ; then
+		dkimopts="$dkimopts -z 2"
+	fi
+	if [ $xopt -eq 0 ] ; then
+		dkimopts="$dkimopts -x -"
+	fi
+	if [ $yopt -eq 0 ] ; then
+		dkimopts="$dkimopts -y $dkimselector"
+	fi
+	if [ $sopt -eq 0 ] ; then
+		dkimopts="$dkimopts -s $dkimkeyfn"
+	fi
+}
+
+#
+# sets keyfn, selector
+#
+set_selector()
+{
+	if [ -z "$1" -o -z "$2" ] ; then
+		return 1
+	fi
+	replace_percent $2
+	case $1 in
+		"dkim")
+		dkimkeyfn=$keyfn
+		# dkimsign is first set by get_dkimfn
+		if [ $dkimsign -eq 2 -a ! -f $dkimkeyfn ] ; then
+			dkimkeyfn=$default_key
+		fi
+		if [ ! -f $dkimkeyfn ] ; then
+			dkimsign=0
+			if [ $percent_found -eq 0 ] ; then
+				echo "private key does not exist" 1>&2
+				/bin/rm -f $tmpfn
+				exit $priv_key_err # private key does not exist
+			else
+				dkimsign=1
+			fi
+		else
+			dkimsign=1
+		fi
+		dkimselector=$(basename $dkimkeyfn)
+		;;
+	esac
+}
+
+#
+# uses dkimkeys to set DKIMSIGN. Overrides original DKIMSIGN
+#
+get_dkimfn()
+{
+# set private key for dk / dkim signing
+if [ -z "$NODKIM" -a -z "$DKIMVERIFY" ] ; then
+	if [ -f $CONTROLDIR/dkimkeys ] ; then
+		domain=$(echo $_SENDER | cut -d@ -f2)
+		t=$(get_dkimkeys $domain)
+		if [ -n "$t" ] ; then
+			if [ -z "$NODKIM" -a -z "$DKIMVERIFY" -a -x $prefix/bin/dkim ] ; then
+				DKIMSIGN=$t
+			fi
+		fi
+	fi
+	if [ -z "$NODKIM" -a -z "$DKIMVERIFY" -a -x $prefix/bin/dkim ] ; then
+		if [ -z "$DKIMSIGN" ] ; then
+			DKIMSIGN=$CONTROLDIR/domainkeys/%/default
+			dkimsign=2 # key, selector selected as control/domainkeys/defaut
+		elif [ " $DKIMSIGN" = " $CONTROLDIR/domainkeys/%/default" ] ; then
+			dkimsign=2 # key, selector selected as control/domainkeys/defaut
+		fi
+	fi
+fi
+}
+
+if [ -z "$QMAILREMOTE" -a -z "$QMAILLOCAL" ]; then
+	echo "dk-filter should be run by spawn-filter" 1>&2
+	exit 1
+fi
+dkimsign=0
+dkimverify=0
+prefix=PREFIX
+
+if [ "$prefix" = "/usr" ] ; then
+	priv_key_err=35 # indimail
+else
+	priv_key_err=32 # netqmail, notqmail
+	BOUNCEDOMAIN=$DKIMDOMAIN
+fi
+if [ " $CONTROLDIR" = " " ] ; then
+	CONTROLDIR=@controldir@
+fi
+if [ -n "$NODKIM" ] ; then
+	exec /bin/cat
+fi
+
+if [ -z "$NODKIM" -a ! -f $prefix/bin/dkim ] ; then
+	echo "$prefix/bin/dkim: No such file or directory" 1>&2
+	exit 1
+fi
+
+if [ -z "$DEFAULT_DKIM_KEY" ] ; then
+	default_key=$CONTROLDIR/domainkeys/default
+else
+	default_key=$DEFAULT_DKIM_KEY
+fi
+slash=$(echo $CONTROLDIR | cut -c1)
+if [ " $slash" != " /" ] ; then
+	cd SYSCONFDIR
+fi
+
+if [ -z "$NODKIM" ] ; then
+	if [ -n "$DKIMVERIFY" ] ; then
+		dkimverify=1
+	else
+		envfn=$(mktemp -t envfilterXXXXXX)
+		exec 3>$envfn
+		get_dkimfn
+		source $envfn
+		/bin/rm -f $envfn
+	fi
+fi
+tmpfn=$(mktemp -t dk-filterXXXXXX)
+/bin/cat > $tmpfn
+if [ -n "$DKIMSIGN" ] ; then
+	set_selector "dkim" "$DKIMSIGN"
+	if [ -n "$dkimkeyfn" -a -f "$dkimkeyfn" ] ; then
+		dkim_setoptions "$DKIMSIGNOPTIONS"
+		exec 0<$tmpfn
+		eval $dkimopts
+		if [ $? -ne 0 ] ; then
+			/bin/rm -f $tmpfn
+			echo "$prefix/bin/dkim failed" 1>&2
+			exit 1
+		fi
+	fi
+	if [ -n "$DKIMSIGNEXTRA" ] ; then
+		set_selector "dkim" "$DKIMSIGNEXTRA"
+		dkim_setoptions "$DKIMSIGNOPTIONSEXTRA"
+		if [ -n "$dkimkeyfn" -a -f "$dkimkeyfn" ] ; then
+			exec 0<$tmpfn
+			eval $dkimopts
+			if [ $? -ne 0 ] ; then
+				/bin/rm -f $tmpfn
+				echo "$prefix/bin/dkim failed" 1>&2
+				exit 1
+			fi
+		fi
+	fi
+fi
+if [ $dkimverify -eq 1 ] ; then
+	practice=$SIGN_PRACTICE
+	if [ " $practice" = " " ] ; then
+		practice=0
+	elif [ " $practice" = " ssp" ] ; then
+		practice=1
+	elif [ " $practice" = " adsp" ] ; then
+		practice=2
+	fi
+	exec 0<$tmpfn
+	dkimvargs="-p $practice"
+	if [ -n "$UNSIGNED_SUBJECT" ] ; then
+		dkimvargs="$dkimvargs -S"
+	fi
+	if [ -n "$UNSIGNED_FROM" ] ; then
+		dkimvargs="$dkimvargs -f"
+	fi
+	if [ -n "$VERBOSE" ] ; then
+		dkimvargs="$dkimvargs -V"
+	fi
+	if [ -n "$SELECTOR_DATA" ] ; then
+		$prefix/bin/dkim $dkimvargs -v -T "$SELECTOR_DATA"
+	else
+		$prefix/bin/dkim $dkimvargs -v
+	fi
+	ret=$?
+	case $ret in
+		14) # permanent error
+		/bin/rm -f $tmpfn
+		exit 100
+		;;
+		88) # temporary error
+		/bin/rm -f $tmpfn
+		exit 111
+		;;
+	esac
+	if [ $ret -lt 0 ] ; then
+		echo "$prefix/bin/dkim failed" 1>&2
+		/bin/rm -f $tmpfn
+		exit 1
+	fi
+fi
+exec 0<$tmpfn
+/bin/rm -f $tmpfn
+/bin/cat
+exit $?
+#
+# $Log: dk-filter.sh,v $
+# Revision 1.37  2023-02-17 20:17:51+05:30  Cprogrammer
+# set environment variables from dkimkeys
+#
+# Revision 1.36  2023-02-13 10:07:28+05:30  Cprogrammer
+# removed yahoo domainkeys
+#
+# Revision 1.35  2023-02-12 18:17:21+05:30  Cprogrammer
+# use VERBOSE variable to turn on debug for signature verification status on fd 2
+#
+# Revision 1.34  2023-02-05 20:59:55+05:30  Cprogrammer
+# fixed temp files not removed for private key not found
+#
+# Revision 1.33  2023-02-02 17:30:12+05:30  Cprogrammer
+# refactored for multi-signature generation
+#
+# Revision 1.32  2023-01-26 22:26:01+05:30  Cprogrammer
+# removed setting redundant -b option
+#
+# Revision 1.31  2022-11-09 20:15:17+05:30  Cprogrammer
+# replaced deprecated egrep with grep -E
+#
+# Revision 1.30  2022-10-02 22:15:23+05:30  Cprogrammer
+# don't treat missng private key as error when DKIMSIGN has %
+#
+# Revision 1.29  2022-09-28 15:26:32+05:30  Cprogrammer
+# remove '%' from filename if dkim key file not found
+#
+# Revision 1.28  2021-08-28 23:15:40+05:30  Cprogrammer
+# control file dkimkeys for domain specific private key, selector
+#
+# Revision 1.27  2020-07-30 11:29:04+05:30  Cprogrammer
+# Use BOUNCEDOMAIN only for bounces
+#
+# Revision 1.26  2020-04-11 08:41:50+05:30  Cprogrammer
+# renamed DKIMDOMAIN to BOUNCEDOMAIN
+#
+# Revision 1.25  2020-04-09 22:25:01+05:30  Cprogrammer
+# exec cat if both NODDK and NODKIM are defined
+#
+# Revision 1.24  2020-04-09 21:42:09+05:30  Cprogrammer
+# added variables NODK, NODKIM to disable domainkeys, dkim
+#
+# Revision 1.23  2019-06-26 18:39:43+05:30  Cprogrammer
+# use DEFAULT_DKIM_KEY env variable for default signing key
+#
+# Revision 1.22  2019-06-24 23:19:57+05:30  Cprogrammer
+# added code for -d option in DKIMSIGNOPTIONS
+#
+# Revision 1.21  2019-01-14 00:10:00+05:30  Cprogrammer
+# added -S, -f option to verify signatures with unsigned subject, unsigned from
+#
+# Revision 1.20  2017-03-09 16:38:15+05:30  Cprogrammer
+# FHS changes
+#
+# Revision 1.19  2016-05-17 23:11:42+05:30  Cprogrammer
+# fix for configurable control directory
+#
+# Revision 1.18  2014-03-12 08:50:48+05:30  Cprogrammer
+# bug - fixed signing when env variables DKSIGN or DKIMSIGN were set
+#
+# Revision 1.17  2013-09-03 23:04:30+05:30  Cprogrammer
+# set signing as default if both DKSIGN and DKIMSIGN are not defined
+#
+# Revision 1.16  2013-08-17 15:59:21+05:30  Cprogrammer
+# do not treat duplicate DomainKey-Signature as an error
+#
+# Revision 1.15  2013-08-17 15:02:06+05:30  Cprogrammer
+# fixed syntax errors and private key lookup
+#
+# Revision 1.14  2011-02-10 22:47:01+05:30  Cprogrammer
+# fixed exit code of dk-filter when doing verification
+#
+# Revision 1.13  2011-02-08 22:02:29+05:30  Cprogrammer
+# use sender domain when replacing '%' in private key
+#
+# Revision 1.12  2010-05-04 08:37:42+05:30  Cprogrammer
+# do DK signing before DKIM signing to prevent DK_SYNTAX error
+#
+# Revision 1.11  2009-12-10 19:25:13+05:30  Cprogrammer
+# added RCS id
+#
+# Revision 1.10  2009-12-10 16:41:14+05:30  Cprogrammer
+# continue of message gives DK_SYNTAX_ERR
+#
+# Revision 1.9  2009-05-04 10:30:32+05:30  Cprogrammer
+# fixed argument expected error
+#
+# Revision 1.8  2009-04-21 20:42:44+05:30  Cprogrammer
+# added check for dktest, dkim executables
+#
+# Revision 1.7  2009-04-20 10:06:58+05:30  Cprogrammer
+# added DKSIGNOPTS
+#
+# Revision 1.6  2009-04-19 13:38:24+05:30  Cprogrammer
+# added full set of dkim options
+# replaced indimail/bin/echo with echo 1>&2
+#
+# Revision 1.5  2009-04-06 16:37:50+05:30  Cprogrammer
+# added SIGN_PRACTICE
+# use ietf standard insted of allman so that Yahoo verification does not fail
+#
+# Revision 1.4  2009-04-03 14:39:00+05:30  Cprogrammer
+# added return status
+#
+# Revision 1.3  2009-04-03 08:55:29+05:30  Cprogrammer
+# print error messages to stderr
+#
+# Revision 1.2  2009-04-02 20:36:25+05:30  Cprogrammer
+# added -h option to dktest
+# added -x - option to dkim
+#
+# Revision 1.1  2009-04-02 14:52:27+05:30  Cprogrammer
+# Initial revision
diff -Naur netqmail-1.06.org/dkim.9 netqmail-1.06/dkim.9
--- netqmail-1.06.org/dkim.9	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/dkim.9	2023-02-19 19:43:52.000000000 +0530
@@ -0,0 +1,202 @@
+.TH dkim 8
+.SH NAME
+dkim \- exercise the domainkeys library
+.SH SYNOPSIS
+.B dkim
+.I opts
+
+.I opts
+is a series of getopt-style options.
+
+.SH DESCRIPTION
+.B dkim
+exercises the dkim library. Both signing and verification merely print out the DKIM header.
+They do not keep a copy of the input file. You will need to do something like this:
+
+.EX
+This example verifies using DNS
+
+ (./dkim -s @controldir@/domainkeys/dog </tmp/testmsg; cat /tmp/testmsg)\\
+ | ./dkim -v
+
+This example does not use DNS. Useful for testing
+
+ (./dkim -z 4 -s /tmp/domainkeys/efgh </tmp/mail.txt;cat /tmp/mail.txt) \\
+ | ./dkim -v -T \\
+ "v=DKIM1; k=ed25519; t=y; p=okZUL1G6RmS4IWfCpCX3xjGKhVssoM4KfKpkmW8IERg="
+.EE
+
+.SH OPTIONS
+.TP
+-s \fIprivkey\fR
+.I privkey
+is a path to a file containing a PEM-format private key. Without the 'y'
+option, the base name of the file is used as the selector. Reads the email
+message on stdin. Prints the \fBDKIM-Signature\fR header. You can pass
+multiple \fIkey\fR to generate multiple signatures. For each \fB-s\fR
+option, you can pass \fB-y\fR, \fB-z\fR option before the \fB-s\fR option.
+
+.TP
+-z \fIhash\fR
+1 - sha1, 2 - sha256, 3 - sha1+sha256, 4 - ed25519
+
+.TP
+-y \fIselector\fR
+the selector tag DEFAULT=private
+
+.TP
+-v
+Verifies the email on stdin. Exits with a non-zero exit code and a message to
+stderr if there was a problem with the signature. Always prints a
+.B DKIM-Status:
+header to stdout. This option requires the \fBs\fR._domainkey.\fBd\fR txt record in
+dns (public key). Here \fBs\fR is the selector and \fBd\fR is the domain
+
+.EX
+DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
+d=gmail.com; s=gamma; h=DomainKey-Status:
+To:Subject:Message-Id:Date:From; bh=IarZI4AMTl/vy1jTbPphDcOl4YNS
+POk7Vn0tDdgkbV4=; b=VpIS6XNOLU2WWWlsYGeLB3wMbyFQwkg7F0hr7blu1W8f
+0RRtuyw9igFwY7q7FNaPVlfZ0cfLPh0mRrlExu4V7uQaTP8nnnHO2cAokYbncGS5
+ADU9NbAcpDh+E2YQwzCX
+.EE
+
+.TP
+-l
+include body length tag when signing. Honor body length tag when verifying
+
+.TP
+-q
+include query method tag
+
+.TP
+-t
+include a timestamp tag
+
+.TP
+-f
+issue error if not all message's From headers are in signature
+
+.TP
+-S
+Allow unsigned subject in signature
+
+.TP
+-h
+include Copied Headers. This adds the z= tag with a list of the message's
+original headers and may differ from the headers listed in the h= tag. This
+tag may be used by some mailbox providers in the process of diagnosing a
+verification error. Its value is not well defined.
+
+.TP
+-p \fIssp\fR | \fIadsp\fR
+0 - disable practice (default), 1- SSP, or 2 - ADSP verification
+
+.TP
+-c \fIcanonicalization\fR
+r for relaxed [DEFAULT], s - simple, t relaxed/simple, u - simple/relaxed
+
+.TP
+-d \fIdomain\fR
+the domain tag, if not provided, determined from the return-path/sender/from header
+
+.TP
+-i \fIidentity\fR
+the identity, if not provided it will not be included
+
+.TP
+-x \fIexpire_time\fR
+the expire time in seconds since epoch ( DEFAULT = current time + 604800). If set to - then it will not be included
+
+.TP
+-T \fIselectorRecord\fR
+Bypass DNS and use \fIselectorRecord\fR instead of fetching the record using DNS.
+
+.TP
+-V
+Sets verbose output
+
+.TP
+-H
+this help
+
+.SH Return Value
+When signing, \fBdkim\fR returns 0 on success and non-zero on any failure.
+
+When verifying, you can set the environment variable \fBDKIMVERIFY\fR to
+set the exit code corresponding to the DKIM verifcation status by setting
+\fBDKIMVERIFY\fR environment variable to a desired set of letters. Precisely,
+if you want a dkim return status to generate an error, include that
+letter, where A is the first return status (DKIM_SUCCESS), B is the
+second (DKIM_FINISHED_BODY), etc.  The letter should be uppercase if you
+want a permanent error (exit code 14) to be returned, and lowercase if you want a temporary
+error to be returned (exit code 88). If you omit the letter, \fBdkim\fR will
+not issue any error inspite of DKIM verification failure. It will return
+success.
+
+The complete set of letters with the corresponding return status is given below
+.nf
+A - DKIM_SUCCESS                        - Function executed successfully
+B - DKIM_FINISHED_BODY                  - process result: no more message
+                                          body is needed
+C - DKIM_PARTIAL_SUCCESS                - verify result: at least one
+                                          but not all signatures verified
+D - DKIM_NEUTRAL                        - verify result: no signatures
+                                          verified but message is
+                                          not suspicious
+E - DKIM_SUCCESS_BUT_EXTRA              - signature result: signature
+                                          verified but it did not
+                                          include all of the body
+F - DKIM_3PS_SIGNATURE                  - 3rd-party signature
+G - DKIM_FAIL                           - Function failed to execute
+H - DKIM_BAD_SYNTAX                     - signature error: DKIM-Signature
+                                          could not parse or has bad
+                                          tags/values
+I - DKIM_SIGNATURE_BAD                  - signature error: RSA verify
+                                          failed
+J - DKIM_SIGNATURE_BAD_BUT_TESTING      - signature error: RSA verify
+                                          failed but testing
+K - DKIM_SIGNATURE_EXPIRED              - signature error: x= is old
+L - DKIM_SELECTOR_INVALID               - signature error: selector doesn't
+                                          parse or contains invalid values
+M - DKIM_SELECTOR_GRANULARITY_MISMATCH  - signature error: selector
+                                          g= doesn't match i=
+N - DKIM_SELECTOR_KEY_REVOKED           - signature error: selector
+                                          p= empty
+O - DKIM_SELECTOR_DOMAIN_NAME_TOO_LONG  - signature error: selector domain
+                                          name too long to request
+P - DKIM_SELECTOR_DNS_TEMP_FAILURE      - signature error: temporary dns
+                                          failure requesting selector
+Q - DKIM_SELECTOR_DNS_PERM_FAILURE      - signature error: permanent dns
+                                          failure requesting selector
+R - DKIM_SELECTOR_PUBLIC_KEY_INVALID    - signature error: selector
+                                          p= value invalid or wrong format
+S - DKIM_NO_SIGNATURES                  - no signatures
+T - DKIM_NO_VALID_SIGNATURES            - no valid signatures
+U - DKIM_BODY_HASH_MISMATCH             - sigature verify error: message
+                                          body does not hash to bh value
+V - DKIM_SELECTOR_ALGORITHM_MISMATCH    - signature error: selector
+                                          h= doesn't match signature a=
+W - DKIM_STAT_INCOMPAT                  - signature error: incompatible v=
+X - DKIM_UNSIGNED_FROM                  - signature error: not all message's
+                                          From headers in signature
+.fi
+
+For example, if you want to permanently reject messages that have a
+signature that is expired, include the letter 'K' in the
+.B DKIMVERIFY
+environment variable.  A conservative set of letters is
+.BR FGHIKLMNOQRTUVWjp .
+Reject permanently 3PS, FAILURE, SYNTAX, SIGNATURE_BAD, SIGNATURE_EXPIRED, SELECTOR_INVALID,
+GRANULARITY_MISMATCH, SELECTOR_KEY_REVOKED, DOMAIN_NAME_TOO_LONG, SELECTOR_PUBLIC_KEY_INVALID,
+NO_VALID_SIGNATURES and BODY_HASH_MISMATCH errors, and temporarily SIGNATURE_BAD_BUT_TESTING and DNS_TEMP_FAILURE .
+Add in \fBS\fR if you want to reject messages that do not have a DKIM signature.
+Note that \fBdkim\fR always inserts the \fBDKIM-Status\fR header, so that messages can be
+rejected later at delivery time, or in the mail reader. In that case you need not set
+\fBDKIMVERIFY\fR. 
+
+.SH "SEE ALSO"
+qmail-dkim(8),
+dknewkey(8),
+rfc-4870(5),
+rfc-4871(5)
diff -Naur netqmail-1.06.org/dkimbase.cpp netqmail-1.06/dkimbase.cpp
--- netqmail-1.06.org/dkimbase.cpp	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/dkimbase.cpp	2023-02-05 07:55:45.000000000 +0530
@@ -0,0 +1,317 @@
+/*
+ *  Copyright 2005 Alt-N Technologies, Ltd.
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  This code incorporates intellectual property owned by Yahoo! and licensed
+ *  pursuant to the Yahoo! DomainKeys Patent License Agreement.
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ */
+
+#include "dkim.h"
+#include "dkimbase.h"
+#include <string.h>
+#include <algorithm>
+
+CDKIMBase::CDKIMBase()
+{
+	m_From = NULL;
+	m_Sender = NULL;
+	m_hTag = NULL;
+	m_hTagSize = 0;
+	m_hTagPos = 0;
+	m_Line = NULL;
+	m_LineSize = 0;
+	m_LinePos = 0;
+	m_InHeaders = true;
+}
+
+CDKIMBase::~CDKIMBase()
+{
+	Free(m_Line);
+	Free(m_From);
+	Free(m_Sender);
+	Free(m_hTag);
+}
+
+int
+CDKIMBase::Init(void)
+{
+	return DKIM_SUCCESS;
+}
+
+/*
+ * Alloc - allocate buffer
+ */
+int CDKIMBase::Alloc(char *&szBuffer, int nRequiredSize)
+{
+	szBuffer = new char[nRequiredSize];
+
+	return (szBuffer == NULL) ? DKIM_OUT_OF_MEMORY : DKIM_SUCCESS;
+}
+
+
+/*
+ * ReAlloc - extend buffer if necessary, leaving room for future expansion
+ */
+int CDKIMBase::ReAlloc(char *&szBuffer, int &nBufferSize, int nRequiredSize)
+{
+	if (nRequiredSize > nBufferSize) {
+		char           *
+			newp;
+		int
+			nNewSize = nRequiredSize + BUFFER_ALLOC_INCREMENT;
+
+		if (Alloc(newp, nNewSize) == DKIM_SUCCESS) {
+			if (szBuffer != NULL && nBufferSize > 0) {
+				memcpy(newp, szBuffer, nBufferSize);
+				delete[]szBuffer;
+			}
+			szBuffer = newp;
+			nBufferSize = nNewSize;
+		} else {
+			return DKIM_OUT_OF_MEMORY;	/* memory alloc error! */
+		}
+	}
+	return DKIM_SUCCESS;
+}
+
+/*
+ * Process - split buffers into lines without any CRs or LFs at the end.
+ */
+void CDKIMBase::Free(char *szBuffer)
+{
+	if (szBuffer)
+		delete[]szBuffer;
+}
+
+/*
+ * Process - split buffers into lines without any CRs or LFs at the end.
+ */
+int CDKIMBase::Process(char *szBuffer, int nBufLength, bool bEOF)
+{
+	char           *p = szBuffer;
+	char           *e = szBuffer + nBufLength;
+
+	while (p < e) {
+		if (*p != '\n' && *p != '\r') {
+			if (m_LinePos >= m_LineSize) {
+				int nRet = ReAlloc(m_Line, m_LineSize, m_LinePos + 1);
+				if (nRet != DKIM_SUCCESS)
+							/*
+							 * How to distinguish between
+							 * DKIM_FINISHED_BODY & DKIM_OUT_OF_MEMORY
+							 */
+					return nRet;
+			}
+			m_Line[m_LinePos++] = *p;
+		} else {
+			if (*p == '\r' && p + 1 < e && *(p + 1) == '\n')
+				p++;
+			if (m_InHeaders) {
+				/* process header line */
+				if (m_LinePos == 0) {
+					m_InHeaders = false;
+					int Result = ProcessHeaders();
+					if (Result != DKIM_SUCCESS)
+						return Result;
+				} else {
+					/* append the header to the headers list */
+					if (m_Line[0] != ' ' && m_Line[0] != '\t')
+						HeaderList.push_back(string(m_Line, m_LinePos));
+					else {
+						if (!HeaderList.empty())
+							HeaderList.back().append("\r\n", 2).append(m_Line, m_LinePos);
+						else {
+							/* no header to append to... */
+						}
+					}
+				}
+			} else {
+				/* process body line */
+				int Result = ProcessBody(m_Line, m_LinePos, bEOF);
+				if (Result != DKIM_SUCCESS && Result != DKIM_FINISHED_BODY) {
+					m_LinePos = 0;
+					return Result;
+				}
+			}
+			m_LinePos = 0;
+		}
+		p++;
+	}
+	return DKIM_SUCCESS;
+}
+
+
+/*
+ * ProcessFinal - process leftovers if stopping before the body or mid-line
+ */
+int CDKIMBase::ProcessFinal(void)
+{
+	if (m_LinePos > 0)
+		Process((char *) "\r\n", 2, true);
+	if (m_InHeaders) {
+		m_InHeaders = false;
+		ProcessHeaders();
+		ProcessBody((char *) "", 0, true);
+	}
+	return DKIM_SUCCESS;
+}
+
+
+/*
+ * ProcessHeaders - process the headers (to be implemented by derived class)
+ */
+int CDKIMBase::ProcessHeaders()
+{
+	return DKIM_SUCCESS;
+}
+
+
+/*
+ * ProcessBody - process body line (to be implemented by derived class)
+ */
+int CDKIMBase::ProcessBody(char *szBuffer, int nBufLength, bool bEOF)
+{
+	return DKIM_SUCCESS;
+}
+
+
+/*
+ * RemoveSWSP - remove streaming white space from buffer/string inline
+ */
+struct isswsp {
+	bool
+	operator() (char ch) {
+		return (ch == ' ' || ch == '\t' || ch == '\r' || ch == '\n');
+	}
+};
+
+void CDKIMBase::RemoveSWSP(char *szBuffer)
+{
+	*remove_if(szBuffer, szBuffer + strlen(szBuffer), isswsp()) = '\0';
+}
+
+void CDKIMBase::RemoveSWSP(char *pBuffer, int &nBufLength)
+{
+	nBufLength = remove_if(pBuffer, pBuffer + nBufLength, isswsp()) - pBuffer;
+}
+
+void CDKIMBase::RemoveSWSP(string &sBuffer)
+{
+	sBuffer.erase(remove_if(sBuffer.begin(), sBuffer.end(), isswsp()), sBuffer.end());
+}
+
+
+/*
+ * CompressSWSP - compress streaming white space into single spaces from buffer/string inline
+ */
+void CDKIMBase::CompressSWSP(char *pBuffer, int &nBufLength)
+{
+	char           *pSrc = pBuffer;
+	char           *pDst = pBuffer;
+	char           *pEnd = pBuffer + nBufLength;
+
+	while (pSrc != pEnd) {
+		if (isswsp()(*pSrc)) {
+			do {
+				++pSrc;
+			} while (pSrc != pEnd && isswsp()(*pSrc));
+			if (pSrc == pEnd)
+				break;
+			*pDst++ = ' ';
+		}
+		*pDst++ = *pSrc++;
+	}
+	nBufLength = pDst - pBuffer;
+}
+
+void CDKIMBase::CompressSWSP(string &sBuffer)
+{
+	string::iterator iSrc = sBuffer.begin();
+	string::iterator iDst = sBuffer.begin();
+	string::iterator iEnd = sBuffer.end();
+
+	while (iSrc != iEnd) {
+		if (isswsp()(*iSrc)) {
+			do {
+				++iSrc;
+			} while (iSrc != iEnd && isswsp()(*iSrc));
+
+			if (iSrc == iEnd)
+				break;
+			*iDst++ = ' ';
+		}
+		*iDst++ = *iSrc++;
+	}
+	sBuffer.erase(iDst, iEnd);
+}
+
+/*
+ * RelaxHeader - relax a header field (lower case the name, remove swsp before and after :)
+ *
+ * modified 4/21/06 STB to remove white space before colon
+ */
+string CDKIMBase::RelaxHeader(const string &sHeader)
+{
+	string sTemp = sHeader;
+
+	CompressSWSP(sTemp);
+
+	int cpos = sTemp.find(':');
+	if (cpos == -1) {
+		/* no colon?! */
+	} else {
+		/* lower case the header field name */
+		for (int i = 0; i < cpos; i++) {
+			if (sTemp[i] >= 'A' && sTemp[i] <= 'Z')
+				sTemp[i] += 'a' - 'A';
+		}
+		/* remove the space after the : */
+		if ((unsigned int) (cpos + 1) < sTemp.length() && sTemp[cpos + 1] == ' ')
+			sTemp.erase(cpos + 1, 1);
+		/* remove the space before the : */
+		if (cpos > 0 && sTemp[cpos - 1] == ' ')
+			sTemp.erase(cpos - 1, 1);
+	}
+	return sTemp;
+}
+
+void
+getversion_dkimbase_cpp()
+{
+	static char    *x = (char *) "$Id: dkimbase.cpp,v 1.6 2023-02-04 07:55:12+05:30 Cprogrammer Exp mbhangui $";
+
+	x++;
+}
+
+/*
+ * $Log: dkimbase.cpp,v $
+ * Revision 1.6  2023-02-04 07:55:12+05:30  Cprogrammer
+ * converted comments to traditional C style comments
+ *
+ * Revision 1.5  2019-06-14 21:24:03+05:30  Cprogrammer
+ * BUG - honor body length tag in verification
+ *
+ * Revision 1.4  2017-09-05 10:58:26+05:30  Cprogrammer
+ * removed compiler warnings
+ *
+ * Revision 1.3  2009-03-26 15:10:32+05:30  Cprogrammer
+ * fixed indentation
+ *
+ * Revision 1.2  2009-03-25 08:37:27+05:30  Cprogrammer
+ * fixed indentation
+ *
+ * Revision 1.1  2009-03-21 08:43:08+05:30  Cprogrammer
+ * Initial revision
+ */
diff -Naur netqmail-1.06.org/dkimbase.h netqmail-1.06/dkimbase.h
--- netqmail-1.06.org/dkimbase.h	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/dkimbase.h	2022-12-09 22:58:50.000000000 +0530
@@ -0,0 +1,72 @@
+/*
+ * $Log: dkimbase.h,v $
+ * Revision 1.1  2009-03-21 08:50:18+05:30  Cprogrammer
+ * Initial revision
+ *
+ *
+ *  Copyright 2005 Alt-N Technologies, Ltd. 
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License"); 
+ *  you may not use this file except in compliance with the License. 
+ *  You may obtain a copy of the License at 
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0 
+ *
+ *  This code incorporates intellectual property owned by Yahoo! and licensed 
+ *  pursuant to the Yahoo! DomainKeys Patent License Agreement.
+ *
+ *  Unless required by applicable law or agreed to in writing, software 
+ *  distributed under the License is distributed on an "AS IS" BASIS, 
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ *  See the License for the specific language governing permissions and 
+ *  limitations under the License.
+ *
+ */
+
+#ifndef DKIMBASE_H
+#define DKIMBASE_H
+
+#include <openssl/evp.h>
+#include <openssl/pem.h>
+#include <openssl/err.h>
+
+#define BUFFER_ALLOC_INCREMENT	256
+
+#include <string>
+#include <list>
+
+using namespace std;
+class           CDKIMBase {
+public:
+
+	CDKIMBase();
+	~CDKIMBase();
+
+	int             Init(void);
+	int             Process(char *szBuffer, int nBufLength, bool bEOF);
+	int             ProcessFinal(void);
+	int             Alloc(char *&szBuffer, int nRequiredSize);
+	int             ReAlloc(char *&szBuffer, int &nBufferLength, int nRequiredSize);
+	void            Free(char *szBuffer);
+	static void     RemoveSWSP(char *szBuffer);
+	static void     RemoveSWSP(char *pBuffer, int &nBufLength);
+	static void     RemoveSWSP(string & sBuffer);
+	static void     CompressSWSP(char *pBuffer, int &nBufLength);
+	static void     CompressSWSP(string & sBuffer);
+	static string   RelaxHeader(const string & sHeader);
+	virtual int     ProcessHeaders(void);
+	virtual int     ProcessBody(char *szBuffer, int nBufLength, bool bEOF);
+
+protected:
+	char           *m_From;
+	char           *m_Sender;
+	char           *m_hTag;
+	int             m_hTagSize;
+	int             m_hTagPos;
+	char           *m_Line;
+	int             m_LineSize;
+	int             m_LinePos;
+	bool            m_InHeaders;
+	                list < string > HeaderList;
+};
+#endif	/*- DKIMBASE_H */
diff -Naur netqmail-1.06.org/dkim.c netqmail-1.06/dkim.c
--- netqmail-1.06.org/dkim.c	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/dkim.c	2023-02-19 08:03:59.000000000 +0530
@@ -0,0 +1,994 @@
+/*
+ * This code incorporates intellectual property owned by Yahoo! and licensed
+ * pursuant to the Yahoo! DomainKeys Patent License Agreement.
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+/*
+ * (cat /tmp/mail.txt|./dkim -z 2 -y private \
+ * -s /var/indimail/control/domainkeys/private ;cat /tmp/mail.txt )|./dkim -v
+ */
+#if 0
+#ifndef __cplusplus
+#error A C++ compiler is required!
+#endif
+#endif
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <fcntl.h>
+#include <errno.h>
+#include <unistd.h>
+#include <string.h>
+#include <time.h>
+#include <stdlib.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include "dkim.h"
+#include "dns_text.h"
+
+#ifdef HAVE_OPENSSL_EVP_H
+#include <openssl/evp.h>
+#define DKIM_MALLOC(s)     OPENSSL_malloc(s)
+#define DKIM_REALLOC(s, n) OPENSSL_realloc((s), (n))
+#define DKIM_MFREE(s)      OPENSSL_free(s); s = NULL;
+#else
+#define DKIM_MALLOC(s)     malloc(s)
+#define DKIM_MFREE(s)      free(s); s = NULL;
+#endif
+#ifndef TMPDIR
+#define TMPDIR "/tmp"
+#endif
+
+static char   *callbackdata;
+const char    *defaultkey = "private";
+char           *program;
+typedef struct
+{
+	char           *fn;
+	char           *selector;
+	int             hash;
+	char           *key;
+	int             len;
+} PRIVKEY;
+
+void
+usage()
+{
+#ifdef HAVE_EVP_SHA256
+	fprintf(stderr, "usage: %s [-lqthvVHS] [-p <0|1|2>] [-c <r|s|t|u>] [-d domain]\n%s\n", program,
+			"\t[-i you@domain] [-x expire_time] [-z hash] [-y selector] -s privkeyfile [-T dnstext]");
+#else
+	fprintf(stderr, "usage: %s [-lqthvVHS] [-p <0|1|2>] [-c <r|s|t|u>] [-d domain]\n%s\n", program,
+			"\t[-i you@domain] [-x expire_time] [-y selector] -s privkeyfile [-T dnstext]");
+#endif
+	fprintf(stderr, "l                    include body length tag\n");
+	fprintf(stderr, "q                    include query method tag\n");
+	fprintf(stderr, "t                    include a timestamp tag\n");
+	fprintf(stderr, "h                    include Copied Headers. This adds the z= tag containing\n");
+	fprintf(stderr, "                     a copy of the message's original headers.\n");
+	fprintf(stderr, "f                    allow Unsigned From (default is to reject if From field is not signed)\n");
+	fprintf(stderr, "S                    allow Unsigned Subject (default is to reject if Subject field is not signed)\n");
+	fprintf(stderr, "v                    verify the message\n");
+	fprintf(stderr, "p <ssp|adsp>         0 - disable practice (default), 1- SSP, or 2 - ADSP verification\n");
+	fprintf(stderr, "c <canonicalization> r for relaxed [DEFAULT], s - simple, t relaxed/simple, u - simple/relaxed\n");
+	fprintf(stderr, "d <domain>           the domain tag, if not provided, determined from the sender/from header\n");
+	fprintf(stderr, "i <identity>         the identity, if not provided it will not be included\n");
+	fprintf(stderr, "x <expire_time>      the expire time in seconds since epoch ( DEFAULT = current time + 604800)\n");
+	fprintf(stderr, "                     if set to - then it will not be included\n");
+#ifdef HAVE_EVP_SHA256
+	fprintf(stderr, "z <hash>             1 - sha1, 2 - sha256, 3 - sha1+sha256, 4 - ed25519\n");
+#endif
+	fprintf(stderr, "y <selector>         the selector tag DEFAULT=basename of privkeyfile\n");
+	fprintf(stderr, "s <privkeyfile>      sign the message using the private key in privkeyfile\n");
+	fprintf(stderr, "T DNSText            Use DNSText as domainkey text record instead of using DNS\n");
+	fprintf(stderr, "V                    set verbose mode\n");
+	fprintf(stderr, "H                    this help\n");
+	exit(1);
+}
+
+int DKIM_CALL
+SignThisHeader(const char *szHeader)
+{
+	if ((!strncasecmp(szHeader, "X-", 2) && strncasecmp(szHeader, "X-Mailer:", 9))
+			|| !strncasecmp(szHeader, "Received:", 9)
+			|| !strncasecmp(szHeader, "Authentication-Results:", 23)
+			|| !strncasecmp(szHeader, "DKIM-Signature:", 15)
+			|| !strncasecmp(szHeader, "DomainKey-Signature:", 20)
+			|| !strncasecmp(szHeader, "Return-Path:", 12))
+		return 0;
+	return 1;
+}
+
+unsigned int str_chr(char *s, int c)
+{
+	char            ch;
+	char           *t;
+
+	ch = c;
+	t = s;
+	for (;;) {
+		if (!*t)
+			break;
+		if (*t == ch)
+			break;
+		++t;
+		if (!*t)
+			break;
+		if (*t == ch)
+			break;
+		++t;
+		if (!*t)
+			break;
+		if (*t == ch)
+			break;
+		++t;
+		if (!*t)
+			break;
+		if (*t == ch)
+			break;
+		++t;
+	}
+	return t - s;
+}
+
+const char *dkim_error_str(int ret, int flag)
+{
+	switch (ret)
+	{
+	case DKIM_SUCCESS:			/*- 0 */ /*- A */
+		return flag ? "good        " : NULL;
+	case DKIM_FAIL:				/*- -1 */ /*- F */
+		return flag ? "bad         " : "DKIM Signature verification failed";
+	case DKIM_FINISHED_BODY:	/*- 1 process result: no more message body is needed */
+		return "process result: no more message body is needed";
+	case DKIM_PARTIAL_SUCCESS:	/*- 2 verify result: at least one but not all signatures verified */
+		return "verify result: at least one but not all signatures verified";
+	case DKIM_NEUTRAL:			/*- 3 verify result: no signatures verified but message is not suspicious */
+		return "verify result: no signatures verified but message is not suspicious";
+	case DKIM_SUCCESS_BUT_EXTRA:/*- 4 signature result: signature verified but it did not include all of the body */
+		return "signature result: signature verified but it did not include all of the body";
+	case DKIM_3PS_SIGNATURE:
+		break;
+	case DKIM_BAD_SYNTAX:		/*- -2 */ /*- G */
+		return "signature error: DKIM-Signature could not parse or has bad tags/values";
+	case DKIM_SIGNATURE_BAD:	/*- -3 */
+#if OPENSSL_VERSION_NUMBER >= 0x10101000L
+		return "signature error: RSA/ED25519 verify failed";
+#else
+		return "signature error: RSA verify failed";
+#endif
+	case DKIM_SIGNATURE_BAD_BUT_TESTING:
+#if OPENSSL_VERSION_NUMBER >= 0x10101000L
+		return "signature error: RSA/ED25519 verify failed but testing";
+#else
+		return "signature error: RSA verify failed but testing";
+#endif
+	case DKIM_SIGNATURE_EXPIRED:
+		return "signature error: x= is old";
+	case DKIM_SELECTOR_INVALID:
+		return "signature error: selector doesn't parse or contains invalid values";
+	case DKIM_SELECTOR_GRANULARITY_MISMATCH:
+		return "signature error: selector g= doesn't match i=";
+	case DKIM_SELECTOR_KEY_REVOKED:
+		return "signature error: selector p= empty";
+	case DKIM_SELECTOR_DOMAIN_NAME_TOO_LONG:
+		return "signature error: selector domain name too long to request";
+	case DKIM_SELECTOR_DNS_TEMP_FAILURE:
+		return "signature error: temporary dns failure requesting selector";
+	case DKIM_SELECTOR_DNS_PERM_FAILURE:
+		return "signature error: permanent dns failure requesting selector";
+	case DKIM_SELECTOR_PUBLIC_KEY_INVALID:
+		return "signature error: selector p= value invalid or wrong format";
+	case DKIM_NO_SIGNATURES:
+		return "no signatures";
+	case DKIM_NO_VALID_SIGNATURES:
+		return "no valid signatures";
+	case DKIM_BODY_HASH_MISMATCH:
+		return "signature verify error: message body does not hash to bh value";
+	case DKIM_SELECTOR_ALGORITHM_MISMATCH:
+		return "signature error: selector h= doesn't match signature a=";
+	case DKIM_STAT_INCOMPAT:
+		return "signature error: incompatible v=";
+	case DKIM_UNSIGNED_FROM:
+		return "signature error: not all message's From headers in signature";
+	case DKIM_OUT_OF_MEMORY:
+		return "memory allocation failed";
+	case DKIM_INVALID_CONTEXT:
+		return "DKIMContext structure invalid for this operation";
+	case DKIM_NO_SENDER:
+		return "signing error: Could not find From: or Sender: header in message";
+	case DKIM_BAD_PRIVATE_KEY:
+		return "signing error: Could not parse private key";
+	case DKIM_BUFFER_TOO_SMALL:
+		return "signing error: Buffer passed in is not large enough";
+	case DKIM_EVP_SIGN_FAILURE:
+		return "signing error: evp signing failure";
+	case DKIM_EVP_DIGEST_FAILURE:
+		return "signing error: evp digest failure";
+	}
+	return "unknown error";
+}
+
+void
+dkim_error(int e)
+{
+	const char     *ptr;
+	
+	if ((ptr = dkim_error_str(e, 0)))
+		fprintf(stderr, "%s\n", ptr);
+	return;
+}
+
+/*
+ * Allows you to add the headers contain the results and DKIM ADSP
+ */
+void writeHeader(int ret, int resDKIMSSP, int resDKIMADSP, int useSSP, int useADSP )
+{
+	char           *dkimStatus, *sspStatus, *adspStatus;
+
+	sspStatus = adspStatus = (char *) "";
+	dkimStatus = (char *) dkim_error_str(ret, 1);
+	if (useSSP && resDKIMSSP != -1) {
+		switch(resDKIMSSP)
+		{
+			case DKIM_SSP_ALL:
+				sspStatus = (char *) "all;";
+				break;
+			case DKIM_SSP_STRICT:
+				sspStatus = (char *) "strict;";
+				break;
+			case DKIM_SSP_SCOPE:
+				sspStatus = (char *) "out of scope;";
+				break;
+			case DKIM_SSP_TEMPFAIL:
+				sspStatus = (char *) "temporary failure;";
+				break;
+			case DKIM_SSP_UNKNOWN:
+			default:
+				sspStatus = (char *) "unknown;";
+				break;
+		}
+	}
+	if (useADSP && resDKIMADSP != -1) {
+		switch(resDKIMADSP)
+		{
+			case DKIM_ADSP_ALL:
+				adspStatus = (char *) "all;";
+				break;
+			case DKIM_ADSP_DISCARDABLE:
+				adspStatus = (char *) "discardable;";
+				break;
+			case DKIM_ADSP_SCOPE:
+				adspStatus = (char *) "out of scope;";
+				break;
+			case DKIM_ADSP_TEMPFAIL:
+				adspStatus = (char *) "temporary failure;";
+				break;
+			case DKIM_ADSP_UNKNOWN:
+			default:
+				adspStatus = (char *) "unknown;";
+				break;
+		}
+	}
+	printf("DKIM-Status: %s\n", dkimStatus);
+	if (useSSP && *sspStatus)
+		printf("X-DKIM-SSP: %s\n", sspStatus);
+	if (useADSP && *adspStatus)
+		printf("X-DKIM-ADSP: %s\n", adspStatus);
+}
+
+int
+ParseTagValues(char *list, char *letters[], char *values[])
+{
+	char           *tmp, *ptr, *key;
+	int             i;
+
+	/*- start with all args unset */
+	for (i = 0; letters[i]; i++)
+		values[i] = 0;
+	key = 0;
+	for(ptr = list;*ptr;) {
+		if ((*ptr == ' ') || (*ptr == '\t') || (*ptr == '\r') || (*ptr == '\n')) /*- FWS */
+			*ptr++ = 0;
+		if (!key)
+			key = ptr;
+		if (*ptr == '=') {
+			*ptr = 0;
+			for (i = 0;letters[i];i++) {
+				if (!strcmp(letters[i], key)) {
+					ptr++;
+					for (;*ptr;) {
+						if ((*ptr == ' ') || (*ptr == '\t') || (*ptr == '\r') || (*ptr == '\n')) {
+							ptr++;
+							continue;
+						}
+						break;
+					}
+					values[i] = ptr;
+					for(;*ptr && *ptr != ';';ptr++);
+					tmp = ptr;
+					if (*ptr)
+						*ptr++ = 0;
+					for(;tmp != values[i];tmp--) /*- RFC 4871 3.2 */ {
+						if ((*tmp == ' ') || (*tmp == '\t') || (*tmp == '\r') || (*tmp == '\n')) {
+							*tmp = 0;
+							continue;
+						}
+						break;
+					}
+					key = 0;
+					break;
+				}
+			}
+		} else
+			ptr++;
+	}
+	return (0);
+}
+
+int
+GetSSP(char *domain, int *bTesting)
+{
+	char           *query, *results;
+	char           *tags[] = { (char *) "dkim", (char *) "t", (char *) 0};
+	char           *values[2];
+	int             bIsParentSSP = 0, iSSP = DKIM_SSP_UNKNOWN;
+
+	*bTesting = 0;
+	if (!(query = (char *) DKIM_MALLOC(strlen("_ssp._domainkey.") + strlen(domain) + 1))) {
+		fprintf(stderr, "malloc: %ld: %s\n", strlen("_ssp._domainkey.") + strlen(domain) + 1,
+			strerror(errno));
+		exit(1);
+	}
+	sprintf(query, "_ssp._domainkey.%s", domain);
+	results = dns_text(query);
+	DKIM_MFREE(query);
+	if (!strcmp(results, "e=temp;")) {
+		DKIM_MFREE(results);
+		return DKIM_SSP_TEMPFAIL;
+	} else
+	if (!strcmp(results, "e=perm;")) {
+		DKIM_MFREE(results);
+		results = dns_text(domain);
+		if (!strcmp(results, "e=temp;")) {
+			DKIM_MFREE(results);
+			return DKIM_SSP_TEMPFAIL;
+		} else
+		if (!strcmp(results, "e=perm;")) {
+			DKIM_MFREE(results);
+			return DKIM_SSP_SCOPE;
+		}
+		bIsParentSSP = 1;
+	}
+	if (!ParseTagValues(results, tags, values)) {
+		DKIM_MFREE(results);
+		return DKIM_SSP_UNKNOWN;
+	}
+	DKIM_MFREE(results);
+	if (values[0] != NULL) {
+		if (strcasecmp(values[0], "all") == 0)
+			iSSP = DKIM_SSP_ALL;
+		else
+		if (strcasecmp(values[0], "strict") == 0)
+			iSSP = DKIM_SSP_STRICT;
+	}
+	/* flags */
+	if (values[1] != NULL) {
+		char           *s, *p;
+		for (p = values[1], s = values[1]; *p; p++) {
+			if (*p == '|')
+				*p = 0;
+			else
+				continue;
+			if (!strcmp(s, "y"))
+				*bTesting = 1;
+			else
+			if (!strcmp(s, "s")) {
+				if (bIsParentSSP) {
+					/*
+					 * this is a parent's SSP record that should not apply to subdomains
+					 * the message is non-suspicious
+					 */
+					*bTesting = 0;
+					return (DKIM_SSP_UNKNOWN);
+				}
+			}
+			s = p + 1;
+		}
+	}
+	return iSSP; /*- No ADSP Record */
+}
+
+int
+GetADSP(char *domain)
+{
+	char           *query, *results;
+	char           *tags[] = {(char *) "dkim", (char *) 0};
+	char           *values[1];
+
+	results = dns_text(domain);
+	if (!strcmp(results, "e=perm;")) {
+		DKIM_MFREE(results);
+		return DKIM_ADSP_SCOPE;
+	} else
+	if (!strcmp(results, "e=temp;")) {
+		DKIM_MFREE(results);
+		return DKIM_ADSP_TEMPFAIL;
+	}
+	if (!(query = (char *) DKIM_MALLOC(strlen((char *) "_adsp._domainkey.") + strlen(domain) + 1))) {
+		fprintf(stderr, "malloc: %ld: %s\n", strlen("_adsp._domainkey.") + strlen(domain) + 1,
+			strerror(errno));
+		exit(1);
+	}
+	sprintf(query, "_adsp._domainkey.%s", domain);
+	results = dns_text(query);
+	DKIM_MFREE(query);
+	if (!strcmp(results, "e=perm;")) {
+		DKIM_MFREE(results);
+		return DKIM_ADSP_SCOPE;
+	} else
+	if (!strcmp(results, "e=temp;")) {
+		DKIM_MFREE(results);
+		return DKIM_ADSP_TEMPFAIL;
+	}
+	if (!ParseTagValues(results, tags, values)) {
+		DKIM_MFREE(results);
+		return DKIM_ADSP_UNKNOWN;
+	}
+	DKIM_MFREE(results);
+	if (values[0] != NULL) {
+		if (strcasecmp(values[0], "all") == 0)
+			return (DKIM_ADSP_ALL);
+		else
+		if (strcasecmp(values[0], "discardable") == 0)
+			return (DKIM_ADSP_DISCARDABLE);
+	}
+	return DKIM_ADSP_UNKNOWN; /*- No ADSP Record */
+}
+
+int
+dns_bypass(const char *domain, char *buffer, int maxlen)
+{
+	strcpy(buffer, callbackdata);
+	return 0;
+}
+
+int
+mktempfile(int seekfd)
+{
+	char            filename[sizeof (TMPDIR) + 19] = TMPDIR "/dkim.XXXXXX";
+	char            buffer[4096];
+	int             fd, ret;
+
+	if (lseek(seekfd, 0, SEEK_SET) == 0)
+		return 0;
+	if ((fd = mkstemp(filename)) == -1)
+		return -1;
+	if (unlink(filename))
+		return -1;
+	for (;;) {
+		if ((ret = read(0, buffer, sizeof(buffer) - 1)) == -1) {
+			close(fd);
+			return -1;
+		} else
+		if (!ret)
+			break;
+		if (write(fd, buffer, ret) != ret) {
+			close(fd);
+			return -1;
+		}
+	}
+	if (fd != seekfd) {
+		if (dup2(fd, seekfd) == -1) {
+			close(fd);
+			return -1;
+		}
+		close(fd);
+	}
+	if (lseek(seekfd, 0, SEEK_SET) == -1) {
+		close(seekfd);
+		return -1;
+	}
+	return (0);
+}
+
+int
+main(int argc, char **argv)
+{
+	PRIVKEY        *PrivKey = NULL;
+	int             PrivKeyLen = 0, len, nHash = 0;
+	char           *pSig = NULL, *dkimverify;
+	int             i, ret, ch, fd, verbose = 0;
+	int             bSign = 1, nSigCount = 0, useSSP = 0, useADSP = 0, accept3ps = 0;
+	int             sCount = 0, sSize = 0, resDKIMSSP = -1, resDKIMADSP = -1;
+	int             nAllowUnsignedFromHeaders = 0;
+	int             nAllowUnsignedSubject = 1;
+	char           *ptr, *selector = NULL;
+	char            buffer[4096], szPolicy[512];
+	time_t          t;
+	struct stat     statbuf;
+	DKIMContext     ctxt;
+	DKIMSignOptions   sopts = { 0 };
+	DKIMVerifyOptions vopts = { 0 };
+	DKIMVerifyDetails *pDetails;
+
+	if (!(program = strrchr(argv[0], '/')))
+		program = argv[0];
+	else
+		program++;
+	t = time(0);
+#ifdef HAVE_EVP_SHA256
+	sopts.nHash = DKIM_HASH_SHA1_AND_SHA256;
+#else
+	sopts.nHash = DKIM_HASH_SHA1;
+#endif
+	sopts.nCanon = DKIM_SIGN_RELAXED;
+	sopts.nIncludeBodyLengthTag = 0;
+	sopts.nIncludeQueryMethod = 0;
+	sopts.nIncludeTimeStamp = 0;
+	sopts.expireTime = t + 604800;	/* expires in 1 week */
+	sopts.nIncludeCopiedHeaders = 0;
+	strcpy(sopts.szRequiredHeaders, "NonExistent");
+	sopts.pfnHeaderCallback = SignThisHeader;
+	while (1) {
+		if ((ch = getopt(argc, argv, "lqtfhHSvVp:b:c:d:i:s:x:y:z:T:")) == -1)
+			break;
+		switch (ch)
+		{
+		case 'l': /*- body length tag */
+			vopts.nHonorBodyLengthTag = 1;
+			sopts.nIncludeBodyLengthTag = 1;
+			break;
+		case 'q': /*- query method tag */
+			sopts.nIncludeQueryMethod = 1;
+			break;
+		case 'S':
+			nAllowUnsignedSubject = 0;
+			break;
+		case 'f':
+			nAllowUnsignedFromHeaders = 1;
+		case 't': /*- timestamp tag */
+			sopts.nIncludeTimeStamp = 1;
+			break;
+		case 'h':
+			sopts.nIncludeCopiedHeaders = 1;
+			break;
+		case 'H':
+			usage();
+			break;
+		case 'v': /*- verify */
+			bSign = 0;
+			break;
+		case 'V': /*- verbose */
+			vopts.verbose = 1;
+			sopts.verbose = 1;
+			verbose = 1;
+			break;
+		case 'p':
+			switch(*optarg)
+			{
+			case '1':
+				accept3ps = 1;
+				useSSP = 1;
+				useADSP = 0;
+				break;
+			case '2':
+				accept3ps = 1;
+				useSSP = 0;
+				useADSP = 1;
+				break;
+			case '3':
+				accept3ps = 1;
+				useSSP = 0;
+				useADSP = 0;
+				break;
+			case '0':
+				accept3ps = 0;
+				useSSP = 0;
+				useADSP = 0;
+				break;
+			default:
+				fprintf(stderr, "%s: unrecognized practice %c.\n", program, *optarg);
+				return (1);
+			}
+			break;
+		case 'b': /*- dummy option kept for backward compatibility */
+			break;
+		case 'c':
+			switch (*optarg)
+			{
+			case 'r':
+				sopts.nCanon = DKIM_SIGN_RELAXED;
+				break;
+			case 's':
+				sopts.nCanon = DKIM_SIGN_SIMPLE;
+				break;
+			case 't':
+				sopts.nCanon = DKIM_SIGN_RELAXED_SIMPLE;
+				break;
+			case 'u':
+				sopts.nCanon = DKIM_SIGN_SIMPLE_RELAXED;
+				break;
+			default:
+				fprintf(stderr, "%s: unrecognized canonicalization.\n", program);
+				return (1);
+			}
+			break;
+		case 'd':
+			strncpy(sopts.szDomain, optarg, sizeof (sopts.szDomain) - 1);
+			break;
+		case 'i':	/*- identity */
+			if (*optarg == '-')
+				sopts.szIdentity[0] = '\0';
+			else
+				strncpy(sopts.szIdentity, optarg, sizeof (sopts.szIdentity) - 1);
+			break;
+		case 'y':
+			selector = optarg;
+			break;
+		case 'z': /*- sign w/ sha1, sha256 or both */
+			switch (*optarg)
+			{
+			case '1':
+				nHash = DKIM_HASH_SHA1;
+				break;
+#ifdef HAVE_EVP_SHA256
+			case '2':
+				nHash = DKIM_HASH_SHA256;
+				break;
+			case '3':
+				nHash = DKIM_HASH_SHA1_AND_SHA256;
+				break;
+#endif
+#if OPENSSL_VERSION_NUMBER >= 0x10101000L
+			case '4':
+				nHash = DKIM_HASH_ED25519;
+				break;
+#endif
+			default:
+				fprintf(stderr, "%s: unrecognized hash.\n", program);
+				return (1);
+			}
+			break;
+		case 'x': /*- expire time */
+			if (*optarg == '-')
+				sopts.expireTime = 0;
+			else
+				sopts.expireTime = t + atoi(optarg);
+			break;
+		case 's': /*- sign */
+			if (!PrivKeyLen)
+				PrivKey = (PRIVKEY *) DKIM_MALLOC(sizeof(PRIVKEY));
+			else
+				PrivKey = (PRIVKEY *) DKIM_REALLOC(PrivKey, sizeof(PRIVKEY) * (PrivKeyLen + 1));
+			if (!PrivKey)
+				fprintf(stderr, "malloc: %ld bytes: %s\n", sizeof(PRIVKEY) * PrivKeyLen, strerror(errno));
+
+			if ((fd = open(optarg, O_RDONLY)) == -1) {
+				fprintf(stderr, "%s: %s\n", optarg, strerror(errno));
+				return (1);
+			}
+			if (fstat(fd, &statbuf) == -1) {
+				fprintf(stderr, "fstat: %s: %s\n", optarg, strerror(errno));
+				return (1);
+			}
+			if (!(ptr = (char *) DKIM_MALLOC(sizeof(char) * ((len = statbuf.st_size) + 1)))) {
+#ifdef DARWIN
+				fprintf(stderr, "malloc: %lld bytes: %s\n", statbuf.st_size + 1, strerror(errno));
+#else
+				fprintf(stderr, "malloc: %ld bytes: %s\n", statbuf.st_size + 1, strerror(errno));
+#endif
+				return (1);
+			}
+			if (read(fd, ptr, len) != len) {
+				fprintf(stderr, "%s: read: %s\n", strerror(errno), program);
+				return (1);
+			}
+			close(fd);
+			ptr[len] = '\0';
+			PrivKey[PrivKeyLen].fn = optarg;
+			PrivKey[PrivKeyLen].key = ptr;
+			PrivKey[PrivKeyLen].len = len;
+			if (selector)
+				PrivKey[PrivKeyLen].selector = selector;
+			else
+			if ((ptr = strrchr(optarg, '/'))) {
+				ptr++;
+				PrivKey[PrivKeyLen].selector = ptr;
+			} else
+				PrivKey[PrivKeyLen].selector = (char *) defaultkey;
+			PrivKey[PrivKeyLen].hash = nHash ? nHash : DKIM_HASH_SHA256;
+			PrivKeyLen++;
+			bSign = 1;
+			selector = NULL;
+			nHash = 0;
+			break;
+		case 'T':
+			callbackdata = optarg;
+			break;
+		} /*- switch (ch) */
+	}
+	if (bSign) { /*- sign */
+		if (!PrivKey) {
+			fprintf(stderr, "Private Key(s) not provided\n");
+			usage();
+			return (1);
+		}
+		if (PrivKeyLen > 1 && mktempfile(0)) {
+			fprintf(stderr, "unable to make descriptor 0 seekable\n");
+			return 1;
+		}
+		for (i = 0; i < PrivKeyLen; i++) {
+			strcpy(sopts.szSelector, PrivKey[i].selector);
+			sopts.nHash = PrivKey[i].hash;
+			if (DKIMSignInit(&ctxt, &sopts) != DKIM_SUCCESS) {
+				fprintf(stderr, "DKIMSignInit: failed to initialize signature %s\n", PrivKey[i].fn);
+				return (1);
+			}
+			/* process mail on descriptor 0 */
+			if (PrivKeyLen > 1 && lseek(0, 0, SEEK_SET) == -1) {
+				fprintf(stderr, "lseek: descriptor 0: %s\n", strerror(errno));
+				return 1;
+			}
+			for (;;) {
+				if ((ret = read(0, buffer, sizeof(buffer) - 1)) == -1) {
+					fprintf(stderr, "read: %s\n", strerror(errno));
+					DKIMSignFree(&ctxt);
+					return (1);
+				} else
+				if (!ret)
+					break;
+				buffer[ret] = 0;
+				if ((ret = DKIMSignProcess(&ctxt, buffer, ret)) != DKIM_SUCCESS) {
+					dkim_error(ret);
+					DKIMSignFree(&ctxt);
+					return (1);
+				}
+			}
+			if ((ret = DKIMSignGetSig2(&ctxt, PrivKey[i].key, &pSig)) != DKIM_SUCCESS) {
+				dkim_error(ret);
+				DKIMSignFree(&ctxt);
+				return (1);
+			}
+			if (pSig) {
+				fwrite(pSig, 1, strlen(pSig), stdout);
+				fwrite("\n", 1, 1, stdout);
+			}
+			DKIMSignFree(&ctxt);
+		}
+		return 0;
+	} else { /*- verify */
+		if (useADSP)
+			vopts.nCheckPractices = useADSP;
+		else
+		if (useSSP)
+			vopts.nCheckPractices = useSSP;
+		else
+			vopts.nCheckPractices = 0;
+		vopts.nAccept3ps = accept3ps;
+		if (callbackdata)
+			vopts.pfnSelectorCallback = dns_bypass; /*- SelectorCallback; */
+		else
+			vopts.pfnSelectorCallback = NULL; /*- SelectorCallback; */
+		vopts.nAllowUnsignedFromHeaders = nAllowUnsignedFromHeaders;
+		vopts.nSubjectRequired = nAllowUnsignedSubject;
+		DKIMVerifyInit(&ctxt, &vopts); /*- this is always successful */
+		for (;;) {
+			if ((i = read(0, buffer, sizeof(buffer) - 1)) == -1) {
+				fprintf(stderr, "read: %s\n", strerror(errno));
+				DKIMVerifyFree(&ctxt);
+				return (1);
+			} else
+			if (!i)
+				break;
+			if ((ret = DKIMVerifyProcess(&ctxt, buffer, i)))
+				dkim_error(ret);
+			if (ret > 0 && ret < DKIM_FINISHED_BODY)
+				ret = DKIM_FAIL;
+			if (ret)
+				break;
+		}
+		if (!ret) {
+			ret = DKIMVerifyResults(&ctxt, &sCount, &sSize);
+			if (ret != DKIM_SUCCESS && ret != DKIM_3PS_SIGNATURE && ret != DKIM_NEUTRAL)
+				dkim_error(ret);
+			if ((ret = DKIMVerifyGetDetails(&ctxt, &nSigCount, &pDetails, szPolicy)) != DKIM_SUCCESS)
+				dkim_error(ret);
+			else {
+				for (ret = DKIM_FAIL, i = 0; i < nSigCount; i++) {
+					if (verbose)
+						fprintf(stderr, "Signature # %02d: ", i + 1);
+					if (pDetails[i].nResult >= 0) {
+						ret = 0;
+						if (verbose)
+							fprintf(stderr, "Success\n");
+						continue;
+					} else {
+						if (ret == DKIM_FAIL)
+							ret = pDetails[i].nResult;
+						if (verbose)
+							fprintf(stderr, "Failure %d\n", pDetails[i].nResult);
+					}
+				}
+				if (!nSigCount)
+					ret = DKIM_NO_SIGNATURES;
+			}
+		}
+		if (ret < 0 || ret == DKIM_3PS_SIGNATURE) {
+			if (useADSP) {
+				char           *domain;
+	
+				if ((domain = DKIMVerifyGetDomain(&ctxt)))
+					resDKIMADSP = GetADSP(domain);
+				if (sCount > 0) {
+					if (resDKIMADSP == DKIM_ADSP_UNKNOWN || resDKIMADSP == DKIM_ADSP_ALL)
+						ret = (sCount == sSize ? DKIM_SUCCESS : DKIM_PARTIAL_SUCCESS);
+				}
+				/* if the message should be signed, return fail */
+				if (resDKIMADSP == DKIM_ADSP_DISCARDABLE)
+					ret = DKIM_FAIL;
+				ret = DKIM_NEUTRAL;
+			} else
+			if (useSSP) {
+				int             bTestingPractices = 0;
+				char           *domain;
+
+				if ((domain = DKIMVerifyGetDomain(&ctxt)))
+					resDKIMSSP = GetSSP(domain, &bTestingPractices);
+				if (sCount > 0) {
+					if ((resDKIMSSP == DKIM_SSP_UNKNOWN || resDKIMSSP == DKIM_SSP_ALL))
+						ret = (sCount == sSize ? DKIM_SUCCESS : DKIM_PARTIAL_SUCCESS);
+				}
+				/* if the SSP is testing, return neutral */
+				if (bTestingPractices)
+					return(DKIM_NEUTRAL);
+				/* if the message should be signed, return fail */
+				if (resDKIMSSP == DKIM_SSP_ALL || resDKIMSSP == DKIM_SSP_STRICT)
+					return(DKIM_FAIL);
+				ret = DKIM_NEUTRAL;
+			}
+		}
+		DKIMVerifyFree(&ctxt);
+		writeHeader(ret, resDKIMSSP, resDKIMADSP, useSSP, useADSP);
+		if ((dkimverify = getenv("DKIMVERIFY"))) {
+			if (ret < 0) {
+				if (dkimverify[str_chr(dkimverify, 'F' - ret)])
+					ret = 14; /*- return permanent error */
+				else
+				if (dkimverify[str_chr(dkimverify, 'f' - ret)])
+					ret = 88; /*- return temporary error */
+				else
+					ret = 0;
+			} else {
+				if (dkimverify[str_chr(dkimverify, 'A' + ret)])
+					ret = 14; /*- return permanent error */
+				else
+				if (dkimverify[str_chr(dkimverify, 'a' + ret)])
+					ret = 88; /*- return temporary error */
+				else
+					ret = 0;
+			}
+		}
+		return (ret);
+	}
+	/*- Not Reached */
+	_exit(0);
+}
+
+void
+getversion_dkim_c()
+{
+	static char    *x = (char *) "$Id: dkim.cpp,v 1.33 2023-02-12 08:07:00+05:30 Cprogrammer Exp mbhangui $";
+
+	x++;
+}
+
+/*
+ * $Log: dkim.cpp,v $
+ * Revision 1.33  2023-02-12 08:07:00+05:30  Cprogrammer
+ * added dkim_error_str function to return DKIM error
+ *
+ * Revision 1.32  2023-02-04 11:56:10+05:30  Cprogrammer
+ * generate DKIM-Signature for each -s option
+ *
+ * Revision 1.31  2023-01-30 10:41:09+05:30  Cprogrammer
+ * set verbose flag for dkimvery, dkimsign methods
+ *
+ * Revision 1.30  2023-01-27 19:38:28+05:30  Cprogrammer
+ * fixed openssl version for ed25519
+ *
+ * Revision 1.29  2023-01-27 17:11:41+05:30  Cprogrammer
+ * removed -b option. Option kept for backward compatibility
+ * added -z 4 for setting Ed25519 DKIM signature
+ *
+ * Revision 1.28  2022-11-27 09:41:38+05:30  Cprogrammer
+ * updated help message for -h option
+ *
+ * Revision 1.27  2021-07-20 23:20:09+05:30  Cprogrammer
+ * removed use of register
+ *
+ * Revision 1.26  2020-10-01 14:14:34+05:30  Cprogrammer
+ * Darwin Port
+ *
+ * Revision 1.25  2020-06-08 23:16:27+05:30  Cprogrammer
+ * quench compiler warnings
+ *
+ * Revision 1.24  2019-06-24 23:14:33+05:30  Cprogrammer
+ * fixed return value interpretation of DKIMVERIFY
+ *
+ * Revision 1.23  2019-06-14 21:24:59+05:30  Cprogrammer
+ * BUG - honor body length tag in verification
+ *
+ * Revision 1.22  2019-01-13 10:10:27+05:30  Cprogrammer
+ * added missing usage string for allowing unsigned subject.
+ *
+ * Revision 1.21  2018-08-08 23:57:02+05:30  Cprogrammer
+ * issue success if at lease one one good signature is found
+ *
+ * Revision 1.20  2018-05-22 10:03:26+05:30  Cprogrammer
+ * changed return type of writeHeader() to void
+ *
+ * Revision 1.19  2016-03-01 16:23:38+05:30  Cprogrammer
+ * added -S option to allow email with unsigned subject
+ *
+ * Revision 1.18  2016-02-01 10:53:32+05:30  Cprogrammer
+ * use basename of private key as the selector in absense of -y option
+ *
+ * Revision 1.17  2015-12-15 15:36:01+05:30  Cprogrammer
+ * added case 3 for 3rd party signature without SSP and ADSP
+ * increased buffer size for Apple mail with X-BrightMail-Tracker header issue
+ *
+ * Revision 1.16  2012-08-16 08:01:19+05:30  Cprogrammer
+ * do not skip X-Mailer headers
+ *
+ * Revision 1.15  2011-06-04 13:55:50+05:30  Cprogrammer
+ * set AllowUnsignedFromHeaders
+ *
+ * Revision 1.14  2011-06-04 09:36:36+05:30  Cprogrammer
+ * added AllowUnsignedFromHeaders option
+ *
+ * Revision 1.13  2011-02-07 22:05:23+05:30  Cprogrammer
+ * added case DKIM_3PS_SIGNATURE
+ *
+ * Revision 1.12  2010-05-04 14:00:13+05:30  Cprogrammer
+ * make option '-z' work on systems without SHA_256
+ *
+ * Revision 1.11  2009-04-20 08:35:45+05:30  Cprogrammer
+ * corrected usage()
+ *
+ * Revision 1.10  2009-04-15 21:30:32+05:30  Cprogrammer
+ * added DKIM-Signature to list of excluded headers
+ *
+ * Revision 1.9  2009-04-15 20:45:04+05:30  Cprogrammer
+ * corrected usage
+ *
+ * Revision 1.8  2009-04-05 19:04:44+05:30  Cprogrammer
+ * improved formating of usage
+ *
+ * Revision 1.7  2009-04-03 12:05:25+05:30  Cprogrammer
+ * minor changes on usage display
+ *
+ * Revision 1.6  2009-03-28 20:15:23+05:30  Cprogrammer
+ * invoke DKIMVerifyGetDetails()
+ *
+ * Revision 1.5  2009-03-27 20:43:48+05:30  Cprogrammer
+ * added HAVE_OPENSSL_EVP_H conditional
+ *
+ * Revision 1.4  2009-03-27 20:19:28+05:30  Cprogrammer
+ * added ADSP
+ *
+ * Revision 1.3  2009-03-26 15:10:53+05:30  Cprogrammer
+ * added ADSP
+ *
+ * Revision 1.2  2009-03-25 08:37:45+05:30  Cprogrammer
+ * added dkim_error
+ *
+ * Revision 1.1  2009-03-21 08:24:47+05:30  Cprogrammer
+ * Initial revision
+ */
diff -Naur netqmail-1.06.org/dkimfuncs.cpp netqmail-1.06/dkimfuncs.cpp
--- netqmail-1.06.org/dkimfuncs.cpp	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/dkimfuncs.cpp	2023-02-01 16:13:37.000000000 +0530
@@ -0,0 +1,253 @@
+/*
+ * $Log: dkimfuncs.cpp,v $
+ * Revision 1.5  2021-08-28 21:41:03+05:30  Cprogrammer
+ * added function to replace selector
+ *
+ * Revision 1.4  2011-06-04 10:06:33+05:30  Cprogrammer
+ * unified error strings for signing & verification
+ *
+ * Revision 1.3  2009-04-15 20:45:29+05:30  Cprogrammer
+ * code beautified
+ *
+ * Revision 1.2  2009-03-26 15:11:12+05:30  Cprogrammer
+ * added GetDomain(), ADSP
+ *
+ * Revision 1.1  2009-03-21 08:43:10+05:30  Cprogrammer
+ * Initial revision
+ *
+ *
+ *  Copyright 2005 Alt-N Technologies, Ltd. 
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License"); 
+ *  you may not use this file except in compliance with the License. 
+ *  You may obtain a copy of the License at 
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0 
+ *
+ *  This code incorporates intellectual property owned by Yahoo! and licensed 
+ *  pursuant to the Yahoo! DomainKeys Patent License Agreement.
+ *
+ *  Unless required by applicable law or agreed to in writing, software 
+ *  distributed under the License is distributed on an "AS IS" BASIS, 
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ *  See the License for the specific language governing permissions and 
+ *  limitations under the License.
+ *
+ */
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+#include "dkim.h"
+#include "dkimsign.h"
+#include "dkimverify.h"
+#include <string.h>
+
+#define DKIMID ('D' | 'K'<<8 | 'I'<<16 | 'M'<<24)
+
+static void
+InitContext(DKIMContext *pContext, bool bSign, void *pObject)
+{
+	pContext->reserved1 = DKIMID;
+	pContext->reserved2 = bSign ? 1 : 0;
+	pContext->reserved3 = pObject;
+}
+
+static void    *
+ValidateContext(DKIMContext *pContext, bool bSign)
+{
+	if (pContext->reserved1 != DKIMID)
+		return NULL;
+	if (pContext->reserved2 != (unsigned int) (bSign ? 1 : 0))
+		return NULL;
+	return pContext->reserved3;
+}
+
+int             DKIM_CALL
+DKIMSignInit(DKIMContext *pSignContext, DKIMSignOptions *pOptions)
+{
+	int             nRet = DKIM_OUT_OF_MEMORY;
+	CDKIMSign      *pSign = new CDKIMSign;
+
+	if (pSign) {
+		nRet = pSign->Init(pOptions);
+		if (nRet != DKIM_SUCCESS)
+			delete          pSign;
+	}
+	if (nRet == DKIM_SUCCESS)
+		InitContext(pSignContext, true, pSign);
+	return nRet;
+}
+
+int             DKIM_CALL
+DKIMSignReplaceSelector(DKIMContext *pSignContext, DKIMSignOptions *pOptions)
+{
+	CDKIMSign      *pSign = (CDKIMSign *) ValidateContext(pSignContext, true);
+
+	if (pSign)
+		pSign->ReplaceSelector(pOptions);
+	return DKIM_INVALID_CONTEXT;
+}
+
+int             DKIM_CALL
+DKIMSignReplaceHash(DKIMContext *pSignContext, DKIMSignOptions *pOptions)
+{
+	CDKIMSign      *pSign = (CDKIMSign *) ValidateContext(pSignContext, true);
+
+	if (pSign)
+		pSign->ReplaceHash(pOptions);
+	return DKIM_INVALID_CONTEXT;
+}
+
+int             DKIM_CALL
+DKIMSignProcess(DKIMContext *pSignContext, char *szBuffer, int nBufLength)
+{
+	CDKIMSign      *pSign = (CDKIMSign *) ValidateContext(pSignContext, true);
+	if (pSign)
+		return pSign->Process(szBuffer, nBufLength, false);
+	return DKIM_INVALID_CONTEXT;
+}
+
+int             DKIM_CALL
+DKIMSignGetSig(DKIMContext *pSignContext, char *szPrivKey, char *szSignature, int nSigLength)
+{
+	CDKIMSign      *pSign = (CDKIMSign *) ValidateContext(pSignContext, true);
+	if (pSign)
+		return pSign->GetSig(szPrivKey, szSignature, nSigLength);
+	return DKIM_INVALID_CONTEXT;
+}
+
+int             DKIM_CALL
+DKIMSignGetSig2(DKIMContext *pSignContext, char *szPrivKey, char **pszSignature)
+{
+	CDKIMSign      *pSign = (CDKIMSign *) ValidateContext(pSignContext, true);
+	if (pSign)
+		return pSign->GetSig2(szPrivKey, pszSignature);
+	return DKIM_INVALID_CONTEXT;
+}
+
+char           *DKIM_CALL
+DKIMSignGetDomain(DKIMContext *pSignContext)
+{
+	CDKIMSign      *pSign = (CDKIMSign *) ValidateContext(pSignContext, true);
+	if (pSign)
+		return pSign->GetDomain();
+	return ((char *) 0);
+}
+
+void            DKIM_CALL
+DKIMSignFree(DKIMContext *pSignContext)
+{
+	CDKIMSign      *pSign = (CDKIMSign *) ValidateContext(pSignContext, true);
+	if (pSign) {
+		delete          pSign;
+		pSignContext->reserved3 = NULL;
+	}
+}
+
+int             DKIM_CALL
+DKIMVerifyInit(DKIMContext *pVerifyContext, DKIMVerifyOptions *pOptions)
+{
+	int             nRet = DKIM_OUT_OF_MEMORY;
+	CDKIMVerify    *pVerify = new CDKIMVerify;
+	if (pVerify) {
+		nRet = pVerify->Init(pOptions);
+		if (nRet != DKIM_SUCCESS)
+			delete          pVerify;
+	}
+	if (nRet == DKIM_SUCCESS)
+		InitContext(pVerifyContext, false, pVerify);
+	return nRet;
+}
+
+int             DKIM_CALL
+DKIMVerifyProcess(DKIMContext *pVerifyContext, char *szBuffer, int nBufLength)
+{
+	CDKIMVerify    *pVerify = (CDKIMVerify *) ValidateContext(pVerifyContext, false);
+	if (pVerify)
+		return pVerify->Process(szBuffer, nBufLength, false);
+	return DKIM_INVALID_CONTEXT;
+}
+
+int             DKIM_CALL
+DKIMVerifyResults( DKIMContext *pVerifyContext , int *sCount, int *sSize)
+{
+	CDKIMVerify    *pVerify = (CDKIMVerify *) ValidateContext(pVerifyContext, false);
+	if (pVerify)
+		return pVerify->GetResults(sCount, sSize);
+	return DKIM_INVALID_CONTEXT;
+}
+
+int             DKIM_CALL
+DKIMVerifyGetDetails(DKIMContext *pVerifyContext, int *nSigCount, DKIMVerifyDetails **pDetails, char *szPractices)
+{
+	szPractices[0] = '\0';
+	CDKIMVerify    *pVerify = (CDKIMVerify *) ValidateContext(pVerifyContext, false);
+	if (pVerify) {
+		strcpy(szPractices, pVerify->GetPractices());
+		return pVerify->GetDetails(nSigCount, pDetails);
+	}
+	return DKIM_INVALID_CONTEXT;
+}
+
+void            DKIM_CALL
+DKIMVerifyFree(DKIMContext *pVerifyContext)
+{
+	CDKIMVerify    *pVerify = (CDKIMVerify *) ValidateContext(pVerifyContext, false);
+	if (pVerify) {
+		delete          pVerify;
+		pVerifyContext->reserved3 = NULL;
+	}
+}
+
+char           *DKIM_CALL
+DKIMVerifyGetDomain(DKIMContext *pVerifyContext)
+{
+	CDKIMVerify    *pVerify = (CDKIMVerify *) ValidateContext(pVerifyContext, false);
+	if (pVerify)
+		return pVerify->GetDomain();
+	return ((char *) 0);
+}
+
+static char    *DKIMErrorStrings[-1 - DKIM_MAX_ERROR] = {
+	(char *) "DKIM_FAIL",
+	(char *) "DKIM_BAD_SYNTAX",
+	(char *) "DKIM_SIGNATURE_BAD",
+	(char *) "DKIM_SIGNATURE_BAD_BUT_TESTING",
+	(char *) "DKIM_SIGNATURE_EXPIRED",
+	(char *) "DKIM_SELECTOR_INVALID",
+	(char *) "DKIM_SELECTOR_GRANULARITY_MISMATCH",
+	(char *) "DKIM_SELECTOR_KEY_REVOKED",
+	(char *) "DKIM_SELECTOR_DOMAIN_NAME_TOO_LONG",
+	(char *) "DKIM_SELECTOR_DNS_TEMP_FAILURE",
+	(char *) "DKIM_SELECTOR_DNS_PERM_FAILURE",
+	(char *) "DKIM_SELECTOR_PUBLIC_KEY_INVALID",
+	(char *) "DKIM_NO_SIGNATURES",
+	(char *) "DKIM_NO_VALID_SIGNATURES",
+	(char *) "DKIM_BODY_HASH_MISMATCH",
+	(char *) "DKIM_SELECTOR_ALGORITHM_MISMATCH",
+	(char *) "DKIM_STAT_INCOMPAT",
+	(char *) "DKIM_UNSIGNED_FROM",
+	(char *) "DKIM_OUT_OF_MEMORY",
+	(char *) "DKIM_INVALID_CONTEXT",
+	(char *) "DKIM_NO_SENDER",
+	(char *) "DKIM_BAD_PRIVATE_KEY",
+	(char *) "DKIM_BUFFER_TOO_SMALL"
+};
+
+char           *DKIM_CALL
+DKIMGetErrorString(int ErrorCode)
+{
+	if (ErrorCode >= 0 || ErrorCode <= DKIM_MAX_ERROR)
+		return (char *) "Unknown";
+
+	else
+		return DKIMErrorStrings[-1 - ErrorCode];
+}
+
+void
+getversion_dkimfuncs_cpp()
+{
+	static char    *x = (char *) "$Id: dkimfuncs.cpp,v 1.5 2021-08-28 21:41:03+05:30 Cprogrammer Exp mbhangui $";
+
+	x++;
+}
diff -Naur netqmail-1.06.org/dkim.h netqmail-1.06/dkim.h
--- netqmail-1.06.org/dkim.h	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/dkim.h	2023-02-12 12:09:45.000000000 +0530
@@ -0,0 +1,217 @@
+/*
+ *  Copyright 2005 Alt-N Technologies, Ltd. 
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License"); 
+ *  you may not use this file except in compliance with the License. 
+ *  You may obtain a copy of the License at 
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0 
+ *
+ *  This code incorporates intellectual property owned by Yahoo! and licensed 
+ *  pursuant to the Yahoo! DomainKeys Patent License Agreement.
+ *
+ *  Unless required by applicable law or agreed to in writing, software 
+ *  distributed under the License is distributed on an "AS IS" BASIS, 
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ *  See the License for the specific language governing permissions and 
+ *  limitations under the License.
+ *
+ */
+
+#define DKIM_CALL
+#define MAKELONG(a,b) ((long)(((unsigned)(a) & 0xffff) | (((unsigned)(b) & 0xffff) << 16)))
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+#include <time.h>
+
+/* DKIM encryption method rsa or ed25519 */
+#define DKIM_ENCRYPTION_RSA         1
+#define DKIM_ENCRYPTION_ED25519     2
+
+/* DKIM hash algorithms */
+#define DKIM_HASH_SHA1              1
+#define DKIM_HASH_SHA256            2
+#define DKIM_HASH_SHA1_AND_SHA256   3
+#define DKIM_HASH_ED25519           4
+
+/* DKIM canonicalization methods */
+#define DKIM_CANON_SIMPLE           1
+#define DKIM_CANON_NOWSP            2
+#define DKIM_CANON_RELAXED          3
+
+#define DKIM_SIGN_SIMPLE			MAKELONG(DKIM_CANON_SIMPLE,DKIM_CANON_SIMPLE)
+#define DKIM_SIGN_SIMPLE_RELAXED	MAKELONG(DKIM_CANON_RELAXED,DKIM_CANON_SIMPLE)
+#define DKIM_SIGN_RELAXED			MAKELONG(DKIM_CANON_RELAXED,DKIM_CANON_RELAXED)
+#define DKIM_SIGN_RELAXED_SIMPLE	MAKELONG(DKIM_CANON_SIMPLE,DKIM_CANON_RELAXED)
+
+/*
+ * DKIM_SUCCESS                                 verify result: all signatures verified
+ * signature result: signature verified
+ */
+#define DKIM_SUCCESS                          0 /* operation successful */
+#define DKIM_FINISHED_BODY                    1 /* process result: no more message body is needed */
+#define DKIM_PARTIAL_SUCCESS                  2 /* verify result: at least one but not all signatures verified */
+#define DKIM_NEUTRAL                          3 /* verify result: no signatures verified but message is not suspicous */
+#define DKIM_SUCCESS_BUT_EXTRA                4 /* signature result: signature verified but it did not include all of the body */
+#define DKIM_3PS_SIGNATURE                    5 /* 3rd-party signature */
+
+/* DKIM Error codes */
+#define DKIM_FAIL                            -1 /* verify error: message is suspicious */
+#define DKIM_BAD_SYNTAX                      -2 /* signature error: DKIM-Signature could not parse or has bad tags/values */
+#define DKIM_SIGNATURE_BAD                   -3 /* signature error: RSA/ED25519 verify failed */
+#define DKIM_SIGNATURE_BAD_BUT_TESTING       -4 /* signature error: RSA/ED25519 verify failed but testing */
+#define DKIM_SIGNATURE_EXPIRED               -5 /* signature error: x= is old */
+#define DKIM_SELECTOR_INVALID                -6 /* signature error: selector doesn't parse or contains invalid values */
+#define DKIM_SELECTOR_GRANULARITY_MISMATCH   -7 /* signature error: selector g= doesn't match i= */
+#define DKIM_SELECTOR_KEY_REVOKED            -8 /* signature error: selector p= empty */
+#define DKIM_SELECTOR_DOMAIN_NAME_TOO_LONG   -9 /* signature error: selector domain name too long to request */
+#define DKIM_SELECTOR_DNS_TEMP_FAILURE      -10 /* signature error: temporary dns failure requesting selector */
+#define DKIM_SELECTOR_DNS_PERM_FAILURE      -11 /* signature error: permanent dns failure requesting selector */
+#define DKIM_SELECTOR_PUBLIC_KEY_INVALID    -12 /* signature error: selector p= value invalid or wrong format */
+#define DKIM_NO_SIGNATURES                  -13 /* process error, no sigs */
+#define DKIM_NO_VALID_SIGNATURES            -14 /* process error, no valid sigs */
+#define DKIM_BODY_HASH_MISMATCH             -15 /* sigature verify error: message body does not hash to bh value */
+#define DKIM_SELECTOR_ALGORITHM_MISMATCH    -16 /* signature error: selector h= doesn't match signature a= */
+#define DKIM_STAT_INCOMPAT                  -17 /* signature error: incompatible v= */
+#define DKIM_UNSIGNED_FROM                  -18 /* signature error: not all message's From headers in signature */
+#define DKIM_OUT_OF_MEMORY                  -19 /* memory allocation failed */
+#define DKIM_INVALID_CONTEXT                -20 /* DKIMContext structure invalid for this operation */
+#define DKIM_NO_SENDER                      -21 /* signing error: Could not find From: or Sender: header in message */
+#define DKIM_BAD_PRIVATE_KEY                -22 /* signing error: Could not parse private key */
+#define DKIM_BUFFER_TOO_SMALL               -23 /* signing error: Buffer passed in is not large enough */
+#define DKIM_EVP_SIGN_FAILURE               -24 /* signing error: evp signing failure */
+#define DKIM_EVP_DIGEST_FAILURE             -25 /* signing error: evp digest failure */
+#define DKIM_MAX_ERROR                      -26 /* set this to 1 greater than the highest error code (but negative) */
+
+#define DKIM_SSP_UNKNOWN                      1 /*- some messages may be signed */
+#define DKIM_SSP_ALL                          2 /*- all messages are signed, 3rd party allowed */
+#define DKIM_SSP_STRICT                       3 /*- all messages are signed, no 3rd party allowed */
+#define DKIM_SSP_SCOPE                        4 /*- the domain should be considered invalid */
+#define DKIM_SSP_TEMPFAIL                     5 /*- Temporary Error */
+
+#define DKIM_ADSP_UNKNOWN                     1 /*- some messages may be signed */
+#define DKIM_ADSP_ALL                         2 /*- All message are signed with author signature */
+#define DKIM_ADSP_DISCARDABLE                 3 /*- messages which fail verification are Discardable */
+#define DKIM_ADSP_SCOPE                       4 /*- domain is out of scope */
+#define DKIM_ADSP_TEMPFAIL                    5 /*- Temporary Error */
+
+
+/* This function is called once for each header in the message */
+/* return 1 to include this header in the signature and 0 to exclude. */
+typedef int     (DKIM_CALL *DKIMHEADERCALLBACK) (const char *szHeader);
+
+/* This function is called to retrieve a TXT record from DNS */
+typedef int     (DKIM_CALL *DKIMDNSCALLBACK) (const char *szFQDN, char *szBuffer, int nBufLen);
+
+typedef struct DKIMContext_t {
+	unsigned int    reserved1;
+	unsigned int    reserved2;
+	void           *reserved3;
+} DKIMContext;
+
+typedef struct DKIMSignOptions_t {
+	int             nCanon;                 /* canonization */
+	int             nIncludeBodyLengthTag;  /* 0 = don't include l= tag, 1 = include l= tag */
+	int             nIncludeTimeStamp;      /* 0 = don't include t= tag, 1 = include t= tag */
+	int             nIncludeQueryMethod;    /* 0 = don't include q= tag, 1 = include q= tag */
+	char            szSelector[80];         /* selector - required */
+	char            szDomain[256];          /* domain - optional - if empty, domain is computed from sender */
+	char            szIdentity[256];        /* for i= tag, if empty tag will not be included in sig */
+	time_t          expireTime;             /* for x= tag, if 0 tag will not be included in sig */
+	DKIMHEADERCALLBACK pfnHeaderCallback;   /* header callback */
+	char            szRequiredHeaders[256]; /* colon-separated list of headers that must be signed */
+	int             nHash;                  /* use one of the DKIM_HASH_xx constants here, even if not present in the message */
+	int             nIncludeCopiedHeaders;  /* 0 = don't include z= tag, 1 = include z= tag */
+	int             nIncludeBodyHash;       /* use one of the DKIM_BODYHASH_xx constants here */
+	int             verbose;
+} DKIMSignOptions;
+
+typedef struct DKIMVerifyOptions_t {
+	DKIMDNSCALLBACK pfnSelectorCallback;       /* selector record callback */
+	DKIMDNSCALLBACK pfnPracticesCallback;      /* SSP record callback */
+	int             nHonorBodyLengthTag;       /* 0 = ignore l= tag, 1 = use l= tag to limit the amount of body verified */
+	int             nCheckPractices;           /* 0 = use default (unknown) practices, 1 = request and use sender's signing practices */
+	int             nSubjectRequired;          /* 0 = subject is required to be signed, 1 = not required */
+	int             nSaveCanonicalizedData;    /* 0 = canonicalized data is not saved, 1 = canonicalized data is saved */
+	int             nAllowUnsignedFromHeaders; /* 0 = From headers not included in the signature are not allowed, 1 = allowed */
+	int             nAccept3ps;                /* 0 = don't check 3rd party signature(s), 1 = check 3rd party signature(s) */
+	int             verbose;
+} DKIMVerifyOptions;
+
+typedef struct DKIMVerifyDetails_t {
+	char           *szSignature;
+	char           *DNS;
+	char           *szSignatureDomain;
+	char           *szIdentityDomain;
+	char           *szCanonicalizedData;
+	int             nResult;
+} DKIMVerifyDetails;
+
+int DKIM_CALL   DKIMSignInit(DKIMContext *pSignContext, DKIMSignOptions *pOptions);
+int DKIM_CALL   DKIMSignProcess(DKIMContext *pSignContext, char *szBuffer, int nBufLength);
+int DKIM_CALL   DKIMSignGetSig(DKIMContext *pSignContext, char *szPrivKey, char *szSignature, int nSigLength);
+int DKIM_CALL   DKIMSignGetSig2(DKIMContext *pSignContext, char *szPrivKey, char **pszSignature);
+void DKIM_CALL  DKIMSignFree(DKIMContext *pSignContext);
+char           *DKIM_CALL DKIMSignGetDomain(DKIMContext *pSignContext);
+
+int DKIM_CALL   DKIMVerifyInit(DKIMContext *pVerifyContext, DKIMVerifyOptions *pOptions);
+int DKIM_CALL   DKIMVerifyProcess(DKIMContext *pVerifyContext, char *szBuffer, int nBufLength);
+int DKIM_CALL   DKIMVerifyResults(DKIMContext *pVerifyContext , int *sCount, int *sSize);
+int DKIM_CALL   DKIMVerifyGetDetails(DKIMContext *pVerifyContext, int *nSigCount, DKIMVerifyDetails **pDetails, char *szPractices);
+char           *DKIM_CALL DKIMVerifyGetDomain(DKIMContext *pVerifyContext);
+void DKIM_CALL  DKIMVerifyFree(DKIMContext *pVerifyContext);
+char           *DKIM_CALL DKIMVersion();
+char           *DKIM_CALL DKIMGetErrorString(int ErrorCode);
+int  DKIM_CALL  DKIMSignReplaceSelector(DKIMContext *pSignContext, DKIMSignOptions *pOptions);
+int  DKIM_CALL  DKIMSignReplaceHash(DKIMContext *pSignContext, DKIMSignOptions *pOptions);
+#include "macros.h"
+#ifdef __cplusplus
+}
+#endif
+
+/*
+ * $Log: dkim.h,v $
+ * Revision 1.13  2023-02-11 22:50:12+05:30  Cprogrammer
+ * added DKIM_EVP_SIGN_FAILURE, DKIM_EVP_DIGEST_FAILURE definitions for EVP signing and digest failures
+ *
+ * Revision 1.12  2023-02-01 18:02:45+05:30  Cprogrammer
+ * new function DKIMSignReplaceHash to alter current Hash method
+ *
+ * Revision 1.11  2023-01-29 22:03:53+05:30  Cprogrammer
+ * added defines for encryption methods
+ *
+ * Revision 1.10  2023-01-26 22:38:16+05:30  Cprogrammer
+ * added definition for DKIM_HASH_ED25519
+ *
+ * Revision 1.9  2021-08-28 21:41:40+05:30  Cprogrammer
+ * added DKIMSignReplaceSelector to replace selector
+ *
+ * Revision 1.8  2015-12-15 16:03:18+05:30  Cprogrammer
+ * use time_t for expireTime
+ *
+ * Revision 1.7  2011-06-04 13:56:06+05:30  Cprogrammer
+ * corrected return codes
+ *
+ * Revision 1.6  2011-06-04 10:04:00+05:30  Cprogrammer
+ * unified error code for signing & verifcation
+ * added signature and identity domain information to
+ *     DKIMVerifyDetails structure
+ *
+ * Revision 1.5  2009-03-27 20:19:05+05:30  Cprogrammer
+ * major changes made for incorporating ADSP
+ *
+ * Revision 1.4  2009-03-26 19:28:15+05:30  Cprogrammer
+ * removed DKIM_3PS_PARTIAL_SUCCESS
+ *
+ * Revision 1.3  2009-03-26 15:11:33+05:30  Cprogrammer
+ * added ADSP
+ *
+ * Revision 1.2  2009-03-25 08:37:58+05:30  Cprogrammer
+ * changed definitions of constants to avoid clash between error and success
+ *
+ * Revision 1.1  2009-03-21 08:50:19+05:30  Cprogrammer
+ * Initial revision
+ */
diff -Naur netqmail-1.06.org/dkimsign.cpp netqmail-1.06/dkimsign.cpp
--- netqmail-1.06.org/dkimsign.cpp	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/dkimsign.cpp	2023-06-30 19:12:11.514793773 +0530
@@ -0,0 +1,1071 @@
+/*
+ *  Copyright 2005 Alt-N Technologies, Ltd.
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  This code incorporates intellectual property owned by Yahoo! and licensed
+ *  pursuant to the Yahoo! DomainKeys Patent License Agreement.
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+#define _strnicmp strncasecmp
+#define _stricmp strcasecmp
+#define LOWORD(l) ((unsigned)(l) & 0xffff)
+#define HIWORD(l) ((unsigned)(l) >> 16)
+
+#include <string.h>
+#include <map>
+#include "dkim.h"
+#include "dkimsign.h"
+
+/*
+ * Much of the code related to ED25519 comes from
+ * Erwin Hoffmann's s/qmail code
+ */
+
+CDKIMSign::CDKIMSign()
+{
+	m_EmptyLineCount = 0;
+	m_pfnHdrCallback = NULL;
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+	if (!m_Hdr_ietf_sha1ctx)
+		m_Hdr_ietf_sha1ctx = EVP_MD_CTX_new();
+	EVP_SignInit(m_Hdr_ietf_sha1ctx, EVP_sha1());
+
+	if (!m_Bdy_ietf_sha1ctx)
+		m_Bdy_ietf_sha1ctx = EVP_MD_CTX_new();
+	EVP_DigestInit(m_Bdy_ietf_sha1ctx, EVP_sha1());
+
+	if (!m_Hdr_ietf_sha256ctx)
+		m_Hdr_ietf_sha256ctx = EVP_MD_CTX_new();
+	EVP_SignInit(m_Hdr_ietf_sha256ctx, EVP_sha256());
+
+	if (!m_Bdy_ietf_sha256ctx)
+		m_Bdy_ietf_sha256ctx = EVP_MD_CTX_new();
+	EVP_DigestInit(m_Bdy_ietf_sha256ctx, EVP_sha256());
+
+#if OPENSSL_VERSION_NUMBER >= 0x10101000L
+	if (!m_Hdr_ed25519ctx)
+		m_Hdr_ed25519ctx = EVP_MD_CTX_new();
+#endif
+#else
+	EVP_SignInit(&m_Hdr_ietf_sha1ctx, EVP_sha1());
+	EVP_DigestInit(&m_Bdy_ietf_sha1ctx, EVP_sha1());
+#ifdef HAVE_EVP_SHA256
+	EVP_SignInit(&m_Hdr_ietf_sha256ctx, EVP_sha256());
+	EVP_DigestInit(&m_Bdy_ietf_sha256ctx, EVP_sha256());
+#endif
+#endif
+}
+
+CDKIMSign::~CDKIMSign()
+{
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+	EVP_MD_CTX_reset(m_Hdr_ietf_sha1ctx);
+	EVP_MD_CTX_reset(m_Bdy_ietf_sha1ctx);
+	EVP_MD_CTX_reset(m_Hdr_ietf_sha256ctx);
+	EVP_MD_CTX_reset(m_Bdy_ietf_sha256ctx);
+#if OPENSSL_VERSION_NUMBER >= 0x10101000L
+	EVP_MD_CTX_free(m_Hdr_ed25519ctx);
+#endif
+#else
+	EVP_MD_CTX_cleanup(&m_Hdr_ietf_sha1ctx);
+	EVP_MD_CTX_cleanup(&m_Bdy_ietf_sha1ctx);
+#ifdef HAVE_EVP_SHA256
+	EVP_MD_CTX_cleanup(&m_Hdr_ietf_sha256ctx);
+	EVP_MD_CTX_cleanup(&m_Bdy_ietf_sha256ctx);
+#endif
+#endif
+}
+
+/*
+ * Init - save the options
+ */
+int
+CDKIMSign::Init(DKIMSignOptions *pOptions)
+{
+	int             nRet = CDKIMBase::Init();
+	m_Canon = pOptions->nCanon;
+
+	/*- as of draft 01, these are the only allowed signing types: */
+	if (m_Canon != DKIM_SIGN_SIMPLE_RELAXED && m_Canon != DKIM_SIGN_RELAXED && m_Canon != DKIM_SIGN_RELAXED_SIMPLE)
+		m_Canon = DKIM_SIGN_SIMPLE;
+	sSelector.assign(pOptions->szSelector);
+	m_pfnHdrCallback = pOptions->pfnHeaderCallback;
+	sDomain.assign(pOptions->szDomain);
+	m_IncludeBodyLengthTag = (pOptions->nIncludeBodyLengthTag != 0);
+	m_nBodyLength = 0;
+	m_ExpireTime = pOptions->expireTime;
+	sIdentity.assign(pOptions->szIdentity);
+	m_nIncludeTimeStamp = pOptions->nIncludeTimeStamp;
+	m_nIncludeQueryMethod = pOptions->nIncludeQueryMethod;
+	m_nIncludeCopiedHeaders = pOptions->nIncludeCopiedHeaders;
+
+	/*-
+	 * NOTE: the following line is not backwards compatible with MD 8.0.3
+	 * because the szRequiredHeaders member was added after the release
+	 * sRequiredHeaders.assign( pOptions->szRequiredHeaders );
+	 */
+
+	/*- make sure there is a colon after the last header in the list */
+	if (sRequiredHeaders.size() > 0 && sRequiredHeaders.at(sRequiredHeaders.size() - 1) != ':')
+		sRequiredHeaders.append(":");
+	m_nHash = pOptions->nHash;
+	m_bReturnedSigAssembled = false;
+	m_sCopiedHeaders.erase();
+#if OPENSSL_VERSION_NUMBER >= 0x10101000L
+	SigHdrs.erase();
+#endif
+	return nRet;
+}
+
+void
+CDKIMSign::ReplaceSelector(DKIMSignOptions *pOptions)
+{
+	sSelector.assign(pOptions->szSelector);
+}
+
+void
+CDKIMSign::ReplaceHash(DKIMSignOptions *pOptions)
+{
+	m_nHash = pOptions->nHash;
+}
+
+/* Hash - update the hash */
+void
+CDKIMSign::Hash(const char *szBuffer, int nBufLength, bool bHdr)
+{
+	EVP_MD_CTX     *p1, *p2, *p3, *p4;
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+	p1 = m_Hdr_ietf_sha1ctx;
+	p2 = m_Hdr_ietf_sha256ctx;
+	p3 = m_Bdy_ietf_sha1ctx;
+	p4 = m_Bdy_ietf_sha256ctx;
+#else
+	p1 = &m_Hdr_ietf_sha1ctx;
+#ifdef HAVE_EVP_SHA256
+	p2 = &m_Hdr_ietf_sha256ctx;
+#endif
+	p3 = &m_Bdy_ietf_sha1ctx;
+#ifdef HAVE_EVP_SHA256
+	p4 = &m_Bdy_ietf_sha256ctx;
+#endif
+#endif
+
+	if (bHdr) { /* Generate signature: b=... */
+		if (m_nHash == DKIM_HASH_SHA1 || m_nHash == DKIM_HASH_SHA1_AND_SHA256)
+			EVP_SignUpdate(p1, szBuffer, nBufLength);
+#ifdef HAVE_EVP_SHA256
+		EVP_SignUpdate(p2, szBuffer, nBufLength);
+#endif
+#if OPENSSL_VERSION_NUMBER >= 0x10101000L
+		SigHdrs.append(szBuffer, nBufLength);
+#endif
+	} else { /* lets go for body hash values: bh=... */
+		if (m_nHash == DKIM_HASH_SHA1 || m_nHash == DKIM_HASH_SHA1_AND_SHA256)
+			EVP_DigestUpdate(p3, szBuffer, nBufLength);
+#ifdef HAVE_EVP_SHA256
+		EVP_DigestUpdate(p4, szBuffer, nBufLength);
+#endif
+	}
+}
+
+
+/*
+ * SignThisHeader - return boolean whether or not to sign this tag
+ */
+bool CDKIMSign::SignThisHeader(const string &sTag)
+{
+	bool            bRet = true;
+
+	if (_strnicmp(sTag.c_str(), "X-", 2) == 0
+		|| _stricmp(sTag.c_str(), "Authentication-Results:") == 0
+		|| _stricmp(sTag.c_str(), "DKIM-Signature:") == 0
+		|| _stricmp(sTag.c_str(), "Domainkey-Signature:") == 0
+		|| _stricmp(sTag.c_str(), "Received:") == 0
+		|| _stricmp(sTag.c_str(), "Return-Path:") == 0)
+	{
+		bRet = false;
+	}
+	return bRet;
+}
+
+bool
+ConvertHeaderToQuotedPrintable(const char *source, char *dest)
+{
+	bool            bConvert = false;
+
+	/* do quoted printable */
+	static unsigned char hexchars[16] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };
+	unsigned char  *d = (unsigned char *) dest;
+	for (const unsigned char *s = (const unsigned char *)source; *s != '\0'; s++) {
+		if (*s >= 33 && *s <= 126 && *s != '=' && *s != ':' && *s != ';' && *s != '|')
+			*d++ = *s;
+		else {
+			bConvert = true;
+			*d++ = '=';
+			*d++ = hexchars[*s >> 4];
+			*d++ = hexchars[*s & 15];
+		}
+	}
+	*d = '\0';
+	return bConvert;
+}
+
+
+/*
+ * GetHeaderParams - Extract any needed header parameters
+ */
+void
+CDKIMSign::GetHeaderParams(const string &sHdr)
+{
+	if (_strnicmp(sHdr.c_str(), "X-Bounced-Address:", 18) == 0)
+		sBouncedAddr.assign(sHdr.c_str() + 21);
+	else
+	if (_strnicmp(sHdr.c_str(), "X", 1) == 0)
+		return;
+	if (_strnicmp(sHdr.c_str(), "From:", 5) == 0)
+		sFrom.assign(sHdr.c_str() + 5);
+	if (_strnicmp(sHdr.c_str(), "Sender:", 7) == 0)
+		sSender.assign(sHdr.c_str() + 7);
+	if (_strnicmp(sHdr.c_str(), "Return-Path:", 12) == 0)
+		sReturnPath.assign(sHdr.c_str() + 12);
+	if (m_nIncludeCopiedHeaders) {
+		string::size_type pos = sHdr.find(':');
+		if (pos != string::npos) {
+			string          sTag, sValue;
+			char           *workBuffer = new char[sHdr.size() * 3 + 1];
+
+			sTag.assign(sHdr.substr(0, pos));
+			sValue.assign(sHdr.substr(pos + 1, string::npos));
+			ConvertHeaderToQuotedPrintable(sTag.c_str(), workBuffer);
+			if (!m_sCopiedHeaders.empty())
+				m_sCopiedHeaders.append("|");
+			m_sCopiedHeaders.append(workBuffer);
+			m_sCopiedHeaders.append(":");
+			ConvertHeaderToQuotedPrintable(sValue.c_str(), workBuffer);
+			m_sCopiedHeaders.append(workBuffer);
+			delete[]workBuffer;
+		}
+	}
+}
+
+/* ProcessHeaders - sign headers and save needed parameters */
+int
+CDKIMSign::ProcessHeaders(void)
+{
+	map <string, list <string>::reverse_iterator> IterMap;
+	map <string, list <string>::reverse_iterator>::iterator IterMapIter;
+	list <string>::reverse_iterator riter;
+	list <string>::iterator iter;
+	string          sTag;
+	bool            bFromHeaderFound = false;
+
+	/* walk the header list */
+	for (iter = HeaderList.begin(); iter != HeaderList.end(); iter++) {
+		sTag.assign(*iter);
+		/* look for a colon */
+		string::size_type pos = sTag.find(':');
+		if (pos != string::npos) {
+			int             nSignThisTag = 1;
+			/* hack off anything past the colon */
+			sTag.erase(pos + 1, string::npos);
+			/* is this the From: header? */
+			if (_stricmp(sTag.c_str(), "From:") == 0) {
+				bFromHeaderFound = true;
+				nSignThisTag = 1;
+				IsRequiredHeader(sTag);	/* remove from required header list */
+			}
+			/* is this in the list of headers that must be signed? */
+			else
+			if (IsRequiredHeader(sTag))
+				nSignThisTag = 1;
+			else {
+				if (m_pfnHdrCallback)
+					nSignThisTag = m_pfnHdrCallback(iter->c_str());
+				else
+					nSignThisTag = SignThisHeader(sTag) ? 1 : 0;
+			}
+			/* save header parameters */
+			GetHeaderParams(*iter);
+			if (nSignThisTag > 0) {
+				/* add this tag to h= */
+				hParam.append(sTag);
+				IterMapIter = IterMap.find(sTag);
+				riter = (IterMapIter == IterMap.end())? HeaderList.rbegin() : IterMapIter->second;
+				/* walk the list in reverse looking for the last instance of this header */
+				while (riter != HeaderList.rend()) {
+					if (_strnicmp(riter->c_str(), sTag.c_str(), sTag.size()) == 0) {
+						ProcessHeader(*riter);
+						/* save the reverse iterator position for this tag */
+						riter++;
+						IterMap[sTag] = riter;
+						break;
+					}
+					riter++;
+				}
+			}
+		}
+	}
+	if (!bFromHeaderFound) {
+		string sFrom("From:");
+		hParam.append(sFrom);
+		IsRequiredHeader(sFrom);	/* remove from required header list */
+	}
+	hParam.append(sRequiredHeaders);
+	if (hParam.at(hParam.size() - 1) == ':')
+		hParam.erase(hParam.size() - 1, string::npos);
+	return DKIM_SUCCESS;
+}
+
+char           *DKIM_CALL
+CDKIMSign::GetDomain(void)
+{
+	if (ParseFromAddress() == false)
+		return ((char *) 0);
+	return ((char *) sDomain.c_str());
+}
+
+void
+CDKIMSign::ProcessHeader(const string &sHdr)
+{
+	string          sTemp;
+
+	switch (HIWORD(m_Canon))
+	{
+	case DKIM_CANON_SIMPLE:
+		Hash(sHdr.c_str(), sHdr.size(), true);
+		Hash("\r\n", 2, true);
+		break;
+	case DKIM_CANON_NOWSP:
+		sTemp = sHdr;
+		RemoveSWSP(sTemp);
+		/* convert characters before ':' to lower case */
+		for (char *s = (char *)sTemp.c_str(); *s != '\0' && *s != ':'; s++) {
+			if (*s >= 'A' && *s <= 'Z')
+				*s += 'a' - 'A';
+		}
+		Hash(sTemp.c_str(), sTemp.size(), true);
+		Hash("\r\n", 2, true);
+		break;
+	case DKIM_CANON_RELAXED:
+		sTemp = RelaxHeader(sHdr);
+		Hash(sTemp.c_str(), sTemp.length(), true);
+		Hash("\r\n", 2, true);
+		break;
+	}
+}
+
+int CDKIMSign::ProcessBody(char *szBuffer, int nBufLength, bool bEOF)
+{
+	switch (LOWORD(m_Canon))
+	{
+	case DKIM_CANON_SIMPLE:
+		if (nBufLength > 0) {
+			while (m_EmptyLineCount > 0) {
+				Hash("\r\n", 2, false);
+				m_nBodyLength += 2;
+				m_EmptyLineCount--;
+			}
+			Hash(szBuffer, nBufLength, false);
+			Hash("\r\n", 2, false);
+			m_nBodyLength += nBufLength + 2;
+		} else {
+			m_EmptyLineCount++;
+			if (bEOF) {
+				Hash("\r\n", 2, false);
+				m_nBodyLength += 2;
+			}
+		}
+		break;
+	case DKIM_CANON_NOWSP:
+		RemoveSWSP(szBuffer, nBufLength);
+		if (nBufLength > 0) {
+			Hash(szBuffer, nBufLength, false);
+			m_nBodyLength += nBufLength;
+		}
+		break;
+	case DKIM_CANON_RELAXED:
+		CompressSWSP(szBuffer, nBufLength);
+		if (nBufLength > 0) {
+			while (m_EmptyLineCount > 0) {
+				Hash("\r\n", 2, false);
+				m_nBodyLength += 2;
+				m_EmptyLineCount--;
+			}
+			Hash(szBuffer, nBufLength, false);
+			m_nBodyLength += nBufLength;
+			if (!bEOF) {
+				Hash("\r\n", 2, false);
+				m_nBodyLength += 2;
+			}
+		} else
+			m_EmptyLineCount++;
+		break;
+	}
+	return DKIM_SUCCESS;
+}
+
+bool CDKIMSign::ParseFromAddress(void)
+{
+	string::size_type pos;
+	string          sAddress;
+	char           *p, *at;
+
+	/* thanks to fred */
+	if (!sReturnPath.empty())
+		sAddress.assign(sReturnPath);
+	else
+	if (!sSender.empty())
+		sAddress.assign(sSender);
+	else
+	if (!sFrom.empty())
+		sAddress.assign(sFrom);
+	else /* use indimail's X-Bounced-Address header to find the domain that injected the bounce */
+	if (!sBouncedAddr.empty())
+		sAddress.assign(sBouncedAddr);
+	else
+		return false;
+	/*-
+	 * simple for now, beef it up later
+	 * remove '<' and anything before it
+	 */
+	pos = sAddress.find('<');
+	if (pos != string::npos)
+		sAddress.erase(0, pos + 1);
+
+	/* remove '>' and anything after it */
+	pos = sAddress.find('>');
+	if (pos != string::npos)
+		sAddress.erase(pos, string::npos);
+	/* look for '@' symbol */
+	if (sDomain.empty()) {
+		pos = sAddress.find('@');
+		if (pos != string::npos)
+			sDomain.assign(sAddress.c_str() + pos + 1);
+		if (sDomain.empty()) {
+			if (!(p = getenv("BOUNCEDOMAIN")))
+				p = getenv("DKIMDOMAIN");
+			if (p && *p) {
+				if (!(at = strchr(p, '@')))
+					at = p;
+				else
+					at++;
+				sDomain.assign(at);
+			} else
+				return false;
+		}
+	}
+	RemoveSWSP(sDomain);
+	return true;
+}
+
+
+/*
+ * InitSig - initialize signature folding algorithm
+ */
+void
+CDKIMSign::InitSig(void)
+{
+	m_sSig.reserve(1024);
+	m_sSig.assign("DKIM-Signature:");
+	m_nSigPos = m_sSig.size();
+}
+
+/*
+ * AddTagToSig - add tag and value to signature folding if necessary
+ *               if bFold, fold at cbrk char
+ */
+void CDKIMSign::AddTagToSig(char *Tag, const string &sValue, char cbrk, bool bFold)
+{
+	int             nTagLen = strlen(Tag);
+
+	AddInterTagSpace((!bFold) ? sValue.size() + nTagLen + 2 : nTagLen + 2);
+	m_sSig.append(Tag);
+	m_sSig.append("=");
+	m_nSigPos += 1 + nTagLen;
+	if (!bFold) {
+		m_sSig.append(sValue);
+		m_nSigPos += sValue.size();
+	} else
+		AddFoldedValueToSig(sValue, cbrk);
+	m_sSig.append(";");
+	m_nSigPos++;
+}
+
+
+/*
+ * AddTagToSig - add tag and numeric value to signature folding if necessary
+ */
+void CDKIMSign::AddTagToSig(char *Tag, unsigned long nValue)
+{
+	char            szValue[64];
+
+	sprintf(szValue, "%lu", nValue);
+	AddTagToSig(Tag, szValue, 0, false);
+}
+
+/*
+ * AddInterTagSpace - add space or fold here
+ */
+void CDKIMSign::AddInterTagSpace(int nSizeOfNextTag)
+{
+	if (m_nSigPos + nSizeOfNextTag + 1 > OptimalHeaderLineLength) {
+		m_sSig.append("\n\t");
+		m_nSigPos = 1;
+	} else {
+		m_sSig.append(" ");
+		m_nSigPos++;
+	}
+}
+
+
+/*
+ * AddTagToSig - add value to signature folding if necessary
+ *               if cbrk == 0 fold anywhere, otherwise fold only at cbrk
+ */
+void CDKIMSign::AddFoldedValueToSig(const string &sValue, char cbrk)
+{
+	string::size_type pos = 0;
+
+	if (cbrk == 0) {
+		/* fold anywhere */
+		while (pos < sValue.size()) {
+			string::size_type len = OptimalHeaderLineLength - m_nSigPos;
+			if (len > sValue.size() - pos)
+				len = sValue.size() - pos;
+			m_sSig.append(sValue.substr(pos, len));
+			m_nSigPos += len;
+			pos += len;
+			if (pos < sValue.size()) {
+				m_sSig.append("\n\t");
+				m_nSigPos = 1;
+			}
+		}
+	} else {
+		/* fold only at cbrk */
+		while (pos < sValue.size()) {
+			string::size_type len = OptimalHeaderLineLength - m_nSigPos;
+			string::size_type brkpos;
+			if (sValue.size() - pos < len)
+				brkpos = sValue.size() - 1;
+			else
+				brkpos = sValue.rfind(cbrk, pos + len);
+			if (brkpos == string::npos || brkpos < pos) {
+				brkpos = sValue.find(cbrk, pos);
+				if (brkpos == string::npos)
+					brkpos = sValue.size();
+			}
+			len = brkpos - pos + 1;
+			m_sSig.append(sValue.substr(pos, len));
+			m_nSigPos += len;
+			pos += len;
+			if (pos < sValue.size()) {
+				m_sSig.append("\n\t");
+				m_nSigPos = 1;
+			}
+		}
+	}
+}
+
+
+/*
+ * GetSig - compute hash and return signature header in szSignature
+ */
+int CDKIMSign::GetSig(char *szPrivKey, char *szSignature, unsigned int nSigLength)
+{
+	if (szPrivKey == NULL)
+		return DKIM_BAD_PRIVATE_KEY;
+	if (szSignature == NULL)
+		return DKIM_BUFFER_TOO_SMALL;
+	int             nRet = AssembleReturnedSig(szPrivKey);
+	if (nRet != DKIM_SUCCESS)
+		return nRet;
+	if (m_sReturnedSig.size() + 1 < nSigLength)
+		strcpy(szSignature, m_sReturnedSig.c_str());
+	else
+		return DKIM_BUFFER_TOO_SMALL;
+	return DKIM_SUCCESS;
+}
+
+
+/*
+ * GetSig - compute hash and return signature header in szSignature
+ */
+int CDKIMSign::GetSig2(char *szPrivKey, char **pszSignature)
+{
+	if (szPrivKey == NULL)
+		return DKIM_BAD_PRIVATE_KEY;
+	if (pszSignature == NULL)
+		return DKIM_BUFFER_TOO_SMALL;
+	int             nRet = AssembleReturnedSig(szPrivKey);
+	if (nRet != DKIM_SUCCESS)
+		return nRet;
+	*pszSignature = (char *) m_sReturnedSig.c_str();
+	return DKIM_SUCCESS;
+}
+
+
+/*
+ * IsRequiredHeader - Check if header in required list. If so, delete
+ *                    header from list.
+ */
+bool CDKIMSign::IsRequiredHeader(const string &sTag)
+{
+	string::size_type start = 0;
+	string::size_type end = sRequiredHeaders.find(':');
+	while (end != string::npos) {
+		/* check for a zero-length header */
+		if (start == end)
+			sRequiredHeaders.erase(start, 1);
+		else {
+			if (_stricmp(sTag.c_str(), sRequiredHeaders.substr(start, end - start + 1).c_str()) == 0) {
+				sRequiredHeaders.erase(start, end - start + 1);
+				return true;
+			} else
+				start = end + 1;
+		}
+		end = sRequiredHeaders.find(':', start);
+	}
+	return false;
+}
+
+int
+CDKIMSign::ConstructSignature(char *szPrivKey, int nSigAlg)
+{
+	string          sSignedSig, sTemp;
+	unsigned char  *sig;
+	EVP_PKEY       *pkey;
+	BIO            *bio, *b64;
+	unsigned int    siglen;
+	int             size, len;
+	int             nSignRet = 0;
+	char           *buf, *cptr;
+	const char     *ptr, *dptr, *sptr;
+	unsigned char   Hash[EVP_MAX_MD_SIZE];
+	unsigned int   nHashLen = 0;
+	EVP_MD_CTX     *p1, *p2, *p3, *p4;
+#if OPENSSL_VERSION_NUMBER >= 0x10101000L
+	EVP_MD_CTX     *p5;
+#endif
+
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+	p1 = m_Hdr_ietf_sha1ctx;
+	p2 = m_Hdr_ietf_sha256ctx;
+	p3 = m_Bdy_ietf_sha1ctx;
+	p4 = m_Bdy_ietf_sha256ctx;
+#if OPENSSL_VERSION_NUMBER >= 0x10101000L
+	p5 = m_Hdr_ed25519ctx;
+#endif
+#else
+	p1 = &m_Hdr_ietf_sha1ctx;
+#ifdef HAVE_EVP_SHA256
+	p2 = &m_Hdr_ietf_sha256ctx;
+#endif
+	p3 = &m_Bdy_ietf_sha1ctx;
+#ifdef HAVE_EVP_SHA256
+	p4 = &m_Bdy_ietf_sha256ctx;
+#endif
+#endif
+
+	/*- construct the DKIM-Signature: header and add to hash */
+	InitSig();
+	AddTagToSig((char *) "v", "1", 0, false);
+	switch (nSigAlg)
+	{
+	case DKIM_HASH_SHA1:
+		AddTagToSig((char *) "a", "rsa-sha1", 0, false);
+		break;
+#ifdef HAVE_EVP_SHA256
+	case DKIM_HASH_SHA256:
+		AddTagToSig((char *) "a", "rsa-sha256", 0, false);
+		break;
+#endif
+	case DKIM_HASH_ED25519:
+		AddTagToSig((char *) "a", "ed25519-sha256", 0, false);
+		break;
+	}
+	switch (m_Canon)
+	{
+	case DKIM_SIGN_SIMPLE:
+		AddTagToSig((char *) "c", "simple", 0, false);
+		break;
+	case DKIM_SIGN_SIMPLE_RELAXED:
+		AddTagToSig((char *) "c", "simple/relaxed", 0, false);
+		break;
+	case DKIM_SIGN_RELAXED:
+		AddTagToSig((char *) "c", "relaxed/relaxed", 0, false);
+		break;
+	case DKIM_SIGN_RELAXED_SIMPLE:
+		AddTagToSig((char *) "c", "relaxed", 0, false);
+		break;
+	}
+	AddTagToSig((char *) "d", sDomain, 0, false);
+	/*- replace % with domain name */
+	ptr = sSelector.c_str();
+	if ((sptr = strchr(ptr, '%'))) {
+		dptr = sDomain.c_str();
+		for (sptr = ptr, len = 0;*sptr;sptr++) {
+			if (*sptr == '%')
+				len += (int) strlen(dptr) + 1;
+			else
+				len++;
+		}
+		if (!(buf = new char[len]))
+			return DKIM_OUT_OF_MEMORY;
+		for (cptr = buf, sptr = ptr; *sptr; sptr++) {
+			if (*sptr == '%') {
+				memcpy(cptr, dptr, (len = strlen(dptr)));
+				cptr += len;
+			} else
+				*cptr++ = *sptr;
+		}
+		*cptr = 0;
+		sSelector.assign(buf);
+		delete[]buf;
+	}
+	AddTagToSig((char *) "s", sSelector, 0, false);
+	if (m_IncludeBodyLengthTag)
+		AddTagToSig((char *) "l", m_nBodyLength);
+	if (m_nIncludeTimeStamp != 0) {
+		time_t t;
+		time(&t);
+		AddTagToSig((char *) "t", t);
+	}
+	if (m_ExpireTime != 0)
+		AddTagToSig((char *) "x", m_ExpireTime);
+	if (!sIdentity.empty())
+		AddTagToSig((char *) "i", sIdentity, 0, false);
+	if (m_nIncludeQueryMethod)
+		AddTagToSig((char *) "q", "dns/txt", 0, false);
+	AddTagToSig((char *) "h", hParam, ':', true);
+	if (m_nIncludeCopiedHeaders)
+		AddTagToSig((char *) "z", m_sCopiedHeaders, 0, true);
+	switch (nSigAlg)
+	{
+	case DKIM_HASH_SHA1:
+		if (!EVP_DigestFinal(p3, Hash, &nHashLen))
+			return DKIM_EVP_DIGEST_FAILURE;
+		break;
+#ifdef HAVE_EVP_SHA256
+	case DKIM_HASH_SHA256:
+		if (!EVP_DigestFinal(p4, Hash, &nHashLen))
+			return DKIM_EVP_DIGEST_FAILURE;
+		break;
+#endif
+#if OPENSSL_VERSION_NUMBER >= 0x10101000L
+	case DKIM_HASH_ED25519:
+		if (!EVP_DigestFinal(p4, Hash, &nHashLen))
+			return DKIM_EVP_DIGEST_FAILURE;
+		break;
+#endif
+	}
+	if (nHashLen) {
+		if (!(bio = BIO_new(BIO_s_mem())))
+			return DKIM_OUT_OF_MEMORY;
+		if (!(b64 = BIO_new(BIO_f_base64()))) {
+			BIO_free(bio);
+			return DKIM_OUT_OF_MEMORY;
+		}
+		BIO_set_flags(b64, BIO_FLAGS_BASE64_NO_NL);
+		BIO_push(b64, bio);
+		if (BIO_write(b64, Hash, nHashLen) < (int) nHashLen) {
+			BIO_free_all(b64);
+			return DKIM_OUT_OF_MEMORY;
+		}
+		BIO_flush(b64);
+		len = nHashLen * 2;
+		if (!(buf = new char[len])) {
+			BIO_free_all(b64);
+			return DKIM_OUT_OF_MEMORY;
+		}
+		size = BIO_read(bio, buf, len);
+		BIO_free_all(b64);
+		/* this should never happen */
+		if (size >= len) {
+			delete[]buf;
+			return DKIM_OUT_OF_MEMORY;
+		}
+		buf[size] = 0;
+		AddTagToSig((char *) "bh", buf, 0, true);
+		delete[]buf;
+	}
+	AddInterTagSpace(3);
+	m_sSig.append("b=");
+	m_nSigPos += 2;
+	/* Force a full copy - no reference copies please */
+	sSignedSig.assign(m_sSig.c_str());
+	/*-
+	 * note that since we're not calling hash here, need to dump this
+	 * to the debug file if you want the full canonical form
+	 */
+	if (HIWORD(m_Canon) == DKIM_CANON_RELAXED)
+		sTemp = RelaxHeader(sSignedSig);
+	else
+		sTemp = sSignedSig.c_str();
+	switch (nSigAlg)
+	{
+	case DKIM_HASH_SHA1:
+		if (!EVP_SignUpdate(p1, sTemp.c_str(), sTemp.size()))
+			return DKIM_EVP_SIGN_FAILURE;
+		break;
+#ifdef HAVE_EVP_SHA256
+	case DKIM_HASH_SHA256:
+		if (!EVP_SignUpdate(p2, sTemp.c_str(), sTemp.size()))
+			return DKIM_EVP_SIGN_FAILURE;
+		break;
+#endif
+#if OPENSSL_VERSION_NUMBER >= 0x10101000L
+	case DKIM_HASH_ED25519:
+		SigHdrs.append(sTemp.c_str(), sTemp.size());
+		break;
+#endif
+	}
+
+	if (!(bio = BIO_new_mem_buf(szPrivKey, -1)))
+		return DKIM_OUT_OF_MEMORY;
+	if (!(pkey = PEM_read_bio_PrivateKey(bio, NULL, NULL, NULL))) {
+		BIO_free(bio);
+		return DKIM_BAD_PRIVATE_KEY;
+	}
+	BIO_free(bio);
+	/*- Finish streaming signature and potentially go for Ed25519 signatures */
+	switch (nSigAlg)
+	{
+	case DKIM_HASH_SHA1:
+		siglen = EVP_PKEY_size(pkey);
+		if (!(sig = (unsigned char *) OPENSSL_malloc(siglen))) {
+			EVP_PKEY_free(pkey);
+			return DKIM_OUT_OF_MEMORY;
+		}
+		nSignRet = EVP_SignFinal(p1, sig, &siglen, pkey);
+		break;
+#ifdef HAVE_EVP_SHA256
+	case DKIM_HASH_SHA256:
+		siglen = EVP_PKEY_size(pkey);
+		if (!(sig = (unsigned char *) OPENSSL_malloc(siglen))) {
+			EVP_PKEY_free(pkey);
+			return DKIM_OUT_OF_MEMORY;
+		}
+		nSignRet = EVP_SignFinal(p2, sig, &siglen, pkey);
+		break;
+#endif
+#if OPENSSL_VERSION_NUMBER >= 0x10101000L
+	case DKIM_HASH_ED25519:
+		size_t          sig_len;
+		unsigned char  *SignMsg;
+
+		if (!EVP_DigestSignInit(p5, NULL, NULL, NULL, pkey)) {
+			EVP_PKEY_free(pkey);
+			return DKIM_BAD_PRIVATE_KEY;
+		}
+		SignMsg = (unsigned char *) SigHdrs.c_str();
+		if (!EVP_DigestSign(p5, NULL, &sig_len, SignMsg, SigHdrs.length())) {
+			EVP_PKEY_free(pkey);
+			return DKIM_BAD_PRIVATE_KEY;
+		}
+		sig = (unsigned char *) OPENSSL_malloc(sig_len);
+		nSignRet = EVP_DigestSign(p5, sig, &sig_len, SignMsg, SigHdrs.length());
+		siglen = (unsigned int) sig_len;
+		break;
+#endif
+	}
+	EVP_PKEY_free(pkey);
+	if (!nSignRet) {
+		OPENSSL_free(sig);
+		return DKIM_BAD_PRIVATE_KEY; /* key too small */
+	}
+	if (!(bio = BIO_new(BIO_s_mem())))
+		return DKIM_OUT_OF_MEMORY;
+	if (!(b64 = BIO_new(BIO_f_base64()))) {
+		BIO_free(bio);
+		return DKIM_OUT_OF_MEMORY;
+	}
+	BIO_set_flags(b64, BIO_FLAGS_BASE64_NO_NL);
+	BIO_push(b64, bio);
+	if (BIO_write(b64, sig, siglen) < (int) siglen) {
+		OPENSSL_free(sig);
+		BIO_free_all(b64);
+		return DKIM_OUT_OF_MEMORY;
+	}
+	BIO_flush(b64);
+	OPENSSL_free(sig);
+	len = siglen * 2;
+	if (!(buf = new char[len])) {
+		BIO_free_all(b64);
+		return DKIM_OUT_OF_MEMORY;
+	}
+	size = BIO_read(bio, buf, len);
+	BIO_free_all(b64);
+	/* this should never happen */
+	if (size >= len) {
+		delete[]buf;
+		return DKIM_OUT_OF_MEMORY;
+	}
+	buf[size] = '\0';
+	AddFoldedValueToSig(buf, 0);
+	delete[]buf;
+	return DKIM_SUCCESS;
+}
+
+int
+CDKIMSign::AssembleReturnedSig(char *szPrivKey)
+{
+	int             nRet;
+
+	if (m_bReturnedSigAssembled)
+		return DKIM_SUCCESS;
+	ProcessFinal();
+	if (ParseFromAddress() == false) {
+		/* return DKIM_NO_SENDER; */
+	}
+#if OPENSSL_VERSION_NUMBER >= 0x10101000L
+	string          ed25519Sig, ietfsha256Sig, ietfsha1Sig;
+#else
+#ifdef HAVE_EVP_SHA256
+	string          ietfsha256Sig, ietfsha1Sig;
+#else
+	string          ietfsha1Sig;
+#endif
+#endif
+	if (m_nHash == DKIM_HASH_SHA256 || m_nHash == DKIM_HASH_SHA1_AND_SHA256) {
+		nRet = ConstructSignature(szPrivKey, DKIM_HASH_SHA256);
+		if (nRet == DKIM_SUCCESS)
+			ietfsha256Sig.assign(m_sSig);
+		else
+			return nRet;
+	}
+	if (m_nHash == DKIM_HASH_SHA1 || m_nHash == DKIM_HASH_SHA1_AND_SHA256) {
+		nRet = ConstructSignature(szPrivKey, DKIM_HASH_SHA1);
+		if (nRet == DKIM_SUCCESS)
+			ietfsha1Sig.assign(m_sSig);
+		else
+			return nRet;
+	}
+#if OPENSSL_VERSION_NUMBER >= 0x10101000L
+	if (m_nHash == DKIM_HASH_ED25519) {
+		nRet = ConstructSignature(szPrivKey, DKIM_HASH_ED25519);
+		if (nRet == DKIM_SUCCESS)
+			ed25519Sig.assign(m_sSig);
+		else
+			return nRet;
+	}
+	if (!ed25519Sig.empty()) {
+		if (!m_sReturnedSig.empty())
+			m_sReturnedSig.append("\n");
+		m_sReturnedSig.assign(ed25519Sig);
+	}
+#endif
+	if (!ietfsha1Sig.empty()) {
+		if (!m_sReturnedSig.empty())
+			m_sReturnedSig.append("\n");
+		m_sReturnedSig.append(ietfsha1Sig);
+	}
+	if (!ietfsha256Sig.empty()) {
+		if (!m_sReturnedSig.empty())
+			m_sReturnedSig.append("\n");
+		m_sReturnedSig.append(ietfsha256Sig);
+	}
+	m_bReturnedSigAssembled = true;
+	return DKIM_SUCCESS;
+}
+
+void
+getversion_dkimsign_cpp()
+{
+	static char    *x = (char *) "$Id: dkimsign.cpp,v 1.25 2023-02-11 22:51:43+05:30 Cprogrammer Exp mbhangui $";
+
+	x++;
+}
+
+/*
+ * $Log: dkimsign.cpp,v $
+ * Revision 1.25  2023-02-11 22:51:43+05:30  Cprogrammer
+ * check for EVP sign and digest failures
+ * fixed a= tag to "ed25519-sha256"
+ *
+ * Revision 1.24  2023-02-04 18:06:01+05:30  Cprogrammer
+ * fixed memory leak
+ *
+ * Revision 1.23  2023-02-01 18:04:33+05:30  Cprogrammer
+ * new function DKIMSignReplaceHash to alter current Hash method
+ *
+ * Revision 1.22  2023-01-29 22:11:23+05:30  Cprogrammer
+ * renamed SignThisTag to SignThisHeader
+ *
+ * Revision 1.21  2023-01-27 19:38:49+05:30  Cprogrammer
+ * fixed openssl version for ed25519
+ *
+ * Revision 1.20  2023-01-27 17:13:53+05:30  Cprogrammer
+ * added ed25519 encryption for DKIM signatues
+ *
+ * Revision 1.19  2021-08-28 21:42:23+05:30  Cprogrammer
+ * added ReplaceSelector to replace selector
+ *
+ * Revision 1.18  2020-04-11 08:37:12+05:30  Cprogrammer
+ * renamed DKKIMDOMAIN to BOUNCEDOMAIN
+ *
+ * Revision 1.17  2020-04-10 21:36:20+05:30  Cprogrammer
+ * fixed BUG with domain assignment
+ *
+ * Revision 1.16  2020-04-09 21:21:04+05:30  Cprogrammer
+ * check for null domain after DKIMDOMAIN replacement
+ *
+ * Revision 1.15  2019-06-26 19:08:18+05:30  Cprogrammer
+ * added sBouncedAddr variable for X-Bounced-Address header added by qmail-send for bounces
+ *
+ * Revision 1.14  2019-06-24 22:22:15+05:30  Cprogrammer
+ * use DKIMDOMAIN only if Return-Path, From, Sender header are empty
+ *
+ * Revision 1.13  2018-08-25 18:01:59+05:30  Cprogrammer
+ * fixed dkim signing for From address containing company name
+ *
+ * Revision 1.12  2018-05-23 13:07:58+05:30  Cprogrammer
+ * fixed compiler warnings
+ *
+ * Revision 1.11  2017-09-05 10:59:03+05:30  Cprogrammer
+ * removed compiler warnings
+ *
+ * Revision 1.10  2017-08-09 22:02:13+05:30  Cprogrammer
+ * replaced EVP_MD_CTX_free() with EVP_MD_CTX_reset()
+ *
+ * Revision 1.9  2017-08-08 23:50:19+05:30  Cprogrammer
+ * openssl 1.1.0 port
+ *
+ * Revision 1.8  2013-07-16 20:18:03+05:30  Cprogrammer
+ * replace '%' with domain name in selector
+ *
+ * Revision 1.7  2013-06-11 00:02:39+05:30  Cprogrammer
+ * removed header iostream
+ *
+ * Revision 1.6  2013-06-09 16:41:28+05:30  Cprogrammer
+ * parse address properly from From and Sender header
+ *
+ * Revision 1.5  2009-04-16 10:32:38+05:30  Cprogrammer
+ * added DKIMDOMAIN env variable
+ *
+ * Revision 1.4  2009-04-15 21:32:12+05:30  Cprogrammer
+ * added DKIM-Signature, Received to list of excluded headers
+ *
+ * Revision 1.3  2009-03-26 15:11:46+05:30  Cprogrammer
+ * added GetDomain
+ *
+ * Revision 1.2  2009-03-21 11:57:19+05:30  Cprogrammer
+ * fixed indentation
+ *
+ * Revision 1.1  2009-03-21 08:43:11+05:30  Cprogrammer
+ * Initial revision
+ */
diff -Naur netqmail-1.06.org/dkimsign.h netqmail-1.06/dkimsign.h
--- netqmail-1.06.org/dkimsign.h	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/dkimsign.h	2023-02-05 07:59:42.000000000 +0530
@@ -0,0 +1,136 @@
+/*
+ *  Copyright 2005 Alt-N Technologies, Ltd.
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  This code incorporates intellectual property owned by Yahoo! and licensed
+ *  pursuant to the Yahoo! DomainKeys Patent License Agreement.
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ */
+
+#ifndef DKIMSIGN_H
+#define DKIMSIGN_H
+
+#include "dkimbase.h"
+
+class           CDKIMSign:public CDKIMBase {
+public:
+
+	CDKIMSign();
+	~CDKIMSign();
+	int             Init(DKIMSignOptions *pOptions);
+	void            ReplaceSelector(DKIMSignOptions *pOptions);
+	void            ReplaceHash(DKIMSignOptions *pOptions);
+	int             GetSig(char *szPrivKey, char *szSignature, unsigned int nSigLength);
+	int             GetSig2(char *szPrivKey, char **pszSignature);
+	virtual int     ProcessHeaders(void);
+	virtual int     ProcessBody(char *szBuffer, int nBufLength, bool bEOF);
+	enum CKDKIMConstants { OptimalHeaderLineLength = 65 };
+	char           *DKIM_CALL GetDomain(void);
+
+protected:
+	void            Hash(const char* szBuffer,int nBufLength,bool bHdr);
+	bool            SignThisHeader(const string &sTag);
+	void            GetHeaderParams(const string &sHdr);
+	void            ProcessHeader(const string &sHdr);
+	bool            ParseFromAddress(void);
+	void            InitSig(void);
+	void            AddTagToSig(char *Tag, const string &sValue, char cbrk, bool bFold);
+	void            AddTagToSig(char *Tag, unsigned long nValue);
+	void            AddInterTagSpace(int nSizeOfNextTag);
+	void            AddFoldedValueToSig(const string &sValue, char cbrk);
+	bool            IsRequiredHeader(const string &sTag);
+	int             ConstructSignature(char *szPrivKey, int nSigAlg);
+	int             AssembleReturnedSig(char *szPrivKey);
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+	EVP_MD_CTX     *m_Hdr_ietf_sha1ctx = NULL;	/* the header hash for ietf sha1  */
+	EVP_MD_CTX     *m_Bdy_ietf_sha1ctx = NULL;	/* the body hash for ietf sha1  */
+	EVP_MD_CTX     *m_Hdr_ietf_sha256ctx = NULL;	/* the header hash for ietf sha256 */
+	EVP_MD_CTX     *m_Bdy_ietf_sha256ctx = NULL;	/* the body hash for ietf sha256 */
+#if OPENSSL_VERSION_NUMBER >= 0x10101000L
+	EVP_MD_CTX     *m_Hdr_ed25519ctx = NULL; /* the PureEd25519 signature */
+#endif
+#else
+	EVP_MD_CTX      m_Hdr_ietf_sha1ctx;	/* the header hash for ietf sha1  */
+	EVP_MD_CTX      m_Bdy_ietf_sha1ctx;	/* the body hash for ietf sha1  */
+#ifdef HAVE_EVP_SHA256
+	EVP_MD_CTX      m_Hdr_ietf_sha256ctx;	/* the header hash for ietf sha256 */
+	EVP_MD_CTX      m_Bdy_ietf_sha256ctx;	/* the body hash for ietf sha256 */
+#endif
+#endif
+	int             m_Canon;	/* canonization method */
+	int             m_EmptyLineCount;
+	string          hParam;
+	string          sFrom;
+	string          sSender;
+	string          sSelector;
+	string          sReturnPath;
+	string          sBouncedAddr; /*- used for bounces */
+	string          sDomain;
+	string          sIdentity;	/* for i= tag, if empty tag will not be included in sig */
+	string          sRequiredHeaders;
+	bool            m_IncludeBodyLengthTag;
+	int             m_nBodyLength;
+	time_t          m_ExpireTime;
+	int             m_nIncludeTimeStamp;		/* 0 = don't include t= tag, 1 = include t= tag */
+	int             m_nIncludeQueryMethod;		/* 0 = don't include q= tag, 1 = include q= tag */
+	int             m_nHash;					/* use one of the DKIM_HASH_xx constants here */
+	int             m_nIncludeCopiedHeaders;	/* 0 = don't include z= tag, 1 = include z= tag */
+	DKIMHEADERCALLBACK m_pfnHdrCallback;		/* use new signature computation algorithm */
+	string          m_sSig;
+	int             m_nSigPos;
+	string          m_sReturnedSig;
+	bool            m_bReturnedSigAssembled;
+	string          m_sCopiedHeaders;
+    string          SigHdrs;
+    size_t          m_SigHdrs;
+};
+
+#endif	/*- DKIMSIGN_H */
+
+/*
+ * $Log: dkimsign.h,v $
+ * Revision 1.11  2023-02-04 18:06:15+05:30  Cprogrammer
+ * fixed formatting
+ *
+ * Revision 1.10  2023-02-01 18:04:37+05:30  Cprogrammer
+ * new function DKIMSignReplaceHash to alter current Hash method
+ *
+ * Revision 1.9  2023-01-29 22:11:35+05:30  Cprogrammer
+ * renamed SignThisTag to SignThiHeader
+ *
+ * Revision 1.8  2023-01-27 19:38:53+05:30  Cprogrammer
+ * fixed openssl version for ed25519
+ *
+ * Revision 1.7  2023-01-27 17:16:00+05:30  Cprogrammer
+ * removed allman code
+ * updated for ed25519 DKIM signatures
+ *
+ * Revision 1.6  2021-08-28 21:42:40+05:30  Cprogrammer
+ * added ReplaceSelector to replace selector
+ *
+ * Revision 1.5  2019-06-26 19:09:07+05:30  Cprogrammer
+ * added sBouncedAddr variable for X-Bounced-Address header added by qmail-send for bounces
+ *
+ * Revision 1.4  2017-09-05 10:59:20+05:30  Cprogrammer
+ * removed compiler warnings
+ *
+ * Revision 1.3  2017-08-09 22:03:09+05:30  Cprogrammer
+ * initialized EVP_MD_CTX variables
+ *
+ * Revision 1.2  2017-08-08 23:50:33+05:30  Cprogrammer
+ * openssl 1.1.0 port
+ *
+ * Revision 1.1  2009-04-16 10:34:02+05:30  Cprogrammer
+ * Initial revision
+ */
diff -Naur netqmail-1.06.org/dkimverify.cpp netqmail-1.06/dkimverify.cpp
--- netqmail-1.06.org/dkimverify.cpp	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/dkimverify.cpp	2023-03-18 09:42:51.000000000 +0530
@@ -0,0 +1,1399 @@
+/*
+ *  Copyright 2005 Alt-N Technologies, Ltd.
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  This code incorporates intellectual property owned by Yahoo! and licensed
+ *  pursuant to the Yahoo! DomainKeys Patent License Agreement.
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ */
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+#define _strnicmp strncasecmp
+#define _stricmp strcasecmp
+#include <string.h>
+#include <ctype.h>
+#include <assert.h>
+#include <vector>
+#include <algorithm>
+#include <openssl/ssl.h>
+#include <openssl/err.h>
+#include "dkim.h"
+#include "dkimverify.h"
+#include "time_t_size.h"
+extern "C" {
+#include "dns_text.h"
+}
+
+#define MAX_SIGNATURES	10		/*- maximum number of DKIM signatures to process in a message */
+
+#if OPENSSL_VERSION_NUMBER >= 0x10101000L
+/*
+ * Much of the code related to ED25519 comes from
+ * Erwin Hoffmann's s/qmail code
+ */
+string          SigHdr;
+#endif
+static int     verbose;
+
+SignatureInfo::SignatureInfo(bool s)
+{
+	VerifiedBodyCount = 0;
+	UnverifiedBodyCount = 0;
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+	if (m_Hdr_ctx)
+		EVP_MD_CTX_init(m_Hdr_ctx);
+	else
+		m_Hdr_ctx = EVP_MD_CTX_new();
+	if (m_Bdy_ctx)
+		EVP_MD_CTX_init(m_Bdy_ctx);
+	else
+		m_Bdy_ctx = EVP_MD_CTX_new();
+#if OPENSSL_VERSION_NUMBER >= 0x10101000L
+	if (m_Msg_ctx)
+		EVP_MD_CTX_init(m_Msg_ctx);
+	else
+		m_Msg_ctx = EVP_MD_CTX_new();
+#endif
+#else
+	EVP_MD_CTX_init(&m_Hdr_ctx);
+	EVP_MD_CTX_init(&m_Bdy_ctx);
+#endif
+	m_pSelector = NULL;
+	Status = DKIM_SUCCESS;
+	m_nHash = 0;
+	EmptyLineCount = 0;
+	m_SaveCanonicalizedData = s;
+}
+
+SignatureInfo::~SignatureInfo()
+{
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+	if (m_Hdr_ctx)
+		EVP_MD_CTX_reset(m_Hdr_ctx);
+	if (m_Bdy_ctx)
+		EVP_MD_CTX_reset(m_Bdy_ctx);
+#if OPENSSL_VERSION_NUMBER >= 0x10101000L
+	if (m_Msg_ctx)
+		EVP_MD_CTX_reset(m_Msg_ctx);
+#endif
+#else
+	EVP_MD_CTX_cleanup(&m_Hdr_ctx);
+	EVP_MD_CTX_cleanup(&m_Bdy_ctx);
+#endif
+}
+
+inline          bool
+isswsp(char ch)
+{
+	return (ch == ' ' || ch == '\t' || ch == '\r' || ch == '\n');
+}
+
+/*
+ * Parse a DKIM tag-list.  Returns true for success
+ */
+bool
+ParseTagValueList(char *tagvaluelist, const char *wanted[], char *values[])
+{
+	char           *s = tagvaluelist;
+
+	for (;;) {
+		/* skip whitespace */
+		while (isswsp(*s))
+			s++;
+		/* if at the end of the string, return success.  note: this allows a list with no entries */
+		if (*s == '\0')
+			return true;
+		/*- get tag name -*/
+		if (!isalpha(*s))
+			return false;
+		char           *tag = s;
+		do {
+			s++;
+		} while (isalnum(*s) || *s == '-');
+		char           *endtag = s;
+		/*- skip whitespace before equals -*/
+		while (isswsp(*s))
+			s++;
+		/*- next character must be equals -*/
+		if (*s != '=')
+			return false;
+		s++;
+		/*- null-terminate tag name -*/
+		*endtag = '\0';
+		/*- skip whitespace after equals -*/
+		while (isswsp(*s))
+			s++;
+		/*- get tag value -*/
+		char           *value = s;
+		while (*s != ';' && ((*s == '\t' || *s == '\r' || *s == '\n') || (*s >= ' ' && *s <= '~')))
+			s++;
+		char           *e = s;
+		/*- make sure the next character is the null terminator (which means we're done) or a semicolon (not done) -*/
+		bool            done = false;
+		if (*s == '\0')
+			done = true;
+		else {
+			if (*s != ';')
+				return false;
+			s++;
+		}
+		/*- skip backwards past any trailing whitespace -*/
+		while (e > value && isswsp(e[-1]))
+			e--;
+		/*- null-terminate tag value -*/
+		*e = '\0';
+		/*- check to see if we want this tag -*/
+		for (unsigned i = 0; wanted[i] != NULL; i++) {
+			if (strcmp(wanted[i], tag) == 0) {
+				/*- return failure if we already have a value for this tag (duplicates not allowed) -*/
+				if (values[i] != NULL)
+					return false;
+				values[i] = value;
+				break;
+			}
+		}
+		if (done)
+			return true;
+	}
+}
+
+/*- Convert hex char to value (0-15) -*/
+char
+tohex(char ch)
+{
+	if (ch >= '0' && ch <= '9')
+		return (ch - '0');
+	else
+	if (ch >= 'A' && ch <= 'F')
+		return (ch - 'A' + 10);
+	else
+	if (ch >= 'a' && ch <= 'f')
+		return (ch - 'a' + 10);
+	else {
+		assert(0);
+		return 0;
+	}
+}
+
+/*
+ * Decode quoted printable string in-place
+ */
+void
+DecodeQuotedPrintable(char *ptr)
+{
+	char           *s = ptr;
+	while (*s != '\0' && *s != '=')
+		s++;
+	if (*s == '\0')
+		return;
+	char           *d = s;
+	do {
+		if (*s == '=' && isxdigit(s[1]) && isxdigit(s[2])) {
+			*d++ = (tohex(s[1]) << 4) | tohex(s[2]);
+			s += 3;
+		} else
+			*d++ = *s++;
+	} while (*s != '\0');
+	*d = '\0';
+}
+
+/*
+ * Decode base64 string in-place, returns number of bytes output
+ */
+unsigned
+DecodeBase64(char *ptr)
+{
+	static const signed char base64_table[256] =
+		{ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1,
+		-1, -1,
+		-1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1,
+		-1, -1,
+		26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1,
+		-1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
+	};
+	unsigned char  *s = (unsigned char *) ptr;
+	unsigned char  *d = (unsigned char *) ptr;
+	unsigned        b64accum = 0;
+	unsigned char   b64shift = 0;
+	while (*s != '\0') {
+		unsigned char value = base64_table[*s++];
+		if ((signed char) value >= 0) {
+			b64accum = (b64accum << 6) | value;
+			b64shift += 6;
+			if (b64shift >= 8) {
+				b64shift -= 8;
+				*d++ = (b64accum >> b64shift);
+			}
+		}
+	}
+	return (char *) d - ptr;
+}
+
+/*
+ * Match a string with a pattern (used for g= value)
+ * Supports a single, optional "*" wildcard character.
+ */
+bool
+WildcardMatch(const char *p, const char *s)
+{
+	/*- special case: An empty "g=" value never matches any addresses -*/
+	if (*p == '\0')
+		return false;
+	const char     *wildcard = strchr(p, '*');
+	if (wildcard == NULL)
+		return strcmp(s, p) == 0;
+	else {
+		unsigned beforewildcardlen = wildcard - p;
+		unsigned afterwildcardlen = strlen(wildcard + 1);
+		unsigned slen = strlen(s);
+		return (slen >= beforewildcardlen + afterwildcardlen) && (strncmp(s, p, beforewildcardlen) == 0)
+			&& strcmp(s + slen - afterwildcardlen, wildcard + 1) == 0;
+	}
+}
+
+/*
+ * Parse addresses from a string.  Returns true if at least one address found
+ */
+bool
+ParseAddresses(string str, vector < string > &Addresses)
+{
+	char           *s = (char *) str.c_str();
+
+	while (*s != '\0') {
+		char           *start = s;
+		char           *from = s;
+		char           *to = s;
+		char           *lt = NULL;	/*- pointer to less than character (<) which starts the address if found */
+
+		while (*from != '\0') {
+			if (*from == '(') {
+				/*- skip over comment -*/
+				from++;
+				for (int depth = 1; depth != 0; from++) {
+					if (*from == '\0')
+						break;
+					else
+					if (*from == '(')
+						depth++;
+					else
+					if (*from == ')')
+						depth--;
+					else
+					if (*from == '\\' && from[1] != '\0')
+						from++;
+				}
+			}
+			else
+			if (*from == ')') /*- ignore closing parenthesis outside of comment -*/
+				from++;
+			else
+			if (*from == ',' || *from == ';') {
+				/*- comma/selicolon ends the address -*/
+				from++;
+				break;
+			}
+			else
+			if (*from == ' ' || *from == '\t' || *from == '\r' || *from == '\n') /*- ignore whitespace -*/
+				from++;
+			else
+			if (*from == '"') {
+				/*- copy the contents of a quoted string -*/
+				from++;
+				while (*from != '\0') {
+					if (*from == '"') {
+						from++;
+						break;
+					}
+					else
+					if (*from == '\\' && from[1] != '\0')
+						*to++ = *from++;
+					*to++ = *from++;
+				}
+			}
+			else
+			if (*from == '\\' && from[1] != '\0') {
+				/*- copy quoted-pair -*/
+				*to++ = *from++;
+				*to++ = *from++;
+			} else {
+				/*- copy any other char -*/
+				*to = *from++;
+				/* save pointer to '<' for later... */
+				if (*to == '<')
+					lt = to;
+				to++;
+			}
+		}
+		*to = '\0';
+		/*- if there's < > get what's inside -*/
+		if (lt != NULL) {
+			start = lt + 1;
+			char           *gt = strchr(start, '>');
+			if (gt != NULL)
+				*gt = '\0';
+		} else {
+			/*- look for and strip group name -*/
+			char           *colon = strchr(start, ':');
+			if (colon != NULL) {
+				char           *at = strchr(start, '@');
+				if (at == NULL || colon < at)
+					start = colon + 1;
+			}
+		}
+		if (*start != '\0' && strchr(start, '@') != NULL)
+			Addresses.push_back(start);
+		s = from;
+	}
+	return !Addresses.empty();
+}
+
+CDKIMVerify::CDKIMVerify()
+{
+	m_pfnSelectorCallback = NULL;
+	m_pfnPracticesCallback = NULL;
+	m_HonorBodyLengthTag = false;
+	m_CheckPractices = false;
+	m_Accept3ps = false;
+	m_SubjectIsRequired = true;
+	m_SaveCanonicalizedData = false;
+	m_AllowUnsignedFromHeaders = false;
+}
+
+CDKIMVerify::~CDKIMVerify()
+{
+}
+
+/*- Init - save the options -*/
+int
+CDKIMVerify::Init(DKIMVerifyOptions *pOptions)
+{
+	int             nRet = CDKIMBase::Init();
+	m_pfnSelectorCallback = pOptions->pfnSelectorCallback;
+	m_pfnPracticesCallback = pOptions->pfnPracticesCallback;
+
+	m_HonorBodyLengthTag = pOptions->nHonorBodyLengthTag != 0;
+	m_CheckPractices = pOptions->nCheckPractices != 0;
+	m_SubjectIsRequired = pOptions->nSubjectRequired != 0;
+	m_Accept3ps = pOptions->nAccept3ps != 0;		/*TBS(Luc) */
+	m_SaveCanonicalizedData = pOptions->nSaveCanonicalizedData != 0;
+	m_AllowUnsignedFromHeaders = pOptions->nAllowUnsignedFromHeaders != 0;
+	verbose = pOptions->verbose;
+	return nRet;
+}
+
+/*- GetResults - return the pass/fail/neutral verification result -*/
+int
+CDKIMVerify::GetResults(int *sCount, int *sSize)
+{
+	ProcessFinal();
+	unsigned int    SuccessCount = 0;
+	int             TestingFailures = 0;
+	int             RealFailures = 0;
+	int             r;
+	list <string>   SuccessfulDomains;	/* can contain duplicates */
+	string          sFromDomain; /*- get the From address's domain if we might need it -*/
+
+	for (list < SignatureInfo >::iterator i = Signatures.begin(); i != Signatures.end(); ++i) {
+		if (i->Status == DKIM_SUCCESS) {
+			if (!i->BodyHashData.empty()) { /*- check the body hash -*/
+				unsigned char   md[EVP_MAX_MD_SIZE];
+				unsigned        len = 0;
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+				int             res = EVP_DigestFinal(i->m_Bdy_ctx, md, &len);
+#else
+				int             res = EVP_DigestFinal(&i->m_Bdy_ctx, md, &len);
+#endif
+				if (!res || len != i->BodyHashData.length() || memcmp(i->BodyHashData.data(), md, len) != 0) {
+					/* body hash mismatch */
+					if (i->m_pSelector->Testing) { /* if the selector is in testing mode... */
+						i->Status = DKIM_SIGNATURE_BAD_BUT_TESTING;	/* todo: make a new error code for this? */
+						TestingFailures++;
+					} else {
+						i->Status = DKIM_BODY_HASH_MISMATCH;
+						RealFailures++;
+					}
+					continue;
+				}
+			} else /* hash CRLF separating the body from the signature */
+				i->Hash("\r\n", 2);
+			/*- check the header hash -*/
+			string          sSignedSig = i->Header;
+			string          sSigValue = sSignedSig.substr(sSignedSig.find(':') + 1);
+			static const char *tags[] = { "b", NULL };
+			int             res = -1;
+			char           *values[sizeof (tags) / sizeof (tags[0])] = { NULL };
+			char           *pSigValue = (char *) sSigValue.c_str();
+
+			if (ParseTagValueList(pSigValue, tags, values) && values[0] != NULL)
+				sSignedSig.erase(15 + values[0] - pSigValue, strlen(values[0])); /*- erase b= value */
+			if (i->HeaderCanonicalization == DKIM_CANON_RELAXED)
+				sSignedSig = RelaxHeader(sSignedSig);
+			else
+			if (i->HeaderCanonicalization == DKIM_CANON_NOWSP) {
+				RemoveSWSP(sSignedSig);
+				/* convert "DKIM-Signature" to lower case */
+				sSignedSig.replace(0, 14, "dkim-signature", 14);
+			}
+			i->Hash(sSignedSig.c_str(), sSignedSig.length());
+			assert(i->m_pSelector != NULL);
+			if (i->m_pSelector->method == DKIM_ENCRYPTION_RSA) {
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+				res = EVP_VerifyFinal(i->m_Hdr_ctx, (unsigned char *) i->SignatureData.data(),
+						i->SignatureData.length(), i->m_pSelector->PublicKey);
+#else
+				res = EVP_VerifyFinal(&i->m_Hdr_ctx, (unsigned char *) i->SignatureData.data(),
+						i->SignatureData.length(), i->m_pSelector->PublicKey);
+#endif
+				if (res != 1 && verbose == true) {
+					while ((r = ERR_get_error()))
+						fprintf(stderr, "EVP_VerifyFinal: %s\n", ERR_error_string(r, NULL));
+				}
+			}
+#if OPENSSL_VERSION_NUMBER >= 0x10101000L
+			else 
+			if (EVP_PKEY_base_id(i->m_pSelector->PublicKey) == EVP_PKEY_ED25519) {
+				res = EVP_DigestVerifyInit(i->m_Msg_ctx, NULL, NULL, NULL,
+						i->m_pSelector->PublicKey);  /* late initialization */
+				if (res != 1) {
+					if (verbose == true) {
+						while ((r = ERR_get_error()))
+							fprintf(stderr, "EVP_DigestVerifyInit: %s\n", ERR_error_string(r, NULL));
+					}
+				} else {
+					res = EVP_DigestVerify(i->m_Msg_ctx, (unsigned char *)i->SignatureData.data(),
+							(size_t) i->SignatureData.length(), (unsigned char *) SigHdr.data(), SigHdr.length());
+					if (res != 1 && verbose == true) {
+						while ((r = ERR_get_error()))
+							fprintf(stderr, "EVP_DigestVerify: %s\n", ERR_error_string(r, NULL));
+					}
+				}
+			}
+			/*-
+			 * remove current dkim-signature so that in case
+			 * mail has multiple signatures, the new signature
+			 * will always be the first signature after the mail
+			 * body
+			 */
+			SigHdr.erase(SigHdr.length() - sSignedSig.length(), SigHdr.length());
+#endif
+			if (res == 1) {
+				if (i->UnverifiedBodyCount == 0)
+					i->Status = DKIM_SUCCESS;
+				else
+					i->Status = DKIM_SUCCESS_BUT_EXTRA;
+				SuccessCount++;
+				SuccessfulDomains.push_back(i->Domain);
+			} else {
+				/* if the selector is in testing mode... */
+				if (i->m_pSelector->Testing) {
+					i->Status = DKIM_SIGNATURE_BAD_BUT_TESTING;
+					TestingFailures++;
+				} else {
+					i->Status = DKIM_SIGNATURE_BAD;
+					RealFailures++;
+				}
+			}
+		} else
+		if (i->Status == DKIM_SELECTOR_GRANULARITY_MISMATCH
+			|| i->Status == DKIM_SELECTOR_ALGORITHM_MISMATCH
+			|| i->Status == DKIM_SELECTOR_KEY_REVOKED) {
+			/*- treat these as failures -*/
+			/*- todo: maybe see if the selector is in testing mode? -*/
+			RealFailures++;
+		}
+	} /* for (list < SignatureInfo >::iterator i = Signatures.begin(); i != Signatures.end(); ++i) */
+	if (SuccessCount > 0 || m_CheckPractices) {
+		for (list < string >::iterator i = HeaderList.begin(); i != HeaderList.end(); ++i) {
+			if (_strnicmp(i->c_str(), "From", 4) == 0) {
+				/*- skip over whitespace between the header name and : -*/
+				const char     *s = i->c_str() + 4;
+				while (*s == ' ' || *s == '\t')
+					s++;
+				if (*s == ':') {
+					vector <string> Addresses;
+					if (ParseAddresses(s + 1, Addresses)) {
+						unsigned atpos = Addresses[0].find('@');
+						sFromDomain = Addresses[0].substr(atpos + 1);
+						break;
+					}
+				}
+			}
+		}
+	}
+	/*-
+	 * if a signature from the From domain verified successfully,
+	 * return success now without checking the sender signing practices
+	 */
+	if (SuccessCount > 0 && !sFromDomain.empty()) {
+		for (list < string >::iterator i = SuccessfulDomains.begin(); i != SuccessfulDomains.end(); ++i) {
+			/* see if the successful domain is the same as or a parent of the From domain */
+			if (i->length() > sFromDomain.length())
+				continue;
+			if (_stricmp(i->c_str(), sFromDomain.c_str() + sFromDomain.length() - i->length()) != 0)
+				continue;
+			if (i->length() == sFromDomain.length() || sFromDomain.c_str()[sFromDomain.length() - i->length() - 1] == '.')
+				return ((SuccessCount == Signatures.size()) ? DKIM_SUCCESS : DKIM_PARTIAL_SUCCESS);
+		}
+	}
+	if (!m_Accept3ps)
+		return DKIM_NEUTRAL;
+	*sCount = SuccessCount;
+	*sSize = Signatures.size();
+	return DKIM_3PS_SIGNATURE;
+}
+
+/*
+ * Hash - update the hash
+ */
+void
+SignatureInfo::Hash(const char *szBuffer, unsigned nBufLength, bool IsBody)
+{
+
+	if (IsBody && BodyLength != -1) {
+		VerifiedBodyCount += nBufLength;
+		if (VerifiedBodyCount > BodyLength) {
+			nBufLength = BodyLength - (VerifiedBodyCount - nBufLength);
+			UnverifiedBodyCount += VerifiedBodyCount - BodyLength;
+			VerifiedBodyCount = BodyLength;
+			if (nBufLength == 0)
+				return;
+		}
+	}
+	if (IsBody && !BodyHashData.empty()) {
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+		EVP_DigestUpdate(m_Bdy_ctx, szBuffer, nBufLength);
+#else
+		EVP_DigestUpdate(&m_Bdy_ctx, szBuffer, nBufLength);
+#endif
+	} else {
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+		EVP_VerifyUpdate(m_Hdr_ctx, szBuffer, nBufLength);
+#if OPENSSL_VERSION_NUMBER >= 0x10101000L
+		SigHdr.append(szBuffer, nBufLength);
+#endif
+#else
+		EVP_VerifyUpdate(&m_Hdr_ctx, szBuffer, nBufLength);
+#endif
+	}
+	if (m_SaveCanonicalizedData)
+		CanonicalizedData.append(szBuffer, nBufLength);
+}
+
+/*- ProcessHeaders - Look for DKIM-Signatures and start processing them -*/
+int
+CDKIMVerify::ProcessHeaders(void)
+{
+	/*- look for DKIM-Signature header(s) -*/
+	int sigStatus = 0;
+
+	for (list < string >::iterator i = HeaderList.begin(); i != HeaderList.end(); ++i) {
+		if (_strnicmp(i->c_str(), "DKIM-Signature", 14) == 0) {
+			/*- skip over whitespace between the header name and : -*/
+			const char     *s = i->c_str() + 14;
+			while (*s == ' ' || *s == '\t')
+				s++;
+			if (*s == ':') {
+				/* found */
+				SignatureInfo   sig(m_SaveCanonicalizedData);
+				sigStatus = sig.Status = ParseDKIMSignature(*i, sig);
+				Signatures.push_back(sig);
+				if (Signatures.size() >= MAX_SIGNATURES)
+					break;
+			}
+		}
+	}
+	if (Signatures.empty())
+		return DKIM_NO_SIGNATURES;
+	bool            ValidSigFound = false;
+	for (list < SignatureInfo >::iterator s = Signatures.begin(); s != Signatures.end(); ++s) {
+		SignatureInfo &sig = *s;
+		if (sig.Status != DKIM_SUCCESS)
+			continue;
+		SelectorInfo &sel = GetSelector(sig.Selector, sig.Domain);
+		sig.m_pSelector = &sel;
+		if (sel.Status != DKIM_SUCCESS) {
+			sigStatus = sig.Status = sel.Status;
+			return (sig.Status);
+		} else {
+			/*- check the granularity -*/
+			if (!WildcardMatch(sel.Granularity.c_str(), sig.IdentityLocalPart.c_str()))
+				sigStatus = sig.Status = DKIM_SELECTOR_GRANULARITY_MISMATCH;	/* this error causes the signature to fail */
+			/*- check the hash algorithm -*/
+#ifdef HAVE_EVP_SHA256
+			if ((sig.m_nHash == DKIM_HASH_SHA1 && !sel.AllowSHA1) || (sig.m_nHash == DKIM_HASH_SHA256 && !sel.AllowSHA256))
+#else
+			if ((sig.m_nHash == DKIM_HASH_SHA1 && !sel.AllowSHA1))
+#endif
+				sigStatus = sig.Status = DKIM_SELECTOR_ALGORITHM_MISMATCH;	/* causes signature to fail */
+			/*- check for same domain RFC5672 -*/
+			if (sel.SameDomain && _stricmp(sig.Domain.c_str(), sig.IdentityDomain.c_str()) != 0)
+				sigStatus = sig.Status = DKIM_BAD_SYNTAX;
+		}
+		if (sig.Status != DKIM_SUCCESS)
+			continue;
+		/*- initialize the hashes -*/
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+		if (sig.m_nHash == DKIM_HASH_SHA256) {
+			EVP_VerifyInit(sig.m_Hdr_ctx, EVP_sha256());
+			EVP_DigestInit(sig.m_Bdy_ctx, EVP_sha256());
+		} else {
+			EVP_VerifyInit(sig.m_Hdr_ctx, EVP_sha1());
+			EVP_DigestInit(sig.m_Bdy_ctx, EVP_sha1());
+		}
+#else
+#ifdef HAVE_EVP_SHA256
+		if (sig.m_nHash == DKIM_HASH_SHA256) {
+			EVP_VerifyInit(&sig.m_Hdr_ctx, EVP_sha256());
+			EVP_DigestInit(&sig.m_Bdy_ctx, EVP_sha256());
+		} else {
+			EVP_VerifyInit(&sig.m_Hdr_ctx, EVP_sha1());
+			EVP_DigestInit(&sig.m_Bdy_ctx, EVP_sha1());
+		}
+#else
+		EVP_VerifyInit(&sig.m_Hdr_ctx, EVP_sha1());
+		EVP_DigestInit(&sig.m_Bdy_ctx, EVP_sha1());
+#endif
+#endif
+
+#if OPENSSL_VERSION_NUMBER >= 0x10101000L
+		if (sig.m_nHash == DKIM_HASH_SHA256)
+			SigHdr.assign("");
+#endif
+		/*- compute the hash of the header -*/
+		vector < list < string >::reverse_iterator > used;
+		for (vector < string >::iterator x = sig.SignedHeaders.begin(); x != sig.SignedHeaders.end(); ++x) {
+			list < string >::reverse_iterator i;
+			for (i = HeaderList.rbegin(); i != HeaderList.rend(); ++i) {
+				if (_strnicmp(i->c_str(), x->c_str(), x->length()) == 0) {
+					/*- skip over whitespace between the header name and : -*/
+					const char     *s = i->c_str() + x->length();
+					while (*s == ' ' || *s == '\t')
+						s++;
+					if (*s == ':' && find(used.begin(), used.end(), i) == used.end())
+						break;
+				}
+			}
+			if (i != HeaderList.rend()) {
+				used.push_back(i);
+				/*- hash this header -*/
+				if (sig.HeaderCanonicalization == DKIM_CANON_SIMPLE)
+					sig.Hash(i->c_str(), i->length());
+				else
+				if (sig.HeaderCanonicalization == DKIM_CANON_RELAXED) {
+					string          sTemp = RelaxHeader(*i);
+					sig.Hash(sTemp.c_str(), sTemp.length());
+				} else
+				if (sig.HeaderCanonicalization == DKIM_CANON_NOWSP) {
+					string          sTemp = *i;
+					RemoveSWSP(sTemp);
+					/*- convert characters before ':' to lower case -*/
+					for (char *s = (char *)sTemp.c_str(); *s != '\0' && *s != ':'; s++) {
+						if (*s >= 'A' && *s <= 'Z')
+							*s += 'a' - 'A';
+					}
+					sig.Hash(sTemp.c_str(), sTemp.length());
+				}
+				sig.Hash("\r\n", 2);
+			}
+		}
+		if (sig.BodyHashData.empty()) /*- hash CRLF separating headers from body -*/
+			sig.Hash("\r\n", 2);
+		if (!m_AllowUnsignedFromHeaders) {
+			/*- make sure the message has no unsigned From headers -*/
+			list<string>::reverse_iterator i;
+			for( i = HeaderList.rbegin(); i != HeaderList.rend(); ++i ) {
+				if( _strnicmp(i->c_str(), "From", 4 ) == 0 ) {
+					/*- skip over whitespace between the header name and : -*/
+					const char *s = i->c_str()+4;
+					while (*s == ' ' || *s == '\t')
+						s++;
+					if (*s == ':') {
+						if (find(used.begin(), used.end(), i) == used.end()) {
+							/*- this From header was not signed -*/
+							break;
+						}
+					}
+				}
+			}
+			if (i != HeaderList.rend()) {
+				/*- treat signature as invalid -*/
+				sigStatus = sig.Status = DKIM_UNSIGNED_FROM;
+				continue;
+			}
+		}
+		ValidSigFound = true;
+	} /*- for (list < SignatureInfo >::iterator s = Signatures.begin(); s != Signatures.end(); ++s) { */
+	if (!ValidSigFound)
+		return sigStatus ? sigStatus: DKIM_NO_VALID_SIGNATURES;
+	return DKIM_SUCCESS;
+}
+
+/*
+ * Strictly parse an unsigned integer.  Don't allow spaces, negative sign,
+ * 0x prefix, etc.  Values greater than 2^32-1 are capped at 2^32-1
+ */
+bool
+ParseUnsigned(const char *s, unsigned long *result)
+{
+	unsigned        temp = 0, last = 0;
+	bool            overflowed = false;
+
+	do {
+		if (*s < '0' || *s > '9')
+			return false;	/*- returns false for an initial '\0' */
+		temp = temp * 10 + (*s - '0');
+		if (temp < last)
+			overflowed = true;
+		last = temp;
+		s++;
+	} while (*s != '\0');
+	if (overflowed)
+		*result = -1;
+	else
+		*result = temp;
+	return true;
+}
+
+/*-
+ * ParseDKIMSignature - Parse a DKIM-Signature header field 
+ * The received DKIM header includes two cryptographic relevant informations:
+ *
+ * a) The 'body hash' => bh=[sha1|sha256]                     - values[12]
+ * b) The signature   =>  b=[RSA-SHA1|RSA-SHA256|PureEd25519] - values[2]
+ */
+int
+CDKIMVerify::ParseDKIMSignature(const string &sHeader, SignatureInfo &sig)
+{
+
+	/*- save header for later -*/
+	sig.Header = sHeader;
+	string          sValue = sHeader.substr(sHeader.find(':') + 1);
+	static const char *tags[] = { "v", "a", "b", "d", "h", "s", "c", "i", "l", "q", "t", "x", "bh", NULL };
+	char           *values[sizeof (tags) / sizeof (tags[0])] = { NULL };
+	char           *saveptr;
+
+	if (!ParseTagValueList((char *) sValue.c_str(), tags, values))
+		return DKIM_BAD_SYNTAX;
+	/*- check signature version -*/
+	if (values[0] != NULL) {
+		if (strcmp(values[0], "1") == 0 || strcmp(values[0], "0.5") == 0 || strcmp(values[0], "0.4") == 0
+			|| strcmp(values[0], "0.3") == 0 || strcmp(values[0], "0.2") == 0) {
+			sig.Version = DKIM_SIG_VERSION_02_PLUS;
+		} else /*- unknown version -*/
+			return DKIM_STAT_INCOMPAT;
+	} else {
+		/*-
+		 * Note:  DKIM Interop 1 pointed out that v= is now required, but we do
+		 * not enforce that in order to verify signatures made by older drafts.
+		 * prior to 0.2, there MUST NOT have been a v=
+		 * (optionally) support these signatures, for backwards compatibility
+		 */
+		if (true)
+			sig.Version = DKIM_SIG_VERSION_PRE_02;
+		else
+			return DKIM_BAD_SYNTAX;
+	}
+	/*- signature MUST have a=, b=, d=, h=, s= -*/
+	if (values[1] == NULL || values[2] == NULL || values[3] == NULL || values[4] == NULL || values[5] == NULL)
+		return DKIM_BAD_SYNTAX;
+	/*- algorithm can be "rsa-sha1" or "rsa-sha256" -*/
+	if (strcmp(values[1], "rsa-sha1") == 0)
+		sig.m_nHash = DKIM_HASH_SHA1;
+#ifdef HAVE_EVP_SHA256
+	else
+	if (strcmp(values[1], "rsa-sha256") == 0)
+		sig.m_nHash = DKIM_HASH_SHA256;
+#endif
+#if OPENSSL_VERSION_NUMBER >= 0x10101000L
+	else
+	if (strcmp(values[1], "ed25519-sha256") == 0)
+		sig.m_nHash = DKIM_HASH_SHA256;
+#endif
+	else
+		return DKIM_BAD_SYNTAX;	/* todo: maybe create a new error code for unknown algorithm */
+
+	/*- make sure the signature data is not empty -*/
+	unsigned SigDataLen = DecodeBase64(values[2]);
+	if (SigDataLen == 0)
+		return DKIM_BAD_SYNTAX;
+	sig.SignatureData.assign(values[2], SigDataLen);
+	/*- check for body hash -*/
+	if (values[12] == NULL) {
+		/*- use the old single hash way for backwards compatibility -*/
+		if (sig.Version != DKIM_SIG_VERSION_PRE_02)
+			return DKIM_BAD_SYNTAX;
+	} else {
+		unsigned BodyHashLen = DecodeBase64(values[12]);
+		if (BodyHashLen == 0)
+			return DKIM_BAD_SYNTAX;
+		sig.BodyHashData.assign(values[12], BodyHashLen);
+	}
+	/*- domain must not be empty -*/
+	if (*values[3] == '\0')
+		return DKIM_BAD_SYNTAX;
+	sig.Domain = values[3];
+	/*- signed headers must not be empty (more verification is done later) -*/
+	if (*values[4] == '\0')
+		return DKIM_BAD_SYNTAX;
+	/*- selector must not be empty -*/
+	if (*values[5] == '\0')
+		return DKIM_BAD_SYNTAX;
+	sig.Selector = values[5];
+	/*- canonicalization -*/
+	if (values[6] == NULL)
+		sig.HeaderCanonicalization = sig.BodyCanonicalization = DKIM_CANON_SIMPLE;
+	else
+	if (sig.Version == DKIM_SIG_VERSION_PRE_02 && strcmp(values[6], "nowsp") == 0) /*- for backwards compatibility -*/
+		sig.HeaderCanonicalization = sig.BodyCanonicalization = DKIM_CANON_NOWSP;
+	else {
+		char           *slash = strchr(values[6], '/');
+		if (slash != NULL)
+			*slash = '\0';
+		if (strcmp(values[6], "simple") == 0)
+			sig.HeaderCanonicalization = DKIM_CANON_SIMPLE;
+		else
+		if (strcmp(values[6], "relaxed") == 0)
+			sig.HeaderCanonicalization = DKIM_CANON_RELAXED;
+		else
+			return DKIM_BAD_SYNTAX;
+		if (slash == NULL || strcmp(slash + 1, "simple") == 0)
+			sig.BodyCanonicalization = DKIM_CANON_SIMPLE;
+		else
+		if (strcmp(slash + 1, "relaxed") == 0)
+			sig.BodyCanonicalization = DKIM_CANON_RELAXED;
+		else
+			return DKIM_BAD_SYNTAX;
+	}
+	/*- identity -*/
+	if (values[7] == NULL) {
+		sig.IdentityLocalPart.erase();
+		sig.IdentityDomain = sig.Domain;
+	} else {
+		/*- quoted-printable decode the value -*/
+		DecodeQuotedPrintable(values[7]);
+		/*- must have a '@' separating the local part from the domain -*/
+		char           *at = strchr(values[7], '@');
+		if (at == NULL)
+			return DKIM_BAD_SYNTAX;
+		*at = '\0';
+		char           *ilocalpart = values[7];
+		char           *idomain = at + 1;
+		/*- i= domain must be the same as or a subdomain of the d= domain -*/
+		int idomainlen = strlen(idomain);
+		int ddomainlen = strlen(values[3]);
+
+		/*- todo: maybe create a new error code for invalid identity domain -*/
+		if (idomainlen < ddomainlen)
+			return DKIM_BAD_SYNTAX;
+		if (_stricmp(idomain + idomainlen - ddomainlen, values[3]) != 0)
+			return DKIM_BAD_SYNTAX;
+		if (idomainlen > ddomainlen && idomain[idomainlen - ddomainlen - 1] != '.')
+			return DKIM_BAD_SYNTAX;
+		sig.IdentityLocalPart = ilocalpart;
+		sig.IdentityDomain = idomain;
+	}
+	/*- body count -*/
+	if (values[8] == NULL || !m_HonorBodyLengthTag)
+		sig.BodyLength = -1;
+	else
+	if (!ParseUnsigned(values[8], (unsigned long *) &sig.BodyLength))
+		return DKIM_BAD_SYNTAX;
+	/*- query methods -*/
+	if (values[9] != NULL) {
+
+		/*- make sure "dns" is in the list -*/
+		bool            HasDNS = false;
+		char           *s = strtok_r(values[9], ":", &saveptr);
+		while (s != NULL) {
+			if (strncmp(s, "dns", 3) == 0 && (s[3] == '\0' || s[3] == '/')) {
+				HasDNS = true;
+				break;
+			}
+			s = strtok_r(NULL, ": \t", &saveptr);
+		}
+		if (!HasDNS)
+			return DKIM_BAD_SYNTAX;	/* todo: maybe create a new error code for unknown query method */
+	}
+#if SIZEOF_TIME_T  == 8
+	/*- signature time -*/
+	time_t          SignedTime = -1;
+#else
+	long long       SignedTime = -1;
+#endif
+	if (values[10] != NULL && !ParseUnsigned(values[10], (unsigned long *) &SignedTime))
+		return DKIM_BAD_SYNTAX;
+	/*- expiration time -*/
+	if (values[11] == NULL)
+		sig.ExpireTime = -1;
+	else {
+		if (!ParseUnsigned(values[11], (unsigned long *) &sig.ExpireTime))
+			return DKIM_BAD_SYNTAX;
+		if (sig.ExpireTime != -1) {
+			/*- the value of x= MUST be greater than the value of t= if both are present -*/
+#if SIZEOF_TIME_T  == 8
+			if (SignedTime != -1 && sig.ExpireTime <= SignedTime)
+				return DKIM_BAD_SYNTAX;
+#else
+			if (SignedTime != -1 && (long long) sig.ExpireTime <= SignedTime)
+				return DKIM_BAD_SYNTAX;
+#endif
+			/*- todo: if possible, use the received date/time instead of the current time -*/
+			time_t curtime = time(NULL);
+#if SIZEOF_TIME_T  == 8
+			if (curtime > sig.ExpireTime)
+				return DKIM_SIGNATURE_EXPIRED;
+#else /*- handle year 2038 the best we can, beyond which one has to upgrade to a 64 bit os */
+			if (curtime < 2147483648 && curtime > sig.ExpireTime)
+				return DKIM_SIGNATURE_EXPIRED;
+#endif
+		}
+	}
+	/*- parse the signed headers list -*/
+	bool            HasFrom = false, HasSubject = false;
+	RemoveSWSP(values[4]);		/*- header names shouldn't have spaces in them so this should be ok... */
+	char           *s = strtok_r(values[4], ":", &saveptr);
+	
+	while (s != NULL) {
+		if (_stricmp(s, "From") == 0)
+			HasFrom = true;
+		else
+		if (_stricmp(s, "Subject") == 0)
+			HasSubject = true;
+		sig.SignedHeaders.push_back(s);
+		s = strtok_r(NULL, ":", &saveptr);
+	}
+	if (!HasFrom)
+		return DKIM_BAD_SYNTAX;	/*- todo: maybe create a new error code for h= missing From */
+	if (m_SubjectIsRequired && !HasSubject)
+		return DKIM_BAD_SYNTAX;	/*- todo: maybe create a new error code for h= missing Subject */
+	return DKIM_SUCCESS;
+}
+
+
+/*- ProcessBody - Process message body data -*/
+int
+CDKIMVerify::ProcessBody(char *szBuffer, int nBufLength, bool bEOF)
+{
+	bool            MoreBodyNeeded = false;
+
+	for (list < SignatureInfo >::iterator i = Signatures.begin(); i != Signatures.end(); ++i) {
+		if (i->Status != DKIM_SUCCESS)
+			continue;
+		if (i->BodyCanonicalization == DKIM_CANON_SIMPLE) {
+			if (nBufLength > 0) {
+				while (i->EmptyLineCount > 0) {
+					i->Hash("\r\n", 2, true);
+					i->EmptyLineCount--;
+				}
+				i->Hash(szBuffer, nBufLength, true);
+				i->Hash("\r\n", 2, true);
+			} else {
+				i->EmptyLineCount++;
+				if (bEOF)
+					i->Hash("\r\n", 2, true);
+			}
+		} else
+		if (i->BodyCanonicalization == DKIM_CANON_RELAXED) {
+			CompressSWSP(szBuffer, nBufLength);
+			if (nBufLength > 0) {
+				while (i->EmptyLineCount > 0) {
+					i->Hash("\r\n", 2, true);
+					i->EmptyLineCount--;
+				}
+				i->Hash(szBuffer, nBufLength, true);
+				if (!bEOF)
+					i->Hash("\r\n", 2, true);
+			} else
+				i->EmptyLineCount++;
+		} else
+		if (i->BodyCanonicalization == DKIM_CANON_NOWSP) {
+			RemoveSWSP(szBuffer, nBufLength);
+			i->Hash(szBuffer, nBufLength, true);
+		}
+		if (i->UnverifiedBodyCount == 0)
+			MoreBodyNeeded = true;
+	}
+	if (!MoreBodyNeeded)
+		return DKIM_FINISHED_BODY;
+	return DKIM_SUCCESS;
+}
+
+SelectorInfo::SelectorInfo(const string &sSelector, const string &sDomain):Selector(sSelector), Domain(sDomain)
+{
+	AllowSHA1 = true;
+#ifdef HAVE_EVP_SHA256
+	AllowSHA256 = true;
+#else
+	AllowSHA256 = false;
+#endif
+	PublicKey = NULL;
+	Testing = false;
+	SameDomain = false;
+	Status = DKIM_SUCCESS;
+} SelectorInfo::~SelectorInfo()
+{
+	if (PublicKey != NULL)
+		EVP_PKEY_free(PublicKey);
+}
+
+/*
+ * Parse - Parse a DKIM selector
+ */
+int
+SelectorInfo::Parse(char *Buffer)
+{
+	static const char *tags[] = { "v", "g", "h", "k", "p", "s", "t", "n", NULL };
+	char           *values[sizeof (tags) / sizeof (tags[0])] = { NULL };
+	char           *saveptr;
+
+	if (!ParseTagValueList(Buffer, tags, values))
+		return DKIM_SELECTOR_INVALID;
+	if (values[0] != NULL) {
+		/*- make sure the version is "DKIM1" -*/
+		if (strcmp(values[0], "DKIM1") != 0)
+			return DKIM_SELECTOR_INVALID;	/*- todo: maybe create a new error code for unsupported selector version */
+		/*- make sure v= is the first tag in the response  */
+		/*- todo: maybe don't enforce this, it seems unnecessary */
+		for (unsigned int j = 1; j < sizeof (values) / sizeof (values[0]); j++) {
+			if (values[j] != NULL && values[j] < values[0])
+				return DKIM_SELECTOR_INVALID;
+		}
+	}
+	/*- selector MUST have p= tag -*/
+	if (values[4] == NULL)
+		return DKIM_SELECTOR_INVALID;
+	/*- granularity -*/
+	if (values[1] == NULL)
+		Granularity = "*";
+
+	else
+		Granularity = values[1];
+	/*- hash algorithm -*/
+	if (values[2] == NULL) {
+		AllowSHA1 = true;
+#ifdef HAVE_EVP_SHA256
+		AllowSHA256 = true;
+#else
+		AllowSHA256 = false;
+#endif
+	} else {
+		/*- MUST include "sha1" or "sha256" -*/
+		char           *s = strtok_r(values[2], ":", &saveptr);
+
+		while (s != NULL) {
+			if (strcmp(s, "sha1") == 0)
+				AllowSHA1 = true;
+#ifdef HAVE_EVP_SHA256
+			else
+			if (strcmp(s, "sha256") == 0)
+				AllowSHA256 = true;
+#endif
+			s = strtok_r(NULL, ":", &saveptr);
+		}
+#ifdef HAVE_EVP_SHA256
+		if (!(AllowSHA1 || AllowSHA256))
+#else
+		if (!AllowSHA1)
+#endif
+			return DKIM_SELECTOR_INVALID;	/*- todo: maybe create a new error code for unsupported hash algorithm */
+	}
+	/*- key type a= -*/
+	if (values[3] == NULL)
+		method = DKIM_ENCRYPTION_RSA; /*- equivalent to k=rsa in selector */
+	else {
+		/* key type MUST be "rsa" or "ed25519" */
+#if OPENSSL_VERSION_NUMBER >= 0x10101000L
+		if (strcmp(values[3], "rsa") && strcmp(values[3], "ed25519"))
+			return DKIM_SELECTOR_INVALID;
+		if (!strcmp(values[3], "ed25519")) {
+			AllowSHA1 = false;
+			AllowSHA256 = true;
+			method = DKIM_ENCRYPTION_ED25519; /*- k=ed25519 in selector */
+		} else
+			method = DKIM_ENCRYPTION_RSA; /*- k=rsa in selector */
+#else
+		method = DKIM_ENCRYPTION_RSA; /*- k=rsa in selector */
+		if (strcmp(values[3], "rsa"))
+			return DKIM_SELECTOR_INVALID;
+#endif
+	}
+	/*- service type -*/
+	if (values[5] != NULL) {
+		/*- make sure "*" or "email" is in the list -*/
+		bool            ServiceTypeMatch = false;
+		char           *s = strtok_r(values[5], ":", &saveptr);
+		while (s != NULL) {
+			if (strcmp(s, "*") == 0 || strcmp(s, "email") == 0) {
+				ServiceTypeMatch = true;
+				break;
+			}
+			s = strtok_r(NULL, ":", &saveptr);
+		}
+		if (!ServiceTypeMatch)
+			return DKIM_SELECTOR_INVALID;
+	}
+	/*- flags -*/
+	if (values[6] != NULL) {
+		char           *s = strtok_r(values[6], ":", &saveptr);
+		while (s != NULL) {
+			if (strcmp(s, "y") == 0)
+				Testing = true;
+			else
+			if (strcmp(s, "s") == 0)
+				SameDomain = true;
+			s = strtok_r(NULL, ":", &saveptr);
+		}
+	}
+	/*- public key data */
+	{
+		unsigned        PublicKeyLen;
+		EVP_PKEY       *pkey;
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+		int             rtype;
+#endif
+#if OPENSSL_VERSION_NUMBER >= 0x10101000L
+		char            ed25519[61];
+#endif
+		char           *qq; /*- public key data */
+
+#if OPENSSL_VERSION_NUMBER >= 0x10101000L
+		if (values[3] && !strcmp(values[3], "ed25519")) {
+			strcpy(ed25519, "MCowBQYDK2VwAyEA");
+			if (strlen(values[4]) > 44)
+				return DKIM_SELECTOR_PUBLIC_KEY_INVALID;
+			strcat(ed25519, values[4]);
+			qq = ed25519;
+		} else
+#endif
+			qq = values[4];
+
+		PublicKeyLen = DecodeBase64(qq);
+		if (PublicKeyLen == 0)
+			return DKIM_SELECTOR_KEY_REVOKED; /*- this error causes the signature to fail */
+		if (!(pkey = d2i_PUBKEY(NULL, (const unsigned char **) &qq, PublicKeyLen)))
+			return DKIM_SELECTOR_PUBLIC_KEY_INVALID;
+		/*- make sure public key is the correct type (we only support rsa & ed25519) */
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+		rtype = EVP_PKEY_base_id(pkey);
+#if OPENSSL_VERSION_NUMBER >= 0x10101000L
+		if (rtype == EVP_PKEY_RSA || rtype == EVP_PKEY_RSA2 || rtype == EVP_PKEY_ED25519)
+#else
+		if (rtype == EVP_PKEY_RSA || rtype == EVP_PKEY_RSA2)
+#endif
+#else
+		if (pkey->type == EVP_PKEY_RSA || pkey->type == EVP_PKEY_RSA2)
+#endif
+			PublicKey = pkey;
+		else {
+			EVP_PKEY_free(pkey);
+			return DKIM_SELECTOR_PUBLIC_KEY_INVALID;
+		}
+	}
+	return DKIM_SUCCESS;
+}
+
+/*- GetSelector - Get a DKIM selector for a domain -*/
+SelectorInfo &CDKIMVerify::GetSelector(const string &sSelector, const string &sDomain)
+{
+	/*- see if we already have this selector -*/
+	for (list < SelectorInfo >::iterator i = Selectors.begin(); i != Selectors.end(); ++i) {
+		if (_stricmp(i->Selector.c_str(), sSelector.c_str()) == 0 && _stricmp(i->Domain.c_str(), sDomain.c_str()) == 0)
+			return *i;
+	}
+	Selectors.push_back(SelectorInfo(sSelector, sDomain));
+	SelectorInfo &sel = Selectors.back();
+	string sFQDN = sSelector;
+	sFQDN += "._domainkey.";
+	sFQDN += sDomain;
+	char            Buffer[4096];
+	int             DNSResult;
+
+	if (m_pfnSelectorCallback)
+		DNSResult = m_pfnSelectorCallback(sFQDN.c_str(), Buffer, sizeof(Buffer));
+	else
+		DNSResult = DNSGetTXT(sFQDN.c_str(), Buffer, sizeof(Buffer));
+	switch (DNSResult)
+	{
+	case DNSRESP_SUCCESS:
+		sel.Status = sel.Parse(Buffer);
+		break;
+	case DNSRESP_TEMP_FAIL:
+		sel.Status = DKIM_SELECTOR_DNS_TEMP_FAILURE;
+		break;
+	case DNSRESP_PERM_FAIL:
+	default:
+		sel.Status = DKIM_SELECTOR_DNS_PERM_FAILURE;
+		break;
+	case DNSRESP_DOMAIN_NAME_TOO_LONG:
+		sel.Status = DKIM_SELECTOR_DOMAIN_NAME_TOO_LONG;
+		break;
+	}
+	return sel;
+}
+
+/*- GetDetails - Get DKIM verification details (per signature) -*/
+int
+CDKIMVerify::GetDetails(int *nSigCount, DKIMVerifyDetails **pDetails)
+{
+	Details.clear();
+	for (list < SignatureInfo >::iterator i = Signatures.begin(); i != Signatures.end(); ++i) {
+		DKIMVerifyDetails d;
+		d.szSignature = (char *) i->Header.c_str();
+		d.szSignatureDomain = (char*)i->Domain.c_str();
+		d.szIdentityDomain = (char*)i->IdentityDomain.c_str();
+		d.nResult = i->Status;
+		d.szCanonicalizedData = (char *) i->CanonicalizedData.c_str();
+		Details.push_back(d);
+	}
+	*nSigCount = Details.size();
+	*pDetails = (*nSigCount != 0) ? &Details[0] : NULL;
+	return DKIM_SUCCESS;
+}
+
+char           *DKIM_CALL
+CDKIMVerify::GetDomain(void)
+{
+	static string   sFromDomain;
+	for (list <string>::iterator i = HeaderList.begin(); i != HeaderList.end(); ++i) {
+		if (_strnicmp(i->c_str(), "From", 4) == 0) {
+			/*- skip over whitespace between the header name and : -*/
+			const char     *s = i->c_str() + 4;
+			while (*s == ' ' || *s == '\t')
+				s++;
+			if (*s == ':') {
+				vector <string> Addresses;
+				if (ParseAddresses(s + 1, Addresses)) {
+					unsigned atpos = Addresses[0].find('@');
+					sFromDomain = Addresses[0].substr(atpos + 1);
+					break;
+				}
+			}
+		}
+	}
+	return ((char *) sFromDomain.c_str());
+}
+
+void
+getversion_dkimverify_cpp()
+{
+	static char    *x = (char *) "$Id: dkimverify.cpp,v 1.31 2023-02-12 10:37:15+05:30 Cprogrammer Exp mbhangui $";
+
+	x++;
+}
+
+/*
+ * $Log: dkimverify.cpp,v $
+ * Revision 1.31  2023-02-12 10:37:15+05:30  Cprogrammer
+ * fixed multi-signature verfication (rsa+ed25519)
+ *
+ * Revision 1.30  2023-02-12 08:11:20+05:30  Cprogrammer
+ * fixed verification of ed25519 signature without ASN.1 structure
+ *
+ * Revision 1.29  2023-02-02 17:38:00+05:30  Cprogrammer
+ * return actual signature error in ProcessHeaders instead of "no valid sigs"
+ *
+ * Revision 1.28  2023-01-30 18:28:59+05:30  Cprogrammer
+ * added comments for documenting code
+ *
+ * Revision 1.27  2023-01-29 22:05:00+05:30  Cprogrammer
+ * multiple DKIM-Signature of different methods verification fixed
+ *
+ * Revision 1.26  2023-01-27 19:38:57+05:30  Cprogrammer
+ * fixed openssl version for ed25519
+ *
+ * Revision 1.25  2023-01-26 22:46:48+05:30  Cprogrammer
+ * verify ed25519 signatures
+ *
+ * Revision 1.24  2020-09-30 20:46:33+05:30  Cprogrammer
+ * Darwin Port
+ *
+ * Revision 1.23  2019-05-22 11:29:09+05:30  Cprogrammer
+ * fix for 32 bit systems where time_t is 4 bytes & encounters year 2038 issue
+ *
+ * Revision 1.22  2019-05-21 22:27:17+05:30  Cprogrammer
+ * increased buffer size
+ *
+ * Revision 1.21  2019-02-17 11:32:05+05:30  Cprogrammer
+ * made scope of sFromDomain static
+ *
+ * Revision 1.20  2018-12-14 11:05:20+05:30  Cprogrammer
+ * fixed 'conversion from 'int' to 'char' inside {}” for cross compiling on arm
+ *
+ * Revision 1.19  2018-08-08 23:56:27+05:30  Cprogrammer
+ * changed comment style
+ *
+ * Revision 1.18  2017-09-05 11:00:33+05:30  Cprogrammer
+ * removed extra whitespace
+ *
+ * Revision 1.17  2017-09-03 14:02:04+05:30  Cprogrammer
+ * call EVP_MD_CTX_init() only once
+ *
+ * Revision 1.16  2017-09-01 12:46:05+05:30  Cprogrammer
+ * removed dkimd2i_PUBKEY function
+ *
+ * Revision 1.15  2017-08-31 17:04:34+05:30  Cprogrammer
+ * replaced d2i_PUBKEY() with dkimd2i_PUBKEY() to avoid SIGSEGV on X509_PUBKEY_free()
+ *
+ * Revision 1.14  2017-08-09 21:59:39+05:30  Cprogrammer
+ * fixed segmentation fault. Use EVP_MD_CTX_reset() instead of EVP_MD_CTX_free()
+ *
+ * Revision 1.13  2017-08-08 23:50:41+05:30  Cprogrammer
+ * openssl 1.1.0 port
+ *
+ * Revision 1.12  2017-05-23 09:23:45+05:30  Cprogrammer
+ * use strtok_r instead of strtok() for thread safe operation
+ *
+ * Revision 1.11  2016-03-01 16:24:00+05:30  Cprogrammer
+ * reverse value of m_SubjectIsRequired
+ *
+ * Revision 1.10  2015-12-15 16:05:00+05:30  Cprogrammer
+ * fixed issue with time comparision. Use time_t for time variables
+ *
+ * Revision 1.9  2011-06-04 10:05:01+05:30  Cprogrammer
+ * added signature and identity domain information to
+ *     DKIMVerifyDetails structure
+ *
+ * Revision 1.8  2011-06-04 09:37:13+05:30  Cprogrammer
+ * added AllowUnsignedFromHeaders
+ *
+ * Revision 1.7  2009-06-11 13:58:34+05:30  Cprogrammer
+ * port for DARWIN
+ *
+ * Revision 1.6  2009-05-31 21:09:29+05:30  Cprogrammer
+ * changed cast
+ *
+ * Revision 1.5  2009-03-27 20:19:58+05:30  Cprogrammer
+ * added ADSP code
+ *
+ * Revision 1.4  2009-03-26 15:12:05+05:30  Cprogrammer
+ * added ADSP code
+ *
+ * Revision 1.3  2009-03-25 08:38:20+05:30  Cprogrammer
+ * fixed indentation
+ *
+ * Revision 1.2  2009-03-21 11:57:40+05:30  Cprogrammer
+ * fixed indentation
+ *
+ * Revision 1.1  2009-03-21 08:43:13+05:30  Cprogrammer
+ * Initial revision
+ */
diff -Naur netqmail-1.06.org/dkimverify.h netqmail-1.06/dkimverify.h
--- netqmail-1.06.org/dkimverify.h	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/dkimverify.h	2023-01-31 19:02:41.000000000 +0530
@@ -0,0 +1,165 @@
+/*
+ *  Copyright 2005 Alt-N Technologies, Ltd. 
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License"); 
+ *  you may not use this file except in compliance with the License. 
+ *  You may obtain a copy of the License at 
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0 
+ *
+ *  This code incorporates intellectual property owned by Yahoo! and licensed 
+ *  pursuant to the Yahoo! DomainKeys Patent License Agreement.
+ *
+ *  Unless required by applicable law or agreed to in writing, software 
+ *  distributed under the License is distributed on an "AS IS" BASIS, 
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ *  See the License for the specific language governing permissions and 
+ *  limitations under the License.
+ *
+ */
+
+#ifndef DKIMVERIFY_H
+#define DKIMVERIFY_H
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+#include "dkimbase.h"
+#include <vector>
+
+#define DKIM_SIG_VERSION_PRE_02			0
+#define DKIM_SIG_VERSION_02_PLUS		1
+
+class           SelectorInfo {
+ public:
+	SelectorInfo(const string &sSelector, const string &sDomain);
+	~SelectorInfo();
+
+	string          Domain;
+	string          Selector;
+	string          Granularity;
+	bool            AllowSHA1;
+	bool            AllowSHA256;
+	EVP_PKEY       *PublicKey;	/* the public key */
+	bool            Testing;
+	bool            SameDomain;
+	int             method; /* rsa or ed25519 */
+	int             Status;
+	int             Parse(char *Buffer);
+};
+
+class           SignatureInfo {
+public:
+	SignatureInfo(bool SaveCanonicalizedData);
+	~SignatureInfo();
+
+	void            Hash(const char *szBuffer, unsigned nBufLength, bool IsBody = false);
+	string          Header;
+	unsigned        Version;
+	string          Domain;
+	string          Selector;
+	string          SignatureData;
+	string          BodyHashData;
+	string          IdentityLocalPart;
+	string          IdentityDomain;
+	string          CanonicalizedData;
+	vector <string> SignedHeaders;
+	long            BodyLength;
+	unsigned        HeaderCanonicalization;
+	unsigned        BodyCanonicalization;
+#if SIZEOF_TIME_T  == 8
+	time_t          ExpireTime;
+#else
+	long long       ExpireTime;
+#endif
+	long            VerifiedBodyCount;
+	long            UnverifiedBodyCount;
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+	EVP_MD_CTX     *m_Hdr_ctx = NULL;
+	EVP_MD_CTX     *m_Bdy_ctx = NULL;
+#if OPENSSL_VERSION_NUMBER >= 0x10101000L
+	EVP_MD_CTX     *m_Msg_ctx = NULL;
+#endif
+#else
+	EVP_MD_CTX      m_Hdr_ctx;
+	EVP_MD_CTX      m_Bdy_ctx;
+#endif
+	SelectorInfo   *m_pSelector;
+	int             Status;
+	int             m_nHash;	/* use one of the DKIM_HASH_xxx constants here */
+	unsigned        EmptyLineCount;
+	bool            m_SaveCanonicalizedData;
+};
+
+class           CDKIMVerify:public CDKIMBase {
+public:
+
+	CDKIMVerify();
+	~CDKIMVerify();
+
+	int             Init(DKIMVerifyOptions * pOptions);
+	int             GetResults(int *sCount, int *sSize);
+	int             GetDetails(int *nSigCount, DKIMVerifyDetails ** pDetails);
+	virtual int     ProcessHeaders(void);
+	virtual int     ProcessBody(char *szBuffer, int nBufLength, bool bEOF);
+	const char     *GetPractices() {return Practices.c_str();}
+	char           *DKIM_CALL GetDomain(void);
+
+protected:
+	int             ParseDKIMSignature(const string &sHeader, SignatureInfo &sig);
+	SelectorInfo   &GetSelector(const string &sSelector, const string &sDomain);
+	int             GetADSP(const string &sDomain, int &iADSP);
+	int             GetSSP(const string &sDomain, int &iSSP, bool &bTesting);
+	list <SignatureInfo> Signatures;
+	list <SelectorInfo> Selectors;
+	DKIMDNSCALLBACK m_pfnSelectorCallback;	/* selector record callback */
+	DKIMDNSCALLBACK m_pfnPracticesCallback;	/* SSP record callback */
+	bool            m_HonorBodyLengthTag;
+	bool            m_CheckPractices;
+	bool            m_Accept3ps;		/* TBS(Luc) : accept 3rd party signature(s) */
+	bool            m_SubjectIsRequired;
+	bool            m_SaveCanonicalizedData;
+	bool            m_AllowUnsignedFromHeaders;
+	vector <DKIMVerifyDetails> Details;
+	string          Practices;
+};
+
+#endif	/*- DKIMVERIFY_H */
+
+/*
+ * $Log: dkimverify.h,v $
+ * Revision 1.12  2023-01-29 22:06:08+05:30  Cprogrammer
+ * added new member 'method'
+ *
+ * Revision 1.11  2023-01-27 19:39:01+05:30  Cprogrammer
+ * fixed openssl version for ed25519
+ *
+ * Revision 1.10  2023-01-26 22:46:59+05:30  Cprogrammer
+ * added ed25519 signatures
+ *
+ * Revision 1.9  2019-06-14 21:25:11+05:30  Cprogrammer
+ * BUG - honor body length tag in verification. Changed data type for BodyLength
+ *
+ * Revision 1.8  2019-05-22 11:30:06+05:30  Cprogrammer
+ * fix for 32 bit systems where time_t is 4 bytes & encounters year 2038 issue
+ *
+ * Revision 1.7  2017-08-31 17:07:45+05:30  Cprogrammer
+ * fixed g++ compiler warning
+ *
+ * Revision 1.6  2017-08-09 22:03:46+05:30  Cprogrammer
+ * initialized EVP_MD_CTX variables
+ *
+ * Revision 1.5  2017-08-08 23:50:47+05:30  Cprogrammer
+ * openssl 1.1.0 port
+ *
+ * Revision 1.4  2015-12-15 16:03:09+05:30  Cprogrammer
+ * use time_t for ExpireTime
+ *
+ * Revision 1.3  2011-06-04 09:37:25+05:30  Cprogrammer
+ * added AllowUnsignedFromHeaders
+ *
+ * Revision 1.2  2009-03-26 15:12:15+05:30  Cprogrammer
+ * changes for ADSP
+ *
+ * Revision 1.1  2009-03-21 08:50:22+05:30  Cprogrammer
+ * Initial revision
+ */
diff -Naur netqmail-1.06.org/dknewkey.9 netqmail-1.06/dknewkey.9
--- netqmail-1.06.org/dknewkey.9	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/dknewkey.9	2023-02-19 19:43:59.000000000 +0530
@@ -0,0 +1,100 @@
+.TH dknewkey 8
+.SH NAME
+dknewkey \- create a new domain key
+
+.SH SYNOPSIS
+\fBdknewkey\fR [-\fBt\fR \fItype\fR] [-\fBd\fR \fIdomain\fR | --\fBdomain\fR \fIdomain\fR]
+[-\fBb\fR | --\fBbits\fR \fIbits\fR] [-\fBf\fR | --\fBforce\fR] [-\fBe\fR | --\fBenforce\fR]
+\fIselector\fR
+
+or
+
+\fBdknewkey\fR [-\fBp\fR | --\fBprint\fR]
+[-\fBd\fR \fIdomain\fR | --\fBdomain\fR \fIdomain\fR] [\fIselector\fR]
+
+or
+
+\fBdknewkey\fR [-\fBr\fR | --\fBremove\fR]
+[-\fBd\fR \fIdomain\fR | --\fBdomain\fR \fIdomain\fR] \fIselector\fR
+
+.SH DESCRIPTION
+.B dknewkey
+generates new DKIM keys and prints the associated DNS record (public key)
+on stdout. For RSA keys, it defaults to 2048 bit key size. This is
+controlled by the \fIbits\fR variable. ed25519 keys do not have a variable
+size. For RSA keys k=sha256 is now included in the public DNS record to
+prevent inadvertent use with the now obsolete sha1 hash algorithm (See RFC
+8301).
+
+.I selector
+is the file which will hold the private key. Additionally \fIselector.pub\fR
+containing the public key will be created.
+.I bits
+is the number of bits in the key. If not specified, defaults to 1024.
+To implement domainkeys you can use
+.B envrules
+in
+.B qmail-smtpd
+or
+.B spawn-filter
+to set the DKSIGN, DKIMSIGN variable to the path of the signature file holding
+the private key.
+
+.B dknewkey
+uses the following
+.B openssl
+command to generate the private/public keys
+.IP \[bu] 2
+openssl -genrsa -out \fIselector\fR \fIbits\fR # for RSA
+.IP \[bu]
+openssl genpkey -algorithm Ed25519 -out \fIselector\fR # for Ed25519
+.IP \[bu]
+openssl rsa -in \fIselector\fR -out \fIselector.pub\fR -pubout -outform PEM
+
+
+.SH OPTIONS
+.TP
+-\fBp\fR | --\fBprint\fR
+print DKIM public key for selector \fIselector\fR, domain \fIdomain\fR. If
+\fIselector\fR is not provided, all selectors will be printed. If
+\fIdomain\fR is not provided, all selectors for all domains will be printed.
+
+.TP
+-\fBr\fR | --\fBremove\fR
+remove DKIM keys for selector \fIselector\fR, domain \fIdomain\fR
+
+.TP
+-\fBt\fR \fItype\fR | --\fBtype\fR \fItype\fR
+Key type to use for cryptography method. Valid values are rsa and ed25519.
+Defaults to rsa.
+
+.TP
+-\fBd\fR \fIdomain\fR | --\fBdomain\fR \fIdomain\fR
+domain name for the DKIM key. The private key \fIselector\fR, public key
+\fIselector.pub\fR will be created in the directory
+@qsysconfdir@/control/domainkeys/\fIdomain\fR.
+
+If this is not specified, the private key \fIselector\fR, public key
+\fIselector.pub\fR will be created  in the directory
+@qsysconfdir@/control/domainkeys.
+
+.TP
+-\fBb\fR | --\fBbits\fR \fIkeysize\fR
+Specify the key size for the DKIM record. Default is 1024
+
+.TP
+-\fBf\fR | --\fBforce\fR
+Force creation of DKIM key even if it exists. Without this, \fBdknewkey\fR will not
+overwrite an existing DKIM key
+
+.TP
+-\fBe\fR | --\fBenforce\fR
+Create a production key. This will not have the t=y in the selector record
+
+.SH "SEE ALSO"
+qmail-dkim(8),
+qmail-smtpd(8),
+qmail-queue(8),
+spawn-filter(8),
+dkim(8),
+openssl(1)
diff -Naur netqmail-1.06.org/dknewkey.sh netqmail-1.06/dknewkey.sh
--- netqmail-1.06.org/dknewkey.sh	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/dknewkey.sh	2023-06-30 19:14:06.708102428 +0530
@@ -0,0 +1,324 @@
+#
+# $Id: dknewkey.sh,v 1.17 2023-02-11 23:01:57+05:30 Cprogrammer Exp mbhangui $
+#
+
+usage()
+{
+	echo "Usage: dknewkey [options] keyfile"
+	echo "options"
+	echo "       [-p | --print]          : print DKIM public keys"
+	echo "       [-r | --remove]         : remove DKIM keys"
+	echo "       [-d | --domain domain]  : domain name"
+	echo "       [-b | --bits   size]    : DKIM private key size"
+	echo "       [-t | --type   type]    : Key type (RSA or ED25519)"
+	echo "       [-e | --enforce]        : Key is not in testing"
+	echo "       [-f]                    : force DKIM private key creation"
+	exit $1
+}
+
+# split a long string into multiple strings
+# of length 255 or less.
+# Credits: J
+# See https://notes.sagredo.eu/en/qmail-notes-185/configuring-dkim-for-qmail-92.html#comment2961
+split_str()
+{
+	local INPUT="$1"
+	local LEN=$(echo "$INPUT" | wc -c)
+	local COUNT=$((LEN / 255))
+	for i in $(seq 0 $COUNT)
+	do
+		LINE=$(echo "$INPUT" | cut -c $((i * 255 + 1))-$(((i + 1) * 255)))
+		if [ $i -ne 0 ]; then
+			printf " "
+		fi
+		printf "\"%s\"" "${LINE}"
+	done
+}
+
+write_pub_key()
+{
+	local selector=$(basename $1)
+	local domain=$2
+	local pubkey=$3
+	if [ $testing -eq 1 ] ; then
+		t=" t=y;"
+	else
+		t=""
+	fi
+	if [ $bits -lt 2048 -o "$ktype" = "ed25519" ] ; then
+		printf "%s._domainkey.%s. IN TXT (\"v=DKIM1; k=%s;%s p=%s\")\n" "$selector" "$domain" "$ktype" "$t" "$pubkey"
+	else
+		printf "%s._domainkey.%s. IN TXT (" "$selector" "$domain"
+		split_str "v=DKIM1; k=$ktype;$t p=$pubkey"
+		printf ")\n"
+	fi
+}
+
+print_key()
+{
+	local domain=$1
+	local selector=$2
+	if [ -n "$selector" ] ; then
+		if [ -f $selector ] ; then
+			echo "DKIM Private key for $domain file $dir/$selector"
+			cat $selector
+			ls -l $dir/$selector
+			echo "------------------------------------------------------"
+		else
+			echo "DKIM Private key for $domain does not exist in $dir/$selector"
+			exit 2
+		fi
+		if [ -f $selector.pub ] ; then
+			echo "DKIM TXT record for $domain with selector=$selector file $dir/$selector.pub"
+			cat $selector.pub
+			ls -l $dir/$selector.pub
+			echo "------------------------------------------------------"
+		else
+			echo "DKIM TXT record for $domain with selector=$selector does not exist in $dir/$selector.pub"
+			exit 2
+		fi
+	else
+		for i in $(find . -name '*'.pub -print)
+		do
+			selector=$(basename $i | cut -d. -f1)
+			t=$(echo $i | cut -c3-)
+			echo "DKIM TXT record for $domain with selector=$selector file $dir/$t"
+			cat $i
+			ls -l $dir/$t
+			t=$(echo $t|sed 's{.pub{{')
+			ls -l $dir/$t
+			echo "------------------------------------------------------"
+		done
+		exit 0
+	fi
+}
+
+controldir=@qsysconfdir@/control
+SYSTEM=$(uname -s)
+if [ "$SYSTEM" = "FreeBSD" ] ; then
+	options=$(getopt eprfd:b:t: "$@")
+else
+	options=$(getopt -a -n dknewkey -o "eprfd:b:t:e" -l enforce,print,remove,force,domain:,bits:,type: -- "$@")
+fi
+if [ $? != 0 ]; then
+	usage 100
+fi
+if [ $(id -u) -ne 0 ] ; then
+	echo "dknewkey is not meant to be run by mere mortals. Use sudo to get superpowers"
+	exit 100
+fi
+
+do_print=0
+remove=0
+testing=1
+force=0
+bits=2048
+ktype="rsa"
+domain=""
+eval set -- "$options"
+while :; do
+	case "$1" in
+	-f | --force)
+	force=1
+	shift 1
+	;;
+	-p | --print)
+	do_print=1
+	shift 1
+	;;
+	-r | --remove)
+	remove=1
+	shift 1
+	;;
+	-d | --domain)
+	grep -w "$2" $controldir/rcpthosts $controldir/dkimdomain >/dev/null 2>&1
+	if [ $? -ne 0 ] ; then
+		echo "$domain not in rcpthosts or dkimdomain" 1>&2
+		exit 1
+	fi
+	domain="$2"
+	shift 2
+	;;
+	-b | --bits)
+	bits="$2"
+	shift 2
+	;;
+	-t | --ktype)
+	ktype=$(echo "$2" | tr '[:upper:]' '[:lower:]')
+	if [ "$ktype" != "rsa" -a "$ktype" != "ed25519" ] ; then
+		echo "Key type must be rsa or ed25519" 1>&2
+		exit 1
+	fi
+	shift 2
+	;;
+	-e | --enforce)
+	testing=0
+	shift 1
+	;;
+	--) # end of options
+	shift
+	break
+	;;
+	*)
+	echo "Unexpected option: $1 - this should not happen."
+	usage 100
+	;;
+	esac
+done
+if [ $do_print -eq 0 -a $# -ne 1 ] ; then
+	usage 100
+else
+	selector=$1
+fi
+if [ -z "$domain" ] ; then
+	dir=$controldir/domainkeys
+	if [ -f $controldir/defaultdomain ] ; then
+		domain=$(cat $controldir/defaultdomain)
+	else
+		domain=$(echo $([ -n "$HOSTNAME" ] && echo "$HOSTNAME" || uname -n) | sed 's/^\([^\.]*\)\.\([^\.]*\)\./\2\./')
+	fi
+else
+	dir=$controldir/domainkeys/$domain
+fi
+
+if [ $do_print -eq 1 ] ; then
+	cd $dir
+	if [ $? -ne 0 ] ; then
+		exit 2
+	fi
+	print_key "$domain" "$selector"
+elif [ $remove -eq 1 ] ; then
+	cd $dir
+	if [ $? -ne 0 ] ; then
+		exit 2
+	fi
+	echo "Removing DKIM Keys $selector, $selector.pub"
+	/bin/rm -f $selector $selector.pub
+	files=$(ls)
+	cd ..
+	if [ -d $domain -a -z "$files" ] ; then
+		echo "Removing empty directory $domain"
+		rmdir --ignore-fail-on-non-empty $dir
+	fi
+else
+	t=$(dirname $selector)
+	if [ "$t" != "$dir" -a "$t" != "." ] ; then
+		echo "WARNING!!!. Generating DKIM keys outside $dir"
+		dir=$t
+		selector=$(basename $selector)
+	fi
+	if [ ! -d $dir ] ; then
+		if (! mkdir -p $dir || ! chown root:qmail $dir || ! chmod 755 $dir) ; then
+			exit 1
+		fi
+	fi
+	cd $dir
+	if [ $? -ne 0 ] ; then
+		exit 2
+	fi
+	if [ -f $selector -a $force -eq 0 ] ; then
+		echo "DKIM private key $selector exists. Skipping private key generation" 1>&2
+		exit 1
+	fi
+	if [ -f $selector -a $force -eq 0 ] ; then
+		echo "DKIM public  key $selector.pub exists. Skipping public  key generation" 1>&2
+		exit 1
+	fi
+	err=$(mktemp -t dkkeyXXXXXXXXXX)
+	if [ $? -ne 0 ] ; then
+		echo "Unable to create temp files" 1>&2
+		exit 1
+	fi
+	exec 3>&2 # save stderr in fd 3
+	exec 2>$err
+	exec 0<$err
+	/bin/rm -f $err
+	echo "Generating $ktype DKIM private key keysize=$bits, file $dir/$selector"
+	if [ "$ktype" = "rsa" ] ; then
+		/usr/bin/openssl genrsa -out $selector $bits
+	else
+		/usr/bin/openssl genpkey -algorithm ed25519 -out $selector
+	fi
+	if [ $? -ne 0 ] ; then
+		/bin/cat
+		exit 1
+	fi
+
+	if [ "$ktype" = "rsa" ] ; then
+		echo "Generating $ktype DKIM public  key for $selector.domainkey.$domain, file $dir/$selector.pub, keysize=$bits"
+		pubkey=$(/usr/bin/openssl  rsa -in $selector -pubout -outform PEM | grep -v '^--' | tr -d '\n')
+	else
+		echo "Generating $ktype DKIM public  key for $selector.domainkey.$domain, file $dir/$selector.pub"
+		pubkey=$(/usr/bin/openssl pkey -pubout -in $selector | /usr/bin/openssl asn1parse -offset 12 -noout -out /dev/stdout | /usr/bin/openssl base64)
+	fi
+	if [ $? -ne 0 ] ; then
+		/bin/cat
+		exit 1
+	fi
+	write_pub_key "$selector" "$domain" "$pubkey" > $selector.pub
+	if [ $? -ne 0 ] ; then
+		/bin/cat
+		exit 1
+	fi
+
+	exec 2>&3 # restore stderr
+	if ( ! chown root:qmail $selector $selector.pub || ! chmod 640 $selector || ! chmod 644 $selector.pub) ; then
+		exit 1
+	fi
+	print_key "$domain" "$selector"
+fi
+exit 0
+
+#
+# $Log: dknewkey.sh,v $
+# Revision 1.17  2023-02-11 23:01:57+05:30  Cprogrammer
+# generate ed25519 public key without ASN.1 structure (skip first 12 bytes)
+#
+# Revision 1.16  2023-02-05 22:53:15+05:30  Cprogrammer
+# made key time argument case insenstive
+# added -e, --enforce option to disable dkim key test mode
+#
+# Revision 1.15  2023-01-26 22:29:12+05:30  Cprogrammer
+# added option to generate ed25519 DKIM keys
+#
+# Revision 1.14  2022-11-27 09:32:51+05:30  Cprogrammer
+# list public, private key using ls
+#
+# Revision 1.13  2022-10-02 21:55:50+05:30  Cprogrammer
+# refactored code
+#
+# Revision 1.12  2022-03-06 18:49:17+05:30  Cprogrammer
+# fix for FreeBSD (getopt usage).
+#
+# Revision 1.11  2021-09-11 18:55:36+05:30  Cprogrammer
+# changed owner/permissions of dkim private/public key pairs
+#
+# Revision 1.10  2021-08-24 11:29:21+05:30  Cprogrammer
+# check if domain exists in rcpthosts
+#
+# Revision 1.9  2021-08-23 17:34:19+05:30  Cprogrammer
+# fixed default_domain variable
+#
+# Revision 1.8  2021-08-21 21:33:14+05:30  Cprogrammer
+# fixed syntax error
+#
+# Revision 1.7  2021-08-19 19:54:39+05:30  Cprogrammer
+# added options to print, remove, generate DKIM keys
+#
+# Revision 1.6  2019-02-15 17:11:18+05:30  Cprogrammer
+# fixed checking of argument count
+#
+# Revision 1.5  2017-03-09 16:38:24+05:30  Cprogrammer
+# use full path of openssl
+#
+# Revision 1.4  2010-05-16 19:59:48+05:30  Cprogrammer
+# fix for Mac OS X
+#
+# Revision 1.3  2004-11-02 20:48:31+05:30  Cprogrammer
+# fixed error when dknewkey was called without arguments
+#
+# Revision 1.2  2004-10-21 21:54:25+05:30  Cprogrammer
+# create public key file
+#
+# Revision 1.1  2004-10-20 20:40:56+05:30  Cprogrammer
+# Initial revision
diff -Naur netqmail-1.06.org/dns.c netqmail-1.06/dns.c
--- netqmail-1.06.org/dns.c	2007-12-01 01:52:54.000000000 +0530
+++ netqmail-1.06/dns.c	2022-12-09 22:58:50.000000000 +0530
@@ -1,4 +1,3 @@
-#include <stdio.h>
 #include <netdb.h>
 #include <sys/types.h>
 #include <netinet/in.h>
@@ -19,10 +18,12 @@
 static unsigned short getshort(c) unsigned char *c;
 { unsigned short u; u = c[0]; return (u << 8) + c[1]; }
 
-static union { HEADER hdr; unsigned char buf[PACKETSZ]; } response;
+static struct { unsigned char *buf; } response;
+static int responsebuflen = 0;
 static int responselen;
 static unsigned char *responseend;
 static unsigned char *responsepos;
+static u_long saveresoptions;
 
 static int numanswers;
 static char name[MAXDNAME];
@@ -43,18 +44,33 @@
  errno = 0;
  if (!stralloc_copy(&glue,domain)) return DNS_MEM;
  if (!stralloc_0(&glue)) return DNS_MEM;
- responselen = lookup(glue.s,C_IN,type,response.buf,sizeof(response));
+ if (!responsebuflen)
+  if (response.buf = (unsigned char *)alloc(PACKETSZ+1))
+   responsebuflen = PACKETSZ+1;
+  else return DNS_MEM;
+
+ responselen = lookup(glue.s,C_IN,type,response.buf,responsebuflen);
+ if ((responselen >= responsebuflen) ||
+     (responselen > 0 && (((HEADER *)response.buf)->tc)))
+  {
+   if (responsebuflen < 65536)
+    if (alloc_re(&response.buf, responsebuflen, 65536))
+     responsebuflen = 65536;
+    else return DNS_MEM;
+    saveresoptions = _res.options;
+    _res.options |= RES_USEVC;
+    responselen = lookup(glue.s,C_IN,type,response.buf,responsebuflen);
+    _res.options = saveresoptions;
+  }
  if (responselen <= 0)
   {
    if (errno == ECONNREFUSED) return DNS_SOFT;
    if (h_errno == TRY_AGAIN) return DNS_SOFT;
    return DNS_HARD;
   }
- if (responselen >= sizeof(response))
-   responselen = sizeof(response);
  responseend = response.buf + responselen;
  responsepos = response.buf + sizeof(HEADER);
- n = ntohs(response.hdr.qdcount);
+ n = ntohs(((HEADER *)response.buf)->qdcount);
  while (n-- > 0)
   {
    i = dn_expand(response.buf,responseend,responsepos,name,MAXDNAME);
@@ -64,7 +80,7 @@
    if (i < QFIXEDSZ) return DNS_SOFT;
    responsepos += QFIXEDSZ;
   }
- numanswers = ntohs(response.hdr.ancount);
+ numanswers = ntohs(((HEADER *)response.buf)->ancount);
  return 0;
 }
 
diff -Naur netqmail-1.06.org/dns_text.c netqmail-1.06/dns_text.c
--- netqmail-1.06.org/dns_text.c	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/dns_text.c	2023-03-18 12:18:55.000000000 +0530
@@ -0,0 +1,217 @@
+#include "dns_text.h"
+#include <netdb.h>
+#include <sys/types.h>
+#include <netinet/in.h>
+#include <arpa/nameser.h>
+#include <resolv.h>
+#include <string.h>
+#include "stralloc.h"
+#include "str.h"
+#include "dns.h"
+#include "error.h"
+#include "byte.h"
+#include "alloc.h"
+#include <openssl/evp.h>
+
+#define MAX_EDNS_RESPONSE_SIZE 65536
+
+char           *
+dk_strdup(const char *s)
+{
+  char           *new = OPENSSL_malloc(str_len((char *) s) + 1);
+  if (new != 0)
+    str_copy(new, (char *) s);
+  return new;
+}
+
+static unsigned short getshort(c) unsigned char *c;
+{ unsigned short u; u = c[0]; return (u << 8) + c[1]; }
+
+static struct
+{
+  unsigned char  *buf;
+} response;
+static int      responsebuflen = 0;
+static int      responselen;
+static unsigned char *responseend;
+static unsigned char *responsepos;
+static u_long   saveresoptions;
+static int      (*lookup) () = res_query;
+static int      numanswers;
+static char     name[MAXDNAME];
+static stralloc glue = {0};
+static stralloc txt = { 0 };
+static stralloc result = { 0 };
+static stralloc sa = {0};
+
+static int resolve(stralloc *domain,int type)
+{
+ int n;
+ int i;
+
+ errno = 0;
+ if (!stralloc_copy(&glue,domain)) return DNS_MEM;
+ if (!stralloc_0(&glue)) return DNS_MEM;
+ if (!responsebuflen) {
+  if ((response.buf = malloc(PACKETSZ+1)))
+   responsebuflen = PACKETSZ+1;
+  else return DNS_MEM;
+ }
+
+ responselen = lookup(glue.s,C_IN,type,response.buf,responsebuflen);
+ if ((responselen >= responsebuflen) ||
+     (responselen > 0 && (((HEADER *)response.buf)->tc)))
+  {
+   if (responsebuflen < MAX_EDNS_RESPONSE_SIZE) {
+    unsigned char *newbuf = realloc(response.buf, MAX_EDNS_RESPONSE_SIZE);
+    if (newbuf) {
+     response.buf = newbuf;
+     responsebuflen = MAX_EDNS_RESPONSE_SIZE;
+    }
+    else return DNS_MEM;
+    saveresoptions = _res.options;
+    _res.options |= RES_USEVC;
+    responselen = lookup(glue.s,C_IN,type,response.buf,responsebuflen);
+    _res.options = saveresoptions;
+   }
+  }
+ if (responselen <= 0)
+  {
+   if (errno == ECONNREFUSED) return DNS_SOFT;
+   if (h_errno == TRY_AGAIN) return DNS_SOFT;
+   return DNS_HARD;
+  }
+ responseend = response.buf + responselen;
+ responsepos = response.buf + sizeof(HEADER);
+ n = ntohs(((HEADER *)response.buf)->qdcount);
+ while (n-- > 0)
+  {
+   i = dn_expand(response.buf,responseend,responsepos,name,MAXDNAME);
+   if (i < 0) return DNS_SOFT;
+   responsepos += i;
+   i = responseend - responsepos;
+   if (i < QFIXEDSZ) return DNS_SOFT;
+   responsepos += QFIXEDSZ;
+  }
+ numanswers = ntohs(((HEADER *)response.buf)->ancount);
+ return 0;
+}
+
+static int findtxt(int wanttype)
+{
+ unsigned short rrtype;
+ unsigned short rrdlen;
+ int i;
+
+ if (numanswers <= 0) return 2;
+ --numanswers;
+ if (responsepos == responseend) return DNS_SOFT;
+
+ i = dn_expand(response.buf,responseend,responsepos,name,MAXDNAME);
+ if (i < 0) return DNS_SOFT;
+ responsepos += i;
+
+ i = responseend - responsepos;
+ if (i < 4 + 3 * 2) return DNS_SOFT;
+
+ rrtype = getshort(responsepos);
+ rrdlen = getshort(responsepos + 8);
+ responsepos += 10;
+
+ if (rrtype == wanttype)
+  {
+   unsigned short txtpos;
+   unsigned char txtlen;
+
+   txt.len = 0;
+   for (txtpos = 0;txtpos < rrdlen;txtpos += txtlen)
+    {
+     txtlen = responsepos[txtpos++];
+     if (txtlen > rrdlen-txtpos) txtlen = rrdlen-txtpos;
+     if (!stralloc_catb(&txt,&responsepos[txtpos],txtlen)) return DNS_MEM;
+    }
+
+   responsepos += rrdlen;
+   return 1;
+ }
+
+ responsepos += rrdlen;
+ return 0;
+}
+
+static int
+dns_txtplus(char *domain)
+{
+  int             r;
+
+  if (!stralloc_copys(&sa, domain)) return DNS_MEM;
+  switch (resolve(&sa, T_TXT)) {
+  case DNS_MEM:
+    return DNS_MEM;
+  case DNS_SOFT:
+    return DNS_SOFT;
+  case DNS_HARD:
+    return DNS_HARD;
+  }
+  while ((r = findtxt(T_TXT)) != 2) {
+    if (r == DNS_SOFT)
+      return DNS_SOFT;
+    if (r == 1) {
+      if (!stralloc_cat(&result, &txt))
+        return DNS_MEM;
+    }
+  }
+  if (!stralloc_0(&result))
+    return DNS_MEM;
+  if (result.len)
+    return (0);
+  return DNS_HARD;
+}
+
+/*
+ * we always return a null-terminated string which has been malloc'ed.  The string
+ * is always in the tag=value form.  If a temporary or permanent error occurs,
+ * the string will be exactly "e=perm;" or "e=temp;".
+ * Note that it never returns NULL.
+ */
+char           *
+dns_text(char *dn)
+{
+  int             r;
+  
+  switch (r = dns_txtplus(dn))
+  {
+  case DNS_MEM:
+  case DNS_SOFT:
+    return dk_strdup("e=temp;");
+  case DNS_HARD:
+    return dk_strdup("e=perm;");
+  }
+  return dk_strdup(result.s);
+}
+
+int
+DNSGetTXT(const char *domain, char *buffer, int maxlen)
+{
+  char           *results;
+  int             len;
+
+  results = dns_text((char *) domain);
+  if (!strcmp(results, "e=perm;")) {
+    free(results);
+    return DNSRESP_PERM_FAIL;
+  } else
+  if (!strcmp(results, "e=temp;")) {
+    free(results);
+    return DNSRESP_TEMP_FAIL;
+  }
+  if ((len = strlen(results)) > maxlen - 1) {
+    free(results);
+    return DNSRESP_DOMAIN_NAME_TOO_LONG;
+  }
+  byte_copy(buffer, len, results);
+  buffer[len] = 0;
+  free(results);
+  return DNSRESP_SUCCESS;
+}
+// vim: shiftwidth=2:tabstop=4:softtabstop=4
diff -Naur netqmail-1.06.org/dns_text.h netqmail-1.06/dns_text.h
--- netqmail-1.06.org/dns_text.h	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/dns_text.h	2023-02-13 08:34:52.000000000 +0530
@@ -0,0 +1,38 @@
+/*
+ *  Copyright 2005 Alt-N Technologies, Ltd. 
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License"); 
+ *  you may not use this file except in compliance with the License. 
+ *  You may obtain a copy of the License at 
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0 
+ *
+ *  This code incorporates intellectual property owned by Yahoo! and licensed 
+ *  pursuant to the Yahoo! DomainKeys Patent License Agreement.
+ *
+ *  Unless required by applicable law or agreed to in writing, software 
+ *  distributed under the License is distributed on an "AS IS" BASIS, 
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ *  See the License for the specific language governing permissions and 
+ *  limitations under the License.
+ *
+ */
+#ifndef _DNS_TXT_H
+#define _DNS_TXT_H
+
+#define MAX_DOMAIN			254
+
+#define DNSRESP_SUCCESS					0	// DNS lookup returned sought after records
+#define DNSRESP_TEMP_FAIL				1	// No response from DNS server
+#define DNSRESP_PERM_FAIL				2	// DNS server returned error or no records
+#define DNSRESP_DOMAIN_NAME_TOO_LONG	3	// Domain name too long
+#define DNSRESP_NXDOMAIN				4	// DNS server returned Name Error
+#define DNSRESP_EMPTY					5	// DNS server returned successful response but no records
+
+#define DNS_SOFT -1
+#define DNS_HARD -2
+#define DNS_MEM  -3
+
+extern char *dns_text(char *szFQDN);
+extern int DNSGetTXT(const char *domain, char *buffer, int maxlen);
+#endif
diff -Naur netqmail-1.06.org/error.c netqmail-1.06/error.c
--- netqmail-1.06.org/error.c	1998-06-15 16:23:16.000000000 +0530
+++ netqmail-1.06/error.c	2023-01-31 22:15:05.000000000 +0530
@@ -31,6 +31,13 @@
 -4;
 #endif
 
+int error_isdir =
+#ifdef EISDIR
+EISDIR;
+#else
+-4;
+#endif
+
 int error_io =
 #ifdef EIO
 EIO;
diff -Naur netqmail-1.06.org/error.h netqmail-1.06/error.h
--- netqmail-1.06.org/error.h	2007-12-01 01:52:54.000000000 +0530
+++ netqmail-1.06/error.h	2023-01-31 22:10:54.000000000 +0530
@@ -8,6 +8,7 @@
 extern int error_noent;
 extern int error_txtbsy;
 extern int error_io;
+extern int error_isdir;
 extern int error_exist;
 extern int error_timeout;
 extern int error_inprogress;
diff -Naur netqmail-1.06.org/getDomainToken.c netqmail-1.06/getDomainToken.c
--- netqmail-1.06.org/getDomainToken.c	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/getDomainToken.c	2023-02-01 10:14:58.000000000 +0530
@@ -0,0 +1,114 @@
+/*
+ * $Log: getDomainToken.c,v $
+ * Revision 1.3  2021-08-28 23:05:10+05:30  Cprogrammer
+ * moved dtype enum delivery variable from variables.h to getDomainToken.h
+ *
+ * Revision 1.2  2021-05-29 23:37:58+05:30  Cprogrammer
+ * refactored for slowq-send
+ *
+ * Revision 1.1  2021-05-26 05:20:05+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
+#include <regex.h>
+#include "str.h"
+#include "stralloc.h"
+#include "env.h"
+#include "wildmat.h"
+#include "getDomainToken.h"
+#include "parse_env.h"
+
+#define REGCOMP(X,Y)    regcomp(&X, Y, REG_EXTENDED|REG_ICASE)
+#define REGEXEC(X,Y)    regexec(&X, Y, (size_t) 0, (regmatch_t *) 0, (int) 0)
+#ifndef REG_NOERROR
+#define REG_NOERROR 0
+#endif
+
+dtype           delivery;
+
+/*
+ * read control file filterargs which can be one of the three
+ * 1. domain:local:command with args
+ * 2. domain:remote:command with args
+ * 3. domain:command with args
+ * 4. domain:local:command with args:env1, env2, ...
+ * 5. domain:remote:command with args:env1, env2, ...
+ * 6. domain:command with args:env1, env2, ...
+ * here domain can be a wildcard or a regular expression if
+ * QREGEX environment variable is defined
+ */
+char           *
+getDomainToken(char *domain, stralloc *sa)
+{
+	regex_t         qreg;
+	int             len, n, retval;
+	char           *ptr, *p1, *p2;
+
+	for (len = 0, ptr = sa->s;len < sa->len;) {
+		len += ((n = str_len(ptr)) + 1);
+		for (p1 = ptr;*p1 && *p1 != ':';p1++);
+		if (*p1 == ':') {
+			*p1 = 0;
+			/*- check for env strings after command */
+			if (!str_diffn(p1 + 1, "remote:", 7))
+				for (p2 = p1 + 8; *p2 && *p2 != ':'; p2++);
+			else
+			if (!str_diffn(p1 + 1, "local:", 6))
+				for (p2 = p1 + 7; *p2 && *p2 != ':'; p2++);
+			else {
+				for (p2 = p1 + 1; *p2 && *p2 != ':'; p2++);
+			}
+			if (*p2 == ':') {
+				*p2 = 0;
+				parse_env(p2 + 1);
+			}
+			/*- build the regex */
+			if ((retval = str_diff(ptr, domain))) {
+				if (env_get("QREGEX")) {
+					if ((retval = REGCOMP(qreg, ptr)) == 0)
+						retval = (REGEXEC(qreg, domain) == REG_NOMATCH ? 1 : REG_NOERROR);
+					regfree(&qreg);
+				} else
+					retval = !wildmat_internal(domain, ptr);
+			}
+			*p1 = ':';
+			if (!retval) { /*- match occurred for domain or wildcard */
+				/* check for local/remote directives */
+				if (delivery == remote_delivery) { /*- domain:remote:command - remote delivery */
+					if (!str_diffn(p1 + 1, "remote:", 7))
+						return (p1 + 8);
+					if (!str_diffn(p1 + 1, "local:", 6)) {
+						ptr = sa->s + len;
+						continue; /*- skip local directives for remote mails */
+					}
+				} else
+				if (delivery == local_delivery) { /*- domain:local:command - local delivery */
+					if (!str_diffn(p1 + 1, "local:", 6))
+						return (p1 + 7);
+					if (!str_diffn(p1 + 1, "remote:", 7)) {
+						ptr = sa->s + len;
+						continue; /*- skip remote directives for local mails */
+					}
+				} if (delivery == local_or_remote) { /*- local/remote delivery */
+					if (!str_diffn(p1 + 1, "local:", 6))
+						return (p1 + 7);
+					if (!str_diffn(p1 + 1, "remote:", 7))
+						return (p1 + 8);
+				}
+				return (p1 + 1); /*- domain:command */
+			}
+		}
+		ptr = sa->s + len;
+	} /*- for (len = 0, ptr = sa->s;len < sa->len;) */
+	return ((char *) 0);
+}
+
+void
+getversion_getdomaintoke_c()
+{
+	static char    *x = "$Id: getDomainToken.c,v 1.3 2021-08-28 23:05:10+05:30 Cprogrammer Exp mbhangui $";
+
+	x = sccsidwildmath;
+	x = sccsidgetdomainth;
+	x++;
+}
diff -Naur netqmail-1.06.org/getDomainToken.h netqmail-1.06/getDomainToken.h
--- netqmail-1.06.org/getDomainToken.h	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/getDomainToken.h	2022-12-09 22:58:50.000000000 +0530
@@ -0,0 +1,27 @@
+/*
+ * $Log: getDomainToken.h,v $
+ * Revision 1.2  2021-08-28 23:03:41+05:30  Cprogrammer
+ * added dtype enum from variables.h
+ *
+ * Revision 1.1  2021-05-26 05:20:07+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
+#ifndef _GETDOMAINTOKEN_H
+#define _GETDOMAINTOKEN_H
+#include "stralloc.h"
+
+#ifndef	lint
+static char     sccsidgetdomainth[] = "$Id: getDomainToken.h,v 1.2 2021-08-28 23:03:41+05:30 Cprogrammer Exp mbhangui $";
+#endif
+
+typedef enum {
+	unknown,
+	local_delivery,
+	remote_delivery,
+	local_or_remote,
+} dtype;
+
+char           *getDomainToken(char *, stralloc *);
+
+#endif
diff -Naur netqmail-1.06.org/hier.c netqmail-1.06/hier.c
--- netqmail-1.06.org/hier.c	1998-06-15 16:23:16.000000000 +0530
+++ netqmail-1.06/hier.c	2023-02-18 17:13:53.000000000 +0530
@@ -32,6 +32,7 @@
   h(auto_qmail,auto_uido,auto_gidq,0755);
 
   d(auto_qmail,"control",auto_uido,auto_gidq,0755);
+  d(auto_qmail,"control/cache",auto_uidd,auto_gidq,0755);
   d(auto_qmail,"users",auto_uido,auto_gidq,0755);
   d(auto_qmail,"bin",auto_uido,auto_gidq,0755);
   d(auto_qmail,"boot",auto_uido,auto_gidq,0755);
@@ -104,10 +105,17 @@
   c(auto_qmail,"bin","qmail-start",auto_uido,auto_gidq,0700);
   c(auto_qmail,"bin","qmail-getpw",auto_uido,auto_gidq,0711);
   c(auto_qmail,"bin","qmail-local",auto_uido,auto_gidq,0711);
+  c(auto_qmail,"bin","spawn-filter",auto_uido,auto_gidq,0711);
+  c(auto_qmail,"bin","surblfilter",auto_uido,auto_gidq,0711);
+  c(auto_qmail,"bin","dk-filter",auto_uido,auto_gidq,0555);
+  c(auto_qmail,"bin","surblqueue",auto_uido,auto_gidq,0555);
   c(auto_qmail,"bin","qmail-remote",auto_uido,auto_gidq,0711);
   c(auto_qmail,"bin","qmail-rspawn",auto_uido,auto_gidq,0711);
   c(auto_qmail,"bin","qmail-clean",auto_uido,auto_gidq,0711);
   c(auto_qmail,"bin","qmail-send",auto_uido,auto_gidq,0711);
+  c(auto_qmail,"bin","dknewkey", auto_uido, auto_gidq, 0711);
+  c(auto_qmail,"bin","qmail-dkim",auto_uidq,auto_gidq,0711);
+  c(auto_qmail,"bin","dkim",auto_uidq,auto_gidq,0711);
   c(auto_qmail,"bin","splogger",auto_uido,auto_gidq,0711);
   c(auto_qmail,"bin","qmail-newu",auto_uido,auto_gidq,0700);
   c(auto_qmail,"bin","qmail-newmrh",auto_uido,auto_gidq,0700);
@@ -143,6 +151,7 @@
   c(auto_qmail,"bin","qail",auto_uido,auto_gidq,0755);
   c(auto_qmail,"bin","elq",auto_uido,auto_gidq,0755);
   c(auto_qmail,"bin","pinq",auto_uido,auto_gidq,0755);
+  c(auto_qmail,"bin","testqmail-dks",auto_uido,auto_gidq,0755);
 
   c(auto_qmail,"man/man5","addresses.5",auto_uido,auto_gidq,0644);
   c(auto_qmail,"man/cat5","addresses.0",auto_uido,auto_gidq,0644);
@@ -198,6 +207,15 @@
   c(auto_qmail,"man/cat1","tcp-env.0",auto_uido,auto_gidq,0644);
 
   c(auto_qmail,"man/man8","qmail-local.8",auto_uido,auto_gidq,0644);
+  c(auto_qmail,"man/man8","dkim.8",auto_uido,auto_gidq,0644);
+  c(auto_qmail,"man/man8","qmail-dkim.8",auto_uido,auto_gidq,0644);
+  c(auto_qmail,"man/cat8","qmail-dkim.0",auto_uido,auto_gidq,0644);
+  c(auto_qmail,"man/man8","dk-filter.8",auto_uido,auto_gidq,0644);
+  c(auto_qmail,"man/cat8","dk-filter.0",auto_uido,auto_gidq,0644);
+  c(auto_qmail,"man/man8","surblfilter.8",auto_uido,auto_gidq,0644);
+  c(auto_qmail,"man/cat8","surblfilter.0",auto_uido,auto_gidq,0644);
+  c(auto_qmail,"man/man8","spawn-filter.8",auto_uido,auto_gidq,0644);
+  c(auto_qmail,"man/cat8","spawn-filter.0",auto_uido,auto_gidq,0644);
   c(auto_qmail,"man/cat8","qmail-local.0",auto_uido,auto_gidq,0644);
   c(auto_qmail,"man/man8","qmail-lspawn.8",auto_uido,auto_gidq,0644);
   c(auto_qmail,"man/cat8","qmail-lspawn.0",auto_uido,auto_gidq,0644);
@@ -249,4 +267,5 @@
   c(auto_qmail,"man/cat8","qmail-smtpd.0",auto_uido,auto_gidq,0644);
   c(auto_qmail,"man/man8","qmail-command.8",auto_uido,auto_gidq,0644);
   c(auto_qmail,"man/cat8","qmail-command.0",auto_uido,auto_gidq,0644);
+  c(auto_qmail,"man/man8","dknewkey.8",auto_uido,auto_gidq,0644);
 }
diff -Naur netqmail-1.06.org/ip.h netqmail-1.06/ip.h
--- netqmail-1.06.org/ip.h	1998-06-15 16:23:16.000000000 +0530
+++ netqmail-1.06/ip.h	2022-12-09 22:58:50.000000000 +0530
@@ -2,6 +2,7 @@
 #define IP_H
 
 struct ip_address { unsigned char d[4]; } ;
+typedef struct  ip_address ip_addr;
 
 extern unsigned int ip_fmt();
 #define IPFMT 19
diff -Naur netqmail-1.06.org/macros.h netqmail-1.06/macros.h
--- netqmail-1.06.org/macros.h	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/macros.h	2022-12-09 22:58:50.000000000 +0530
@@ -0,0 +1,25 @@
+/*
+ * $Log: macros.h,v $
+ * Revision 1.1  2009-03-21 08:50:25+05:30  Cprogrammer
+ * Initial revision
+ *
+ *
+ * macros.h:  Useful macros
+ *
+ * Author:
+ *  Dick Porter (dick@ximian.com)
+ *
+ * (C) 2002 Ximian, Inc.
+ */
+
+#ifndef _WAPI_MACROS_H_
+#define _WAPI_MACROS_H_
+
+#include <sys/types.h>
+
+#define MAKEWORD(low, high) ((__uint16_t)(((__uint8_t)(low)) | \
+				       ((__uint16_t)((__uint8_t)(high))) << 8))
+#define LOBYTE(i16) ((__uint8_t)((i16) & 0xFF))
+#define HIBYTE(i16) ((__uint8_t)(((__uint16_t)(i16) >> 8) & 0xFF))
+
+#endif							/* _WAPI_MACROS_H_ */
diff -Naur netqmail-1.06.org/MakeArgs.c netqmail-1.06/MakeArgs.c
--- netqmail-1.06.org/MakeArgs.c	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/MakeArgs.c	2022-12-09 22:58:50.000000000 +0530
@@ -0,0 +1,144 @@
+/*
+ * $Log: MakeArgs.c,v $
+ * Revision 2.8  2007-12-21 14:35:42+05:30  Cprogrammer
+ * included env.h to prevent compiler warning
+ *
+ * Revision 2.7  2007-12-20 12:45:28+05:30  Cprogrammer
+ * expand environment variables with '$' sign
+ *
+ * Revision 2.6  2005-08-23 17:31:28+05:30  Cprogrammer
+ * removed sccsid variable
+ *
+ * Revision 2.5  2005-04-02 19:06:02+05:30  Cprogrammer
+ * djb version
+ *
+ * Revision 2.4  2005-03-30 22:52:47+05:30  Cprogrammer
+ * BUG - Incorrect free
+ *
+ * Revision 2.3  2004-07-12 22:47:58+05:30  Cprogrammer
+ * bug fix. Free all allocated members
+ *
+ * Revision 2.2  2002-12-21 18:21:09+05:30  Cprogrammer
+ * added functionality of escaping text via quotes
+ *
+ * Revision 2.1  2002-08-13 20:35:44+05:30  Cprogrammer
+ * addition spaces were not getting skipped
+ *
+ * Revision 1.2  2002-03-03 17:23:05+05:30  Cprogrammer
+ * replaced strcpy with scopy
+ *
+ * Revision 1.1  2001-12-13 01:46:09+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
+#include "alloc.h"
+#include "str.h"
+#include "stralloc.h"
+#include "env.h"
+#include <ctype.h>
+
+#define isEscape(ch) ((ch) == '"' || (ch) == '\'')
+
+/*
+ * function to expand a string into command line
+ * arguments. To free memory allocated by this
+ * function the following should be done
+ *
+ * free(argv);
+ *
+ */
+char          **
+MakeArgs(char *cmmd)
+{
+	char           *ptr, *marker;
+	char          **argv;
+	int             argc, idx;
+	static stralloc sptr = { 0 };
+
+	for (ptr = cmmd;*ptr && isspace((int) *ptr);ptr++);
+	idx = str_len(ptr);
+	if (!stralloc_copys(&sptr, ptr))
+		return((char **) 0);
+	if (!stralloc_0(&sptr))
+		return((char **) 0);
+	/*-
+	 * Get the number of arguments by counting
+	 * white spaces. Allow escape via the double
+	 * quotes character at the first word
+	 */
+	for (argc = 0, ptr = sptr.s;*ptr;)
+	{
+		for (;*ptr && isspace((int) *ptr);ptr++);
+		if (!*ptr)
+			break;
+		argc++;
+		marker = ptr;
+		/*- Move till you hit the next white space */
+		for (;*ptr && !isspace((int) *ptr);ptr++)
+		{
+			/*-
+			 * 1. If escape char is encounted skip till you
+			 *    hit the terminating escape char
+			 * 2. If terminating escape char is missing, come
+			 *    back to the start escape char
+			 */
+			if (ptr == marker && isEscape(*ptr))
+			{
+				for (ptr++;*ptr && !isEscape(*ptr);ptr++);
+				if (!*ptr)
+					ptr = marker;
+			}
+		} /*- for(;*ptr && !isspace((int) *ptr);ptr++) */
+	} /*- for (argc = 0, ptr = sptr.s;*ptr;) */
+	/*
+	 * Allocate memory to store the arguments
+	 * Do not bother extra bytes occupied by
+	 * white space characters.
+	 */
+	if (!(argv = (char **) alloc((argc + 1) * sizeof(char *))))
+		return ((char **) 0);
+	for (idx = 0, ptr = sptr.s;*ptr;)
+	{
+		for (;*ptr && isspace((int) *ptr);ptr++)
+			*ptr = 0;
+		if (!*ptr)
+			break;
+		if (*ptr == '$')
+			argv[idx++] = env_get(ptr + 1);
+		else
+			argv[idx++] = ptr;
+		marker = ptr;
+		for (;*ptr && !isspace((int) *ptr);ptr++)
+		{
+			if (ptr == marker && isEscape(*ptr))
+			{
+				for (ptr++;*ptr && !isEscape(*ptr);ptr++);
+				if (!*ptr)
+					ptr = marker;
+				else /*- Remove the quotes */
+				{
+					argv[idx - 1] += 1;
+					*ptr = 0;
+				}
+			}
+		}
+	} /*- for (idx = 0, ptr = sptr.s;*ptr;) */
+	argv[idx++] = (char *) 0;
+	return (argv);
+}
+
+void
+FreeMakeArgs(char **argv)
+{
+	alloc_free(argv);
+	return;
+}
+
+void
+getversion_MakeArgs__c()
+{
+	static char     *x = "$Id: MakeArgs.c,v 2.8 2007-12-21 14:35:42+05:30 Cprogrammer Stab mbhangui $";
+	x++;
+	x--;
+	return;
+}
diff -Naur netqmail-1.06.org/Makefile netqmail-1.06/Makefile
--- netqmail-1.06.org/Makefile	2007-12-01 01:52:54.000000000 +0530
+++ netqmail-1.06/Makefile	2023-02-19 08:36:10.000000000 +0530
@@ -807,8 +807,9 @@
 dnsptr dnsip dnsmxip dnsfq hostname ipmeprint qreceipt qsmhook qbiff \
 forward preline condredirect bouncesaying except maildirmake \
 maildir2mbox maildirwatch qail elq pinq idedit install-big install \
+qmail-dkim dkim spawn-filter dk-filter surblfilter \
 instcheck home home+df proc proc+df binm1 binm1+df binm2 binm2+df \
-binm3 binm3+df
+binm3 binm3+df surblqueue dknewkey
 
 load: \
 make-load warn-auto.sh systype
@@ -933,9 +934,10 @@
 qmail-smtpd.0 tcp-env.0 qmail-newmrh.0 qreceipt.0 qbiff.0 forward.0 \
 preline.0 condredirect.0 bouncesaying.0 except.0 maildirmake.0 \
 maildir2mbox.0 maildirwatch.0 qmail.0 qmail-limits.0 qmail-log.0 \
-qmail-control.0 qmail-header.0 qmail-users.0 dot-qmail.0 \
-qmail-command.0 tcp-environ.0 maildir.0 mbox.0 addresses.0 \
-envelopes.0 forgeries.0
+qmail-control.0 qmail-header.0 qmail-users.0 dot-qmail.0 dknewkey.8 \
+qmail-command.0 tcp-environ.0 maildir.0 mbox.0 addresses.0 dkim.8 \
+envelopes.0 forgeries.0 qmail-dkim.0 dk-filter.0 spawn-filter.0 \
+surblfilter.0
 
 mbox.0: \
 mbox.5
@@ -1107,6 +1109,28 @@
 	| sed s}SPAWN}"`head -1 conf-spawn`"}g \
 	> qmail-control.5
 
+qmail-dkim: \
+load qmail-dkim.o triggerpull.o fmtqfn.o now.o date822fmt.o \
+subgetopt.o MakeArgs.o datetime.a seek.a ndelay.a \
+dns_text.o open.a sig.a alloc.a substdio.a error.a \
+wildmat.o str.a case.a fs.a auto_qmail.o auto_split.o \
+parse_env.o auto_uids.o fd.a wait.a getDomainToken.o \
+env.a getln.a control.o stralloc.a dns.lib libdkim.a
+	g++ -o qmail-dkim qmail-dkim.o triggerpull.o fmtqfn.o now.o \
+	subgetopt.o MakeArgs.o date822fmt.o datetime.a seek.a ndelay.a \
+	dns_text.o open.a sig.a substdio.a error.a auto_qmail.o \
+	wildmat.o auto_split.o auto_uids.o fd.a wait.a \
+	getDomainToken.o parse_env.o \
+	-lcrypto env.a control.o open.a getln.a stralloc.a alloc.a \
+	substdio.a str.a case.a libdkim.a fs.a `cat dns.lib`
+
+qmail-dkim.o: \
+compile qmail-dkim.c readwrite.h sig.h exit.h open.h seek.h fmt.h \
+qmail.h alloc.h substdio.h datetime.h now.h datetime.h triggerpull.h extra.h \
+sgetopt.h env.h wait.h fd.h fork.h str.h dkim.h dns_text.h \
+auto_qmail.h auto_uids.h date822fmt.h fmtqfn.h
+	./compile -DHAVE_CONFIG_H qmail-dkim.c
+
 qmail-getpw: \
 load qmail-getpw.o case.a substdio.a error.a str.a fs.a auto_break.o \
 auto_usera.o
@@ -1125,6 +1149,33 @@
 	| sed s}SPAWN}"`head -1 conf-spawn`"}g \
 	> qmail-getpw.8
 
+qmail-dkim.0: qmail-dkim.8
+	nroff -man qmail-dkim.8 > qmail-dkim.0
+qmail-dkim.8: qmail-dkim.9
+	cat qmail-dkim.9 \
+	| sed s}@controldir\@}"`head -1 conf-qmail`/control"}g \
+	> qmail-dkim.8
+
+dkim.8: dkim.9
+	cat dkim.9 | sed s}@controldir\@}"`head -1 conf-qmail`/control"}g \
+	> dkim.8
+
+dk-filter.0: dk-filter.8
+	nroff -man dk-filter.8 > dk-filter.0
+dk-filter.8: dk-filter.9
+	cat dk-filter.9 \
+	| sed s}@controldir\@}"`head -1 conf-qmail`/control"}g \
+	> dk-filter.8
+
+dknewkey: dknewkey.sh warn-auto.sh
+	cat warn-auto.sh dknewkey.sh \
+	| sed s}@qsysconfdir\@}"`head -1 conf-qmail`"}g \
+	> dknewkey
+	chmod +x dknewkey
+dknewkey.8: dknewkey.9
+	cat dknewkey.9 | sed s}@qsysconfdir\@}"`head -1 conf-qmail`"}g \
+	> dknewkey.8
+
 qmail-getpw.o: \
 compile qmail-getpw.c readwrite.h substdio.h subfd.h substdio.h \
 error.h exit.h byte.h str.h case.h fmt.h auto_usera.h auto_break.h \
@@ -1200,11 +1251,11 @@
 qmail-lspawn: \
 load qmail-lspawn.o spawn.o prot.o slurpclose.o coe.o sig.a wait.a \
 case.a cdb.a fd.a open.a stralloc.a alloc.a substdio.a error.a str.a \
-fs.a auto_qmail.o auto_uids.o auto_spawn.o
+fs.a auto_qmail.o auto_uids.o auto_spawn.o envread.o str_diffn.o
 	./load qmail-lspawn spawn.o prot.o slurpclose.o coe.o \
 	sig.a wait.a case.a cdb.a fd.a open.a stralloc.a alloc.a \
 	substdio.a error.a str.a fs.a auto_qmail.o auto_uids.o \
-	auto_spawn.o 
+	auto_spawn.o envread.o str_diffn.o
 
 qmail-lspawn.0: \
 qmail-lspawn.8
@@ -1213,7 +1264,7 @@
 qmail-lspawn.o: \
 compile qmail-lspawn.c fd.h wait.h prot.h substdio.h stralloc.h \
 gen_alloc.h scan.h exit.h fork.h error.h cdb.h uint32.h case.h \
-slurpclose.h auto_qmail.h auto_uids.h qlx.h
+slurpclose.h auto_qmail.h auto_uids.h qlx.h env.h
 	./compile qmail-lspawn.c
 
 qmail-newmrh: \
@@ -1463,11 +1514,11 @@
 qmail-rspawn: \
 load qmail-rspawn.o spawn.o tcpto_clean.o now.o coe.o sig.a open.a \
 seek.a lock.a wait.a fd.a stralloc.a alloc.a substdio.a error.a str.a \
-auto_qmail.o auto_uids.o auto_spawn.o
+auto_qmail.o auto_uids.o auto_spawn.o envread.o str_diffn.o
 	./load qmail-rspawn spawn.o tcpto_clean.o now.o coe.o \
 	sig.a open.a seek.a lock.a wait.a fd.a stralloc.a alloc.a \
 	substdio.a error.a str.a auto_qmail.o auto_uids.o \
-	auto_spawn.o 
+	auto_spawn.o  envread.o str_diffn.o
 
 qmail-rspawn.0: \
 qmail-rspawn.8
@@ -1475,7 +1526,7 @@
 
 qmail-rspawn.o: \
 compile qmail-rspawn.c fd.h wait.h substdio.h exit.h fork.h error.h \
-tcpto.h
+tcpto.h env.h
 	./compile qmail-rspawn.c
 
 qmail-send: \
@@ -1541,8 +1592,7 @@
 	timeoutwrite.o ip.o ipme.o ipalloc.o control.o constmap.o \
 	received.o date822fmt.o now.o qmail.o cdb.a fd.a wait.a \
 	datetime.a getln.a open.a sig.a case.a env.a stralloc.a \
-	alloc.a substdio.a error.a str.a fs.a auto_qmail.o  `cat \
-	socket.lib`
+	alloc.a substdio.a error.a str.a fs.a auto_qmail.o `cat socket.lib`
 
 qmail-smtpd.0: \
 qmail-smtpd.8
@@ -1639,10 +1689,10 @@
 qreceipt: \
 load qreceipt.o headerbody.o hfield.o quote.o token822.o qmail.o \
 getln.a fd.a wait.a sig.a env.a stralloc.a alloc.a substdio.a error.a \
-str.a auto_qmail.o
+str.a auto_qmail.o scan_ulong.o
 	./load qreceipt headerbody.o hfield.o quote.o token822.o \
 	qmail.o getln.a fd.a wait.a sig.a env.a stralloc.a alloc.a \
-	substdio.a error.a str.a auto_qmail.o 
+	substdio.a error.a str.a auto_qmail.o scan_ulong.o
 
 qreceipt.0: \
 qreceipt.1
@@ -1912,11 +1962,11 @@
 	./compile splogger.c
 
 str.a: \
-makelib str_len.o str_diff.o str_diffn.o str_cpy.o str_chr.o \
+makelib str_len.o str_diff.o str_diffn.o str_cpy.o str_cpyb.o str_chr.o \
 str_rchr.o str_start.o byte_chr.o byte_rchr.o byte_diff.o byte_copy.o \
 byte_cr.o byte_zero.o
 	./makelib str.a str_len.o str_diff.o str_diffn.o str_cpy.o \
-	str_chr.o str_rchr.o str_start.o byte_chr.o byte_rchr.o \
+	str_cpyb.o str_chr.o str_rchr.o str_start.o byte_chr.o byte_rchr.o \
 	byte_diff.o byte_copy.o byte_cr.o byte_zero.o
 
 str_chr.o: \
@@ -1927,6 +1977,10 @@
 compile str_cpy.c str.h
 	./compile str_cpy.c
 
+str_cpyb.o: \
+compile str_cpyb.c str.h
+	./compile str_cpyb.c
+
 str_diff.o: \
 compile str_diff.c str.h
 	./compile str_diff.c
@@ -2139,3 +2193,172 @@
 wait_pid.o: \
 compile wait_pid.c error.h haswaitp.h
 	./compile wait_pid.c
+MakeArgs.o: compile MakeArgs.c alloc.h str.h alloc.h stralloc.h
+	./compile MakeArgs.c
+
+spawn-filter: \
+load spawn-filter.o auto_qmail.o getDomainToken.o \
+parse_env.o fmt_ulong.o scan_ulong.o control.o \
+open_read.o wildmat.o qregex.o MakeArgs.o \
+case_lowerb.o constmap.o byte_chr.o byte_cr.o case_diffb.o \
+error.a env.a stralloc.a wait.a strerr.a str.a \
+getln.a substdio.a alloc.a
+	./load spawn-filter getDomainToken.o parse_env.o \
+	fmt_ulong.o scan_ulong.o control.o open_read.o \
+	wildmat.o qregex.o MakeArgs.o case_lowerb.o \
+	constmap.o byte_chr.o byte_cr.o case_diffb.o \
+	auto_qmail.o \
+	error.a env.a stralloc.a wait.a strerr.a str.a \
+	getln.a substdio.a alloc.a
+
+spawn-filter.o: \
+compile spawn-filter.c fmt.h str.h strerr.h env.h \
+substdio.h stralloc.h error.h \
+wait.h qregex.h  getDomainToken.h
+	./compile spawn-filter.c
+
+qregex.o: \
+compile qregex.c case.h stralloc.h constmap.h substdio.h byte.h env.h
+	./compile qregex.c
+
+getDomainToken.o: \
+compile getDomainToken.c getDomainToken.h \
+parse_env.h wildmat.h
+	./compile getDomainToken.c
+
+parse_env.o: \
+compile parse_env.c parse_env.h
+	./compile parse_env.c
+
+wildmat.o: \
+compile wildmat.c
+	./compile wildmat.c
+
+spawn-filter.0: \
+spawn-filter.8
+	nroff -man spawn-filter.8 > spawn-filter.0
+
+spawn-filter.8: \
+spawn-filter.9
+	cat spawn-filter.9 \
+	| sed s}QMAILHOME}"`head -1 conf-qmail`"}g \
+	> spawn-filter.8
+
+str_cspn.o: \
+compile str.h str_cspn.c
+	./compile str_cspn.c
+
+mess822_ok.o: \
+compile mess822_ok.c uint64.h
+
+surblfilter.0: surblfilter.8
+	nroff -man surblfilter.8 > surblfilter.0
+
+surblfilter.8: surblfilter.9
+	cat surblfilter.9 \
+	| sed s}QMAILHOME}"`head -1 conf-qmail`"}g \
+	> surblfilter.8
+
+surblfilter: \
+load surblfilter.o envread.o strerr_die.o strerr_sys.o \
+control.o alloc.o alloc_re.o error.o \
+error_str.o auto_qmail.o \
+case_startb.o byte_diff.o str_cspn.o \
+byte_copy.o byte_chr.o byte_rchr.o byte_cr.o \
+getln.o getln2.o open_read.o str_len.o str_diffn.o \
+str_cpy.o str_chr.o scan_xlong.o \
+now.o scan_ulong.o mess822_ok.o constmap.o \
+ip.o dns.o ipalloc.o fmt_str.o fmt_ulong.o \
+socket_v6any.o socket_v4mappedprefix.o \
+sgetopt.o subgetopt.o base64sub.o \
+case_diffb.o stralloc.a substdio.a
+	./load surblfilter envread.o strerr_die.o strerr_sys.o \
+	control.o alloc.o alloc_re.o error.o \
+	error_str.o auto_qmail.o \
+	case_startb.o byte_diff.o str_cspn.o \
+	byte_copy.o byte_chr.o byte_rchr.o byte_cr.o \
+	getln.o getln2.o open_read.o str_len.o str_diffn.o \
+	str_cpy.o str_chr.o scan_xlong.o \
+	now.o scan_ulong.o mess822_ok.o constmap.o \
+	ip.o dns.o ipalloc.o fmt_str.o fmt_ulong.o \
+	socket_v6any.o socket_v4mappedprefix.o \
+	sgetopt.o subgetopt.o base64sub.o \
+	case_diffb.o stralloc.a substdio.a -lresolv
+
+surblfilter.o: \
+compile surblfilter.c alloc.h error.h str.h case.h \
+constmap.h auto_qmail.h stralloc.h env.h control.h \
+strerr.h substdio.h getln.h byte.h dns.h ip.h \
+ipalloc.h mess822.h scan.h subgetopt.h uint64.h \
+base64.h
+	./compile surblfilter.c
+
+surblqueue: \
+surblqueue.sh conf-qmail
+	cat warn-auto.sh surblqueue.sh \
+	| sed s}QMAIL}"`head -1 conf-qmail`"}g \
+	> surblqueue
+	chmod 755 surblqueue
+
+hastai.h: \
+trytai.c compile load
+	(( ./compile trytai.c && ./load trytai -ltai) >/dev/null \
+	2>&1 \
+	&& echo \#define HASTAI 1 || exit 0 ) > hastai.h
+	rm -f trytai.o trytai
+
+uint64.h: \
+tryulong64.c compile load uint64.h1 uint64.h2
+	( ( ./compile tryulong64.c && ./load tryulong64 && \
+	./tryulong64 ) >/dev/null 2>&1 \
+	&& cat uint64.h1 || cat uint64.h2 ) > uint64.h
+	rm -f tryulong64.o tryulong64
+
+base64sub.o: \
+compile base64sub.c base64.h stralloc.h substdio.h str.h
+	./compile base64sub.c
+
+dk-filter: \
+warn-auto.sh dk-filter.sh conf-qmail
+	cat warn-auto.sh dk-filter.sh \
+	| sed s}QMAILHOME}"`head -1 conf-qmail`"}g \
+	| sed s}PREFIX}"`head -1 conf-qmail`"}g \
+	| sed s}@controldir\@}"`head -1 conf-qmail`/control"}g \
+	> dk-filter
+	chmod +x $@
+
+DKIMHDRS = dkim.h dkimbase.h dkimsign.h dkimverify.h time_t_size.h
+DKIMSRCS = dkimfuncs.cpp dkimbase.cpp
+DKIMOBJS = $(DKIMSRCS:.cpp=.o)
+
+time_t_size.h: time_t_size.c compile load
+	(./compile time_t_size.c && ./load time_t_size && \
+		./time_t_size) > time_t_size.h
+	rm -f time_t_size.o time_t_size
+
+dkimfuncs.o: dkimfuncs.cpp time_t_size.h
+	g++ -g -DHAVE_EVP_SHA256 -c dkimfuncs.cpp
+
+dkimverify.o: dkim.h dns_text.h dkimverify.h dkimverify.cpp time_t_size.h
+	g++ -g -DHAVE_EVP_SHA256 -c dkimverify.cpp
+
+dkimsign.o: dkim.h dkimsign.h dkimsign.cpp
+	g++ -g -DHAVE_EVP_SHA256 -c dkimsign.cpp
+
+dkim: libdkim.a dkim.o dns_text.h dns_text.o \
+error.o alloc.o alloc_re.o str.a stralloc.a dns.lib
+	g++ -o dkim $(LFLAGS) -L. dkim.o dns_text.o str.a \
+	error.o alloc.o alloc_re.o stralloc.a libdkim.a \
+	`cat dns.lib` -lcrypto
+	
+dkim.o: dkim.c $(DKIMHDRS)
+	gcc -c -g -DHAVE_OPENSSL_EVP_H -DHAVE_EVP_SHA256 -I. -DHAVE_EVP_SHA256 dkim.c
+
+dns_text.o: compile dns_text.c dns.h dns_text.h
+	./compile -I. dns_text.c
+
+libdkim.a: $(DKIMOBJS) dkimverify.o dkimsign.o makelib time_t_size.h
+	rm -f libdkim.a
+	./makelib libdkim.a $(DKIMOBJS) dkimsign.o dkimverify.o
+.cpp.o:
+	g++ -g -I. -DHAVE_EVP_SHA256 $(CFLAGS) $(INCL) -c $<
diff -Naur netqmail-1.06.org/mess822.h netqmail-1.06/mess822.h
--- netqmail-1.06.org/mess822.h	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/mess822.h	2022-12-09 22:58:50.000000000 +0530
@@ -0,0 +1,55 @@
+/*
+ * $Log: mess822.h,v $
+ * Revision 1.3  2004-10-11 13:55:55+05:30  Cprogrammer
+ * added function prototypes
+ *
+ * Revision 1.2  2004-06-18 23:00:58+05:30  Cprogrammer
+ * added RCS log
+ *
+ */
+#ifndef MESS822_H
+#define MESS822_H
+#include "stralloc.h"
+#include "caltime.h"
+
+#define MESS822_HEADER { {0} }
+
+typedef struct
+{
+	struct caltime  ct;
+	int             known; /*- 0 for ct uninitialized; 1 if ok; 2 if ok and right zone */
+}
+mess822_time;
+
+typedef struct
+{
+	char           *name; /*- 0 means all names */
+	int            *flag;
+	stralloc       *copy;
+	stralloc       *value;
+	stralloc       *addr;
+	mess822_time   *when;
+}
+mess822_action;
+
+typedef struct
+{
+	stralloc        inprogress;
+	mess822_action *action;
+}
+mess822_header;
+
+int             mess822_quoteplus(stralloc *, char *, char *);
+int             mess822_quote(stralloc *, char *, char *);
+int             mess822_quotelist(stralloc *, stralloc *);
+int             mess822_fold(stralloc *, stralloc *, char *, int);
+int             mess822_date(stralloc *, mess822_time *);
+int             mess822_token(stralloc *, char *);
+int             mess822_addrlist(stralloc *, char *);
+int             mess822_when(mess822_time *, char *);
+int             mess822_begin(mess822_header *, mess822_action *);
+int             mess822_line(mess822_header *, stralloc *);
+int             mess822_end(mess822_header *);
+int             mess822_ok(stralloc *);
+
+#endif
diff -Naur netqmail-1.06.org/mess822_ok.c netqmail-1.06/mess822_ok.c
--- netqmail-1.06.org/mess822_ok.c	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/mess822_ok.c	2022-12-09 22:58:50.000000000 +0530
@@ -0,0 +1,55 @@
+/*
+ * $Log: mess822_ok.c,v $
+ * Revision 1.2  2004-10-22 20:27:30+05:30  Cprogrammer
+ * added RCS id
+ *
+ * Revision 1.1  2004-01-04 23:17:51+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
+#include "mess822.h"
+#include "byte.h"
+
+int
+mess822_ok(sa)
+	stralloc       *sa;
+{
+	int             i;
+	int             len;
+	int             colon;
+
+	len = sa->len;
+	if (len && (sa->s[len - 1] == '\n'))
+		--len;
+	if (!len)
+		return 0;
+	/*
+	 * if input message is 822-compliant, will return 1 after this 
+	 */
+	if (sa->s[0] == ' ')
+		return 1;
+	if (sa->s[0] == '\t')
+		return 1;
+	colon = byte_chr(sa->s, sa->len, ':');
+	if (colon >= sa->len)
+		return 0;
+	while (colon && ((sa->s[colon - 1] == ' ') || (sa->s[colon - 1] == '\t')))
+		--colon;
+	if (!colon)
+		return 0;
+	for (i = 0; i < colon; ++i)
+		if (sa->s[i] < 33)
+			return 0;
+	for (i = 0; i < colon; ++i)
+		if (sa->s[i] > 126)
+			return 0;
+	return 1;
+}
+
+void
+getversion_mess822_ok_c()
+{
+	static char    *x = "$Id: mess822_ok.c,v 1.2 2004-10-22 20:27:30+05:30 Cprogrammer Stab mbhangui $";
+
+	x++;
+}
diff -Naur netqmail-1.06.org/parse_env.c netqmail-1.06/parse_env.c
--- netqmail-1.06.org/parse_env.c	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/parse_env.c	2023-02-01 10:13:58.000000000 +0530
@@ -0,0 +1,57 @@
+/*-
+ * $Id: parse_env.c,v 1.1 2023-01-13 12:14:53+05:30 Cprogrammer Exp mbhangui $
+ */
+#include <ctype.h>
+#include "env.h"
+#include "parse_env.h"
+
+int
+parse_env(char *envStrings)
+{
+	char           *ptr1, *ptr2, *ptr3, *ptr4;
+
+	for (ptr2 = ptr1 = envStrings;*ptr1;ptr1++) {
+		if (*ptr1 == ',') {
+			/*
+			 * Allow ',' in environment variable if escaped
+			 * by '\' character
+			 */
+			if (ptr1 != envStrings && *(ptr1 - 1) == '\\') {
+				for (ptr3 = ptr1 - 1, ptr4 = ptr1; *ptr3; *ptr3++ = *ptr4++);
+				continue;
+			}
+			*ptr1 = 0;
+			/*- envar=, - Unset the environment variable */
+			if (ptr1 != envStrings && *(ptr1 - 1) == '=') {
+				*(ptr1 - 1) = 0;
+				if (*ptr2 && !env_unset(ptr2))
+					return (1);
+			} else { /*- envar=val, - Set the environment variable */
+				while (isspace(*ptr2))
+					ptr2++;
+				if (*ptr2 && !env_put(ptr2))
+					return (1);
+			}
+			ptr2 = ptr1 + 1;
+		}
+	}
+	/*- envar=, */
+	if (ptr1 != envStrings && *(ptr1 - 1) == '=') {
+		*(ptr1 - 1) = 0;
+		if (*ptr2 && !env_unset(ptr2))
+			return (1);
+	} else { /*- envar=val, */
+		while (isspace(*ptr2))
+			ptr2++;
+		if (*ptr2 && !env_put(ptr2))
+			return (1);
+	}
+	return (0);
+}
+
+/*-
+ * $Log: parse_env.c,v $
+ * Revision 1.1  2023-01-13 12:14:53+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
diff -Naur netqmail-1.06.org/parse_env.h netqmail-1.06/parse_env.h
--- netqmail-1.06.org/parse_env.h	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/parse_env.h	2023-02-01 10:14:22.000000000 +0530
@@ -0,0 +1,12 @@
+/*
+ * $Id: parse_env.h,v 1.1 2023-01-13 12:15:01+05:30 Cprogrammer Exp mbhangui $
+ */
+#ifndef _PARSE_ENV_H
+#define _PARSE_ENV_H
+
+int             parse_env(char *);
+
+#endif
+/*
+ * Log: $
+ */
diff -Naur netqmail-1.06.org/qmail.c netqmail-1.06/qmail.c
--- netqmail-1.06.org/qmail.c	2007-12-01 01:52:54.000000000 +0530
+++ netqmail-1.06/qmail.c	2023-04-26 07:36:20.000000000 +0530
@@ -23,22 +23,32 @@
 {
   int pim[2];
   int pie[2];
+  int pic[2], errfd;
+  char *x;
 
   setup_qqargs();
 
   if (pipe(pim) == -1) return -1;
   if (pipe(pie) == -1) { close(pim[0]); close(pim[1]); return -1; }
+  if (pipe(pic) == -1) { close(pim[0]); close(pim[1]); close(pie[0]); close(pie[1]); return -1; }
  
   switch(qq->pid = vfork()) {
     case -1:
       close(pim[0]); close(pim[1]);
       close(pie[0]); close(pie[1]);
+      close(pic[0]); close(pic[1]);
       return -1;
     case 0:
       close(pim[1]);
       close(pie[1]);
+      close(pic[0]); /*- we want to receive data */
       if (fd_move(0,pim[0]) == -1) _exit(120);
       if (fd_move(1,pie[0]) == -1) _exit(120);
+      if (!(x = env_get("ERROR_FD")))
+        errfd = CUSTOM_ERR_FD;
+      else
+        scan_int(x, &errfd);
+      if (fd_move(errfd, pic[1]) == -1) _exit(120);
       if (chdir(auto_qmail) == -1) _exit(61);
       execv(*binqqargs,binqqargs);
       _exit(120);
@@ -46,6 +56,7 @@
 
   qq->fdm = pim[1]; close(pim[0]);
   qq->fde = pie[1]; close(pie[0]);
+  qq->fdc = pic[0]; close(pic[1]);
   substdio_fdbuf(&qq->ss,write,qq->fdm,qq->buf,sizeof(qq->buf));
   qq->flagerr = 0;
   return 0;
@@ -93,10 +104,21 @@
 {
   int wstat;
   int exitcode;
+  int len = 0;
+  char ch;
+  static char errstr[256];
 
   qmail_put(qq,"",1);
   if (!qq->flagerr) if (substdio_flush(&qq->ss) == -1) qq->flagerr = 1;
   close(qq->fde);
+  substdio_fdbuf(&qq->ss, read, qq->fdc, qq->buf, sizeof(qq->buf));
+  while (substdio_bget(&qq->ss, &ch, 1) && len < 255)
+  {
+    errstr[len] = ch; len++;
+  }
+  if (len > 0)
+    errstr[len] = 0; /* add str-term */
+  close(qq->fdc);
 
   if (wait_pid(&wstat,qq->pid) != qq->pid)
     return "Zqq waitpid surprise (#4.3.0)";
@@ -108,6 +130,7 @@
     case 115: /* compatibility */
     case 11: return "Denvelope address too long for qq (#5.1.3)";
     case 31: return "Dmail server permanently rejected message (#5.3.0)";
+    case 32: return "DPrivate key file does not exist (#5.3.5)";
     case 51: return "Zqq out of memory (#4.3.0)";
     case 52: return "Zqq timeout (#4.3.0)";
     case 53: return "Zqq write error or disk full (#4.3.0)";
@@ -115,22 +138,30 @@
     case 54: return "Zqq read error (#4.3.0)";
     case 55: return "Zqq unable to read configuration (#4.3.0)";
     case 56: return "Zqq trouble making network connection (#4.3.0)";
+    case 58: return "Zqq trouble creating child (#4.3.0)";
+    case 59: return "Zqq trouble creating pipes (#4.3.0)";
     case 61: return "Zqq trouble in home directory (#4.3.0)";
     case 63:
     case 64:
     case 65:
     case 66:
     case 62: return "Zqq trouble creating files in queue (#4.3.0)";
+    case 70: return "Zqq trouble with pid file (#4.3.0)";
     case 71: return "Zmail server temporarily rejected message (#4.3.0)";
     case 72: return "Zconnection to mail server timed out (#4.4.1)";
     case 73: return "Zconnection to mail server rejected (#4.4.1)";
     case 74: return "Zcommunication with mail server failed (#4.4.2)";
     case 91: /* fall through */
     case 81: return "Zqq internal bug (#4.3.0)";
+    case 82: /*- simscan exits with 82 */
+    case 88: /*- custom error */
+      if (len > 2) return errstr;
     case 120: return "Zunable to exec qq (#4.3.0)";
+    case 122: return "Zqq waitpid surprise (#4.3.0)";
+    case 123: return "Zqq crashed (#4.3.0)";
     default:
       if ((exitcode >= 11) && (exitcode <= 40))
-	return "Dqq permanent problem (#5.3.0)";
+        return "Dqq permanent problem (#5.3.0)";
       return "Zqq temporary problem (#4.3.0)";
   }
 }
diff -Naur netqmail-1.06.org/qmail-dkim.9 netqmail-1.06/qmail-dkim.9
--- netqmail-1.06.org/qmail-dkim.9	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/qmail-dkim.9	2023-06-30 19:16:37.189892950 +0530
@@ -0,0 +1,326 @@
+.TH qmail-dkim 8
+.SH NAME
+qmail-dkim \- sign/verify using DKIM (SSP/ADSP optionally) and queue a mail message for delivery
+
+.SH SYNOPSIS
+.B qmail-dkim
+
+.SH DESCRIPTION
+\fBqmail-dkim\fR has the same interface as \fBqmail-queue\fR except that it
+inserts an appropriate DKIM header (rfc4871, rfc6376) before it queues the
+message. To invoke \fBqmail-dkim\fR, set QMAILQUEUE to point to qmail-dkim
+in the environment when you send or receive email.
+
+\fBqmail-dkim\fR will call \fBqmail-multi\fR. To invoke an executable other
+than \fBqmail-multi\fR set DKIMQUEUE=bin/qmail-queue for example.
+
+\fBqmail-dkim\fR supports RSA-SHA1, RSA-SHA256 and ED25519-SHA256 (rfc8463)
+encryption methods for signing and verification. By default RSA-SHA256 is
+used.
+
+\fBqmail-dkim\fR supports DKIM signing and verification and can optionally
+use \fBSender Signing Practice (SSP)\fR or \fBAuthor Domain Signing Practice\fR.
+\fBqmail-dkim\fR uses libdkim and OpenSSL libraries for signing and
+verification.
+
+To sign a message, set the \fBDKIMSIGN\fR environment variable to the
+pathname of the private key that will be used to sign the message. You can
+run \fBdknewkey\fR(8) to create a private key. Any % character in the
+environment variable are removed and replaced by the domain name in the
+From: header. The selector (s=) will be taken from the basename of the
+file. If, after substituting the %, that file does not exist, the %
+character will be removed to check if the file exists. In addition to
+\fBDKIMSIGN\fR environment variable, you can have the domain and the
+pathname of the private key in the control file \fIdkimkeys\fR which has
+the following format
+
+.EX
+domain:private_key_path:envstr
+.EE
+
+.fi
+Here \fIenvstr\fR is a string of environment variable additions or
+removals. e.g.
+
+.EX
+QREGEX=1,DKIMSIGNOPTIONS=-z 4
+.EX
+
+.fi
+If an entry for \fIdomain\fR exists in \fIdkimkeys\fR, the value of
+\fBDKIMSIGN\fR environment variable is ignored. You can disable
+\fIdkimkeys\fR by setting \fBNODKIMKEYS\fR environment variable.
+
+If a private key file does not exist and does not have a % character, the
+message will be rejected with error 32.
+
+In the absense of DKSIGN and DKVERIFY environment variable, qmail-dkim will
+sign the message if RELAYCLIENT or AUTHINFO environment variable is set. It
+will verify the message if RELAYCLIENT or AUTHINFO environment variable is
+not set. Even if DKVERIFY is set, you can disable dkim verification, if
+RELAYCLIENT or AUTHINFO is set, by setting RELAYCLIENT_NODKVERIFY
+environment variable.
+
+You can set various DKIM options in getopt style, by setting the
+environment variable \fBDKIMSIGNOPTIONS\fR
+
+.nf
+c <canonicalization> r for relaxed [DEFAULT], s - simple,
+                     t relaxed/simple, u - simple/relaxed
+l                    include body length tag
+q                    include query method tag;
+t                    include a timestamp tag
+h                    include copied headers. This adds the z= tag
+                     containing a copy of the message's original
+                     headers.
+i <identity>         the identity, if not provided it will not be included
+x <expire_time>      the expire time in seconds since epoch
+                     ( DEFAULT = current time + 604800)
+                     if set to - then it will not be included
+z <hash>             1 for RSA-SHA1, 2 for RSA-SHA256, 3 for
+                     RSA-SHA1+RSA-SHA256, 4 for Ed25519-SHA256
+.fi
+
+.EX
+DKIMSIGNOPTIONS="-z 2 -c r -q"
+Use RSA SHA256 hash, set relaxed canonicalization and include query method
+tag
+.EE
+
+Apart from setting \fBDKIMSIGNOPTIONS\fR, you can set the identity and the
+expire time by setting \fBDKIMIDENTITY\fR and \fBDKIMEXPIRE\fR
+respectively. \fBDKIMIDENTITY\fR takes precedence over -i option specified
+in \fBDKIMSIGNOPTIONS\fR. Similarly, \fBDKIMEXPIRE\fR takes precedence over
+-x option specifed in \fBR DKIMSIGNOPTIONS\fR. \fBqmail-dkim\fR uses the
+domain found in the Return-Path, Sender, From headers to set the domain
+tag. If not it uses the \fBBOUNCEDOMAIN\fR environment variable.
+\fBBOUNCEDOMAIN\fR can be set to an email address or a domain (without the
+at sign). You can also use \fBDKIMDOMAIN\fR environment variable instead of
+the \fBBOUNCEDOMAIN\fR environment variable.
+
+As a default \fBqmail-dkim\fR inserts RSA-SHA256 DKIM-Signature and expects
+the private key file to be a RSA private key. This can be changed by
+setting DKIMOPTIONS="-z 4" to insert ed25519 signature. \fBqmail-dkim\fR
+can insert an additional DKIM-signature if \fBDKIMSIGNEXTRA\fR is set. This
+is useful for inserting both RSA and ED25519 signature when signing. As an
+example you can have \fBDKIMSIGN\fR pointing to a RSA private key,
+\fBDKIMSIGNOPTIONS\fR having "-z 2" along with other options if any.
+Additionally set \fBDKIMSIGNEXTRA\fR pointing to an ed25519 private key and
+set \fBDKIMSIGNOPTIONSEXTRA\fR to have "-z 4" along with other options if
+any.
+
+To verify a message, set the \fBDKIMVERIFY\fR environment variable to a
+desired set of letters.  Precisely, if you want a libdkim return status to
+generate an error, include that letter, where A is the first return status
+(DKIM_SUCCESS), B is the second (DKIM_FINISHED_BODY), etc. The letter
+should be uppercase if you want a permanent error to be returned, and
+lowercase if you want a temporary error to be returned (exit code 88). If
+you omit the letter, qmail-dkim will not issue any error inspite of DKIM
+verification failure. It will return success and the email will get
+delivered.
+
+The complete set of letters with the corresponding return status is given
+below
+.nf
+A - DKIM_SUCCESS                        - Function executed successfully
+B - DKIM_FINISHED_BODY                  - process result: no more message
+                                          body is needed
+C - DKIM_PARTIAL_SUCCESS                - verify result: at least one
+                                          but not all signatures verified
+D - DKIM_NEUTRAL                        - verify result: no signatures
+                                          verified but message is
+                                          not suspicious
+E - DKIM_SUCCESS_BUT_EXTRA              - signature result: signature
+                                          verified but it did not
+                                          include all of the body
+F - DKIM_3PS_SIGNATURE                  - 3rd-party signature
+G - DKIM_FAIL                           - Function failed to execute
+H - DKIM_BAD_SYNTAX                     - signature error: DKIM-Signature
+                                          could not parse or has bad
+                                          tags/values
+I - DKIM_SIGNATURE_BAD                  - signature error: RSA verify
+                                          failed
+J - DKIM_SIGNATURE_BAD_BUT_TESTING      - signature error: RSA verify
+                                          failed but testing
+K - DKIM_SIGNATURE_EXPIRED              - signature error: x= is old
+L - DKIM_SELECTOR_INVALID               - signature error: selector doesn't
+                                          parse or contains invalid values
+M - DKIM_SELECTOR_GRANULARITY_MISMATCH  - signature error: selector
+                                          g= doesn't match i=
+N - DKIM_SELECTOR_KEY_REVOKED           - signature error: selector
+                                          p= empty
+O - DKIM_SELECTOR_DOMAIN_NAME_TOO_LONG  - signature error: selector domain
+                                          name too long to request
+P - DKIM_SELECTOR_DNS_TEMP_FAILURE      - signature error: temporary dns
+                                          failure requesting selector
+Q - DKIM_SELECTOR_DNS_PERM_FAILURE      - signature error: permanent dns
+                                          failure requesting selector
+R - DKIM_SELECTOR_PUBLIC_KEY_INVALID    - signature error: selector
+                                          p= value invalid or wrong format
+S - DKIM_NO_SIGNATURES                  - no signatures
+T - DKIM_NO_VALID_SIGNATURES            - no valid signatures
+U - DKIM_BODY_HASH_MISMATCH             - sigature verify error: message
+                                          body does not hash to bh value
+V - DKIM_SELECTOR_ALGORITHM_MISMATCH    - signature error: selector
+                                          h= doesn't match signature a=
+W - DKIM_STAT_INCOMPAT                  - signature error: incompatible v=
+X - DKIM_UNSIGNED_FROM                  - signature error: not found
+                                          message From headers in signature
+.fi
+
+For example, if you want to permanently reject messages that have a
+signature that is expired, include the letter 'K' in the \fBDKIMVERIFY\fR
+environment variable. A conservative set of letters is
+\fBFGHIKLMNOQRTUVWjp\fR. Reject permanently 3PS, FAILURE, SYNTAX,
+SIGNATURE_BAD, SIGNATURE_EXPIRED, SELECTOR_INVALID, GRANULARITY_MISMATCH,
+SELECTOR_KEY_REVOKED, DOMAIN_NAME_TOO_LONG, SELECTOR_PUBLIC_KEY_INVALID,
+NO_VALID_SIGNATURES and BODY_HASH_MISMATCH errors, and temporarily
+SIGNATURE_BAD_BUT_TESTING and DNS_TEMP_FAILURE. Add in \fBS\fR if you want
+to reject messages that do not have a DKIM signature. You can use the
+control files \fBsignaturedomains\fR and \fBnosignaturedomains\fR (See
+Below) to further fine tune the action to be taken when a mail arrives with
+no DKIM signature. Note that \fBqmail-dkim\fR always inserts the
+\fBDKIM-Status\fR header, so that messages can be rejected later at
+delivery time, or in the mail reader. In that case you may set
+\fBDKIMVERIFY\fR to an empty string. If you want to check all message's
+From header in signature set the \fBUNSIGNED_FROM\fR environment variable
+to an empty string. If you want to check messages without signed subject
+header, set \fBUNSIGNED_SUBJECT\fR environment variable. If you want to
+honor body lengh tag (l=), set \fBHONOR_BODYLENGTHTAG\fR environment
+variable.
+
+qmail-dkim supports signing practice which can be additonall checked when a
+signature verifcation fails -
+
+.BR "SSP - Sender Signing Practice"
+
+and
+
+.BR "ADSP - Author Domain Signing Practice" .
+
+When a signature fails to verify for a message, you can use SSP/ADSP to
+determine if the message is suspicious or not. To verify a message against
+SSP/ADSP, set the \fBDKIMPRACTICE\fR environment variable to the desired
+set of letters allowed for DKIMVERIFY environment variable. SSP/ADSP should
+be used only when signature verification fails. SSP/ADSP should be invoked
+only when libdkim returns the error codes
+(F,G,H,I,J,K,L,M,N,P,Q,R,S,T,U,V,W,X) for signature verification. In case
+you want to test against SSP/ADSP only for DKIM_NO_SIGNATURE and
+DKIM_NO_VALID_SIGNATURE set the environment variable
+\fBDKIMPRACTICE="ST"\fR. If you want automatic behaviour, set DKIMPRACTICE
+to an empty string. In this case ADSP/SSP will be used when return code
+matches "FGHIJKLMNPQRSTUVWX". \fBqmail-dkim\fR uses ADSP as the default
+signing practice. You can override this by setting the SIGN_PRACTICE to
+ssp, adsp, local (lowercase). if you set SIGN_PRACTICE to \fIlocal\fB,
+\fBqmail-dkim\fR will check the domain against the control file
+\fIsignaturedomains\fR (See Below). If the domain is found listed in
+\fIsignaturedomains\fR, \fBqmail-dkim\fR will bypass ADSP/SSP and return
+DKIM_FAIL if signature fails to verify. Setting \fBSIGN_PRACTICE\fR to
+anything else will cause \fBqmail-dkim\fR to disable Signing Practice.
+
+If ADSP or SSP is checked, \fBqmail-dkim will insert the \fBX-DKIM-ADSP\fR
+or \fBX-DKIM-SSP\fR header as given below
+
+.nf
+A - DKIM_SUCCESS             - Message passes ADSP test
+B - DKIM_ADSP_UNKNOWN        - some messages may be signed
+C - DKIM_ADSP_ALL            - All message are signed with author signature 
+D - DKIM_ADSP_DISCARDABLE    - messages which fail verification are
+                               Discardable
+E - DKIM_ADSP_SCOPE          - domain is out of scope
+F - DKIM_ADSP_TEMPFAIL       - Temporary Error 
+
+or
+
+A - DKIM_SUCCESS             - Message passes ADSP test
+B - DKIM_SSP_UNKNOWN         - some messages may be signed
+C - DKIM_SSP_ALL             - All message are signed with author signature 
+D - DKIM_SSP_STRICT          - messages which fail verification are
+                               Discardable
+E - DKIM_SSP_SCOPE           - domain is out of scope
+F - DKIM_SSP_TEMPFAIL        - Temporary Error 
+.fi
+
+You can have a control file \fIsignaturedomains\fR containing a list of
+domains which you know are sure to sign messages using DKIM. If a message
+comes from a domain listed in \fIRsignaturedomains\fR, and the signature
+fails verification (any of DKIM failure status), \fBqmail-dkim\fR will
+bypass ADSP/SSP checks and return DKIM_FAIL. The name of this control file
+can be overriden by the environment variable \fBSIGNATUREDOMAINS\fR.
+
+You can have a control file \fInosignaturedomains\fR containing a list of
+domains which you know are sure not to sign messages using DKIM. If a
+message comes from a domain listed in \fInosignaturedomains\fR, and does
+not have a DKIM-Signature header, \fBqmail-dkim\fR will bypass ADSP/SSP
+checks and return DKIM_NEUTRAL. The wildcard entry '*' in this file, will
+result in all mails which do not have a signature to pass DKIM test (unless
+the domain is listed in the control file \fBsignaturedomains\fR). The name
+of this control file can be overriden by the environment variable
+\fBNOSIGNATUREDOMAINS\fR.
+
+\fBqmail-dkim\fR will use the environment variable \fBSELECTOR_DATA\fR
+instead of dns for the public key text record. This can be used to test
+signatures without deploying the public key in dns.
+
+Typically, you would sign messages generated on-host by setting
+\fBDKIMSIGN\fR in the environment before running an \fBqmail-smtpd\fR(8) or
+\fBsendmail(1)\fR / \fBqmail-inject\fR(8). \fBDKIMSIGN\fR will be carried
+through qmail-smtpd or through qmail's sendmail emulation through
+\fBqmail-inject\fR to \fBqmail-dkim\fR. You would also set it for
+\fBqmail-smtpd\fR at the same time \fBRELAYCLIENT\fR is set, most often in
+the tcpserver cdb file. If a host is authorized to relay, you probably want
+to sign messages sent by that host. \fBDKIMVERIFY\fR should be set for all
+other hosts.
+
+If neither \fBDKIMSIGN\fR nor \fBDKIMVERIFY\fR are set, then \fBDKIMSIGN\fR
+will be set to @controldir@/domainkeys/%/default. The % will be replaced by
+the domain in the From: header. If such a file does not exist, then it will
+be set to @controldir@/domainkeys/default. If such a private key exists, it
+will be used to sign the domain. You can also set \fBDKIMKEY\fR to chose a
+key different from @controldir@/domainkeys/%/default. \fBDKIMKEY\fR can
+also have % character that will be replaced by the domain in the From:
+header. If the private key does not exist, qmail-dkim will exit with return
+code 32.
+
+By default \fBqmail-dkim\fR will use all of the headers when signing a
+message.
+
+.SH NOTES
+If the environment variable \fBCONTROLDIR\fR is set, \fBqmail-dkim\fR uses
+that instead of @controldir@ to read control files and the private key.
+
+.SH "EXIT CODES"
+\fBqmail-dkim\fR returns the same exit codes as qmail-queue with these additions:
+
+.TP 5
+\fB32\fR
+The private key file does not exist.
+
+.TP 5
+\fB57\fR
+Trouble waiting for qmail-queue to exit.
+
+.TP 5
+\fB58\fR
+Unable to vfork.
+
+.TP 5
+\fB59\fR
+Unable to create a pipe to qmail-queue.
+
+.TP 5
+\fB88\fR
+For custom errors. Additionally diagnostic information of the error will be
+written to descriptor 2.
+
+.SH "SEE ALSO"
+addresses(5),
+envelopes(5),
+qmail-header(5),
+dknewkey(8),
+dkim(8),
+qmail-inject(8),
+qmail-qmqpc(8),
+qmail-queue(8),
+qmail-send(8),
+qmail-smtpd(8)
diff -Naur netqmail-1.06.org/qmail-dkim.c netqmail-1.06/qmail-dkim.c
--- netqmail-1.06.org/qmail-dkim.c	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/qmail-dkim.c	2023-04-26 07:59:08.000000000 +0530
@@ -0,0 +1,1571 @@
+/*
+ * $Id: qmail-dkim.c,v 1.71 2023-01-30 10:42:16+05:30 Cprogrammer Exp mbhangui $
+ */
+#include <unistd.h>
+#include <stdlib.h>
+#include <ctype.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include "sgetopt.h"
+#include "substdio.h"
+#include "open.h"
+#include "qmail.h"
+#include "sig.h"
+#include "scan.h"
+#include "case.h"
+#include "fmt.h"
+#include "fd.h"
+#include "alloc.h"
+#include "str.h"
+#include "stralloc.h"
+#include "datetime.h"
+#include "now.h"
+#include "wait.h"
+#include "auto_qmail.h"
+#include "env.h"
+#include "control.h"
+#include "error.h"
+#include "getDomainToken.h"
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+#include "dkim.h"
+#include <openssl/evp.h>
+
+#define DKIM_MALLOC(n)     OPENSSL_malloc(n)
+#define DKIM_MFREE(s)      OPENSSL_free(s); s = NULL;
+#define DEATH 86400	/*- 24 hours; _must_ be below q-s's OSSIFIED (36 hours) */
+#define ADDR 1003
+#ifndef HAVE_EVP_SHA256
+#define HAVE_EVP_SHA256
+#endif
+#define strncasecmp(x,y,z) case_diffb((x), (z), (y))
+#define strcasecmp(x,y)    case_diffs((x), (y))
+
+extern char    *dns_text(char *);
+
+char            inbuf[4096];
+char            outbuf[256];
+struct substdio ssin;
+struct substdio ssout;
+
+datetime_sec    starttime;
+struct datetime dt;
+unsigned long   mypid;
+unsigned long   uid;
+char           *pidfn;
+int             messfd;
+int             readfd;
+DKIMContext     ctxt;
+static char    *dkimsignoptions;
+static char    *binqqargs[2] = { "bin/qmail-queue", 0 };
+static char    *controldir;
+static stralloc fntmp = {0};
+
+char          **MakeArgs(char *);
+void            FreeMakeArgs(char **);
+
+void
+die(int e, int what)
+{
+	if (!what)
+		_exit(e);
+	(what == 1 ? DKIMSignFree : DKIMVerifyFree) (&ctxt);
+	_exit(e);
+}
+
+void
+die_write()
+{
+	die(53, 0);
+}
+
+void
+die_read()
+{
+	die(54, 0);
+}
+
+void
+sigalrm()
+{
+	/*- thou shalt not clean up here */
+	die(52, 0);
+}
+
+void
+sigbug()
+{
+	die(81, 0);
+}
+
+int DKIM_CALL
+SignThisHeader(const char *szHeader)
+{
+	if ((!strncasecmp((char *) szHeader, "X-", 2) && strncasecmp((char *) szHeader, "X-Mailer:", 9))
+			|| strncasecmp((char *) szHeader, "Received:", 9) == 0
+			|| strncasecmp((char *) szHeader, "Authentication-Results:", 23) == 0
+			|| !strncasecmp(szHeader, "DKIM-Signature:", 15)
+			|| !strncasecmp(szHeader, "DomainKey-Signature:", 20)
+			|| strncasecmp((char *) szHeader, "Return-Path:", 12) == 0)
+		return 0;
+	return 1;
+}
+
+void
+custom_error(char *program, char *type, char *message, char *extra, char *code)
+{
+	char           *c;
+	char            errbuf[256];
+	int             errfd = -1;
+	struct substdio sserr;
+
+	if (errfd == -1) {
+		if (!(c = env_get("ERROR_FD")))
+			errfd = CUSTOM_ERR_FD;
+		else
+			scan_int(c, &errfd);
+	}
+	substdio_fdbuf(&sserr, write, errfd, errbuf, sizeof(errbuf));
+	if (substdio_put(&sserr, type, 1) == -1 ||
+			substdio_puts(&sserr, program) == -1 ||
+			substdio_put(&sserr, ": ", 2) ||
+			substdio_puts(&sserr, message) == -1)
+		_exit(53);
+	if (extra && (substdio_put(&sserr, ": ", 2) == -1 || substdio_puts(&sserr, extra) == -1))
+		_exit(53);
+	if (code) {
+		if (substdio_put(&sserr, " (#", 3) == -1)
+			_exit(53);
+		c = (*type == 'D') ? "5" : "4";
+		if (substdio_put(&sserr, c, 1) == -1 ||
+				substdio_put(&sserr, code + 1, 4) == -1 ||
+				substdio_put(&sserr, ")", 1) == -1)
+			_exit(53);
+	}
+	if (substdio_flush(&sserr) == -1)
+		_exit(53);
+	_exit(88);
+}
+
+void
+maybe_die_dkim(int e)
+{
+	switch (e)
+	{
+	case DKIM_OUT_OF_MEMORY:
+	case DKIM_BUFFER_TOO_SMALL:
+		_exit (51);
+	case DKIM_INVALID_CONTEXT:
+		custom_error("qmail-dkim", "Z", "DKIMContext structure invalid for this operation", 0, "X.3.0");
+	case DKIM_NO_SENDER:
+		custom_error("qmail-dkim", "Z", "Could not find From: or Sender: header in message", 0, "X.1.7");
+	case DKIM_BAD_PRIVATE_KEY:
+		custom_error("qmail-dkim", "D", "Could not parse private key", 0, "X.7.5");
+	default:
+		return;
+	}
+}
+
+unsigned int
+pidfmt(char *s, unsigned long seq)
+{
+	unsigned int    i;
+	unsigned int    len;
+	char           *tmpdir;
+
+	if (!(tmpdir = env_get("TMPDIR")))
+		tmpdir = "/tmp";
+	len = 0;
+	i = fmt_str(s, tmpdir);
+	len += i;
+	if (s)
+		s += i;
+	i = fmt_str(s, "/qmail-dkim.");
+	len += i;
+	if (s)
+		s += i;
+	i = fmt_ulong(s, mypid);
+	len += i;
+	if (s)
+		s += i;
+	i = fmt_str(s, ".");
+	len += i;
+	if (s)
+		s += i;
+	i = fmt_ulong(s, starttime);
+	len += i;
+	if (s)
+		s += i;
+	i = fmt_str(s, ".");
+	len += i;
+	if (s)
+		s += i;
+	i = fmt_ulong(s, seq);
+	len += i;
+	if (s)
+		s += i;
+	++len;
+	if (s)
+		*s++ = 0;
+
+	return len;
+}
+
+void
+pidopen()
+{
+	unsigned int    len;
+	unsigned long   seq;
+
+	seq = 1;
+	len = pidfmt((char *) 0, seq);
+	if (!(pidfn = alloc(len)))
+		die(51, 0);
+	for (seq = 1; seq < 10; ++seq) {
+		if (pidfmt((char *) 0, seq) > len)
+			die(81, 0); /*- paranoia */
+		pidfmt(pidfn, seq);
+		if ((messfd = open_excl(pidfn)) != -1)
+			return;
+	}
+	die(63, 0);
+}
+
+static char    *dkimsign = 0;
+static char    *dkimverify = 0;
+static char    *dkimpractice =  "FGHIJKLMNPQRSTUVWX";
+static stralloc dkimoutput = { 0 };  /*- DKIM-Signature */
+static stralloc dksignature = { 0 }; /*- content of private signature */
+static stralloc sigdomains = { 0 };  /*- domains which must have signatures */
+static stralloc nsigdomains = { 0 }; /*- domains which do not have signatures */
+static stralloc dkimopts = { 0 };
+static stralloc dkimkeys = { 0 };
+static char    *dkimqueue = 0;
+
+char           *
+replace_pct(char *keyfn, char *domain, int pos, int *replace)
+{
+	char           *p, *t, *s;
+	int             i, d, r, len;
+	static stralloc tmp = {0};
+
+	if (!domain) {
+		tmp.len = 0;
+		for (p = keyfn, len = 0; *p; p++) {
+			if (*p == '%') {
+				if (tmp.len && *(p - 1) == '/' && *(p + 1) == '/') /*- replace // with single / */
+					tmp.len--;
+			} else
+			if (!stralloc_append(&tmp, p))
+				die(51, 1);
+		}
+		if (!stralloc_0(&tmp))
+			die(51, 1);
+		return tmp.s;
+	}
+	if (!keyfn[pos + 1]) { /*- file has % as the last component (implies selector is %) */
+		len = pos + (d = fmt_str(0, domain));
+		r = 0;
+		if (replace)
+			*replace = 1;
+	} else
+		len = pos + (d = fmt_str(0, domain)) + (r = fmt_str(0, keyfn + pos + 1));
+	if (!(t = (char *) alloc((len + 1) * sizeof(char))))
+		die(51, 1);
+	s = t;
+	s += fmt_strn(t, keyfn, pos);
+	s += fmt_strn(t + pos, domain, d);
+	if (keyfn[pos + 1])
+		s += fmt_strn(t + pos + d, keyfn + pos + 1, r);
+	*s = 0;
+	i = str_rchr(t, '%');
+	if (t[i]) {
+		p = replace_pct(t, domain, i, replace);
+		alloc_free(t);
+		return p;
+	} else {
+		if (!stralloc_copyb(&tmp, t, len + 1))
+			die(51, 1);
+		alloc_free(t);
+		return tmp.s;
+	}
+}
+
+int
+dkim_setoptions(DKIMSignOptions *opts, char *signOptions)
+{
+	int             ch, argc;
+	char          **argv;
+
+	opts->nCanon = DKIM_SIGN_RELAXED;					/*- c */
+	opts->nIncludeBodyLengthTag = 0;					/*- l */
+	opts->nIncludeQueryMethod = 0;						/*- q */
+	opts->nIncludeTimeStamp = 0;						/*- t */
+	opts->nIncludeCopiedHeaders = 0;					/*- h */
+	opts->szIdentity[0] = '\0';
+	opts->expireTime = starttime + 604800;	// expires in 1 week
+	opts->nHash = DKIM_HASH_SHA256;
+	str_copy(opts->szRequiredHeaders, "NonExistent");
+	if (!signOptions)
+		return (0);
+	if (!stralloc_copys(&dkimopts, "dkim ") ||
+			!stralloc_cats(&dkimopts, signOptions) ||
+			!stralloc_0(&dkimopts))
+		die(51, 0);
+	if (!(argv = MakeArgs(dkimopts.s)))
+		die(51, 0);
+	for (argc = 0;argv[argc];argc++);
+	while ((ch = sgopt(argc, argv, "b:c:li:qthx:z:")) != sgoptdone) {
+		switch (ch)
+		{
+		case 'b':
+			break;
+		case 'c':
+			switch (*optarg)
+			{
+			case 'r':
+				opts->nCanon = DKIM_SIGN_RELAXED;
+				break;
+			case 's':
+				opts->nCanon = DKIM_SIGN_SIMPLE;
+				break;
+			case 't':
+				opts->nCanon = DKIM_SIGN_RELAXED_SIMPLE;
+				break;
+			case 'u':
+				opts->nCanon = DKIM_SIGN_SIMPLE_RELAXED;
+				break;
+			default:
+				FreeMakeArgs(argv);
+				return (1);
+			}
+			break;
+		case 'l': /*- body length tag */
+			opts->nIncludeBodyLengthTag = 1;
+			break;
+		case 'q': /*- query method tag */
+			opts->nIncludeQueryMethod = 1;
+			break;
+		case 't': /*- timestamp tag */
+			opts->nIncludeTimeStamp = 1;
+			break;
+		case 'h':
+			opts->nIncludeCopiedHeaders = 1;
+			break;
+		case 'i':	/*- identity */
+			if (*optarg == '-') /* do not use i= tag */
+				opts->szIdentity[0] = '\0';
+			else
+				str_copyb(opts->szIdentity, optarg, sizeof(opts->szIdentity) - 1);
+			break;
+		case 'x': /*- expire time */
+			if (*optarg == '-')
+				opts->expireTime = 0;
+			else
+				opts->expireTime = starttime + atoi(optarg);
+			break;
+		case 'z': /*- sign rsa-sha1, rsa-sha256, rsa-sha1+rsa-sha256 or ed25519 */
+			switch (*optarg)
+			{
+			case '1':
+				opts->nHash = DKIM_HASH_SHA1;
+				break;
+#ifdef HAVE_EVP_SHA256
+			case '2':
+				opts->nHash = DKIM_HASH_SHA256;
+				break;
+			case '3':
+				opts->nHash = DKIM_HASH_SHA1_AND_SHA256;
+				break;
+#endif
+#if OPENSSL_VERSION_NUMBER >= 0x10101000L
+			case '4':
+				opts->nHash = DKIM_HASH_ED25519;
+				break;
+#endif
+			default:
+				FreeMakeArgs(argv);
+				return (1);
+			}
+			break;
+		default:
+			FreeMakeArgs(argv);
+			return (1);
+		} /*- switch (ch) */
+	} /*- while (1) */
+	FreeMakeArgs(argv);
+	return (0);
+}
+
+void
+format_controlfile(char *fn, int what)
+{
+	if (!stralloc_copys(&fntmp, controldir) ||
+			!stralloc_append(&fntmp, "/") ||
+			!stralloc_cats(&fntmp, fn) ||
+			!stralloc_0(&fntmp))
+		die(51, what);
+}
+
+static void
+write_signature(char *domain, DKIMSignOptions *opts, size_t selector_size)
+{
+	char           *pSig, *keyfn, *ptr, *selector;
+	int             i, r_selector, pct_found;
+	static stralloc tmp = { 0 };
+
+	if (env_get("NODKIMKEYS")) {
+		i = 0;
+		keyfn = dkimsign;
+	} else {
+		format_controlfile("dkimkeys", 1);
+		if ((i = control_readfile(&dkimkeys, fntmp.s, 0)) == -1)
+			custom_error("qmail-dkim", "Z", "unable to read dkimkeys.", 0, "X.3.0");
+		else
+		if (!i || !(keyfn = getDomainToken(domain, &dkimkeys))) {
+			i = 0;
+			keyfn = dkimsign;
+		} else {
+			ptr = env_get("DKIMSIGNOPTIONS");
+			if (!dkimsignoptions || str_diff(dkimsignoptions, ptr)) {
+				dkimsignoptions = ptr;
+				if (dkim_setoptions(opts, dkimsignoptions))
+					custom_error("qmail-dkim", "Z", "Invalid DKIMSIGNOPTIONS", 0, "X.3.0");
+				DKIMSignReplaceHash(&ctxt, opts);
+			}
+		}
+	}
+	if (keyfn[0] != '/') {
+		if (!stralloc_copys(&tmp, controldir) ||
+				!stralloc_append(&tmp, "/") ||
+				!stralloc_cats(&tmp, keyfn))
+			die(51, 1);
+	} else
+	if (!stralloc_copys(&tmp, keyfn))
+		die(51, 1);
+	if (!stralloc_0(&tmp))
+		die(51, 1);
+	/*
+	 * it is possible that selector was chosen based
+	 * on DKIMSIGN.
+	 * If the selector is % or keyfn has been overriden
+	 * by dkimkeys control file, we need to change
+	 * the selector
+	 */
+	r_selector = i ? 1 : 0; /*- for replacing selector later */
+	i = str_rchr(tmp.s, '%');
+	if (tmp.s[i]) {
+		pct_found = 1;
+		keyfn = replace_pct(tmp.s, domain, i, &r_selector);
+		if (access(keyfn, F_OK)) {
+			if (errno != error_noent && errno != error_isdir)
+				custom_error("qmail-dkim", "Z", "unable to read private key.", 0, "X.3.0");
+			keyfn = replace_pct(tmp.s, 0, 0, 0);
+		}
+	} else {
+		pct_found = 0;
+		keyfn = tmp.s;
+	}
+	switch (control_readnativefile(&dksignature, keyfn, 1))
+	{
+	case 0: /*- missing signature file */
+		DKIMSignFree(&ctxt);
+		/*
+		 * You may have multiple domains, but may chose to sign
+		 * only for few domains which have the key present. Do not
+		 * treat domains with missing key as an error.
+		 */
+		if (pct_found)
+			return;
+		die(32, 0);
+	case 1:
+		break;
+	default:
+		DKIMSignFree(&ctxt);
+		if (errno == error_isdir && pct_found)
+			return;
+		custom_error("qmail-dkim", "Z", "unable to read private key.", 0, "X.3.0");
+	}
+	for (i = 0; i < dksignature.len; i++) {
+		if (dksignature.s[i] == '\0')
+			dksignature.s[i] = '\n';
+	}
+	if (!stralloc_0(&dksignature))
+		die(51, 1);
+	if (r_selector) { /*- replace selector */
+		selector = ptr = keyfn;
+		while (*ptr) {
+			if (*ptr == '/' && *(ptr + 1))
+				selector = ptr + 1;
+			ptr++;
+		}
+		str_copyb(opts->szSelector, selector, selector_size);
+		DKIMSignReplaceSelector(&ctxt, opts);
+	}
+	i = DKIMSignGetSig2(&ctxt, dksignature.s, &pSig);
+	maybe_die_dkim(i);
+	if (pSig) {
+		if (!stralloc_catb(&dkimoutput, pSig, str_len(pSig)) ||
+				!stralloc_cats(&dkimoutput, "\n"))
+			die(51, 1);
+	}
+	DKIMSignFree(&ctxt);
+}
+
+int
+ParseTagValues(char *list, char *letters[], char *values[])
+{
+	char           *t, *ptr, *key;
+	int             i;
+
+	/*- start with all args unset */
+	for (i = 0; letters[i]; i++)
+		values[i] = 0;
+	key = 0;
+	for(ptr = list;*ptr;) {
+		if ((*ptr == ' ') || (*ptr == '\t') || (*ptr == '\r') || (*ptr == '\n')) /*- FWS */
+			*ptr++ = 0;
+		if (!key)
+			key = ptr;
+		if (*ptr == '=') {
+			*ptr = 0;
+			for (i = 0;letters[i];i++) {
+				if (!str_diff(letters[i], key)) {
+					ptr++;
+					for (;*ptr;) {
+						if ((*ptr == ' ') || (*ptr == '\t') || (*ptr == '\r') || (*ptr == '\n')) {
+							ptr++;
+							continue;
+						}
+						break;
+					}
+					values[i] = ptr;
+					for(;*ptr && *ptr != ';';ptr++);
+					t = ptr;
+					if (*ptr)
+						*ptr++ = 0;
+					for(;t != values[i];t--) { /*- RFC 4871 3.2 */
+						if ((*t == ' ') || (*t == '\t') || (*t == '\r') || (*t == '\n')) {
+							*t = 0;
+							continue;
+						}
+						break;
+					}
+					key = 0;
+					break;
+				}
+			}
+		} else
+			ptr++;
+	}
+	return (0);
+}
+
+int
+checkSSP(char *domain, int *bTesting)
+{
+	char           *query, *results;
+	char           *tags[] = { "dkim", "t", 0};
+	char           *values[2];
+	int             bIsParentSSP = 0, iSSP = DKIM_SSP_UNKNOWN;
+
+	*bTesting = 0;
+	if (!(query = DKIM_MALLOC(str_len("_ssp._domainkey.") + str_len(domain) + 1)))
+		die(51, 0);
+	sprintf(query, "_ssp._domainkey.%s", domain);
+	results = dns_text(query);
+	DKIM_MFREE(query);
+	if (!str_diff(results, "e=temp;")) {
+		DKIM_MFREE(results);
+		return DKIM_SSP_TEMPFAIL;
+	} else
+	if (!str_diff(results, "e=perm;")) {
+		results = dns_text(domain);
+		if (!str_diff(results, "e=temp;")) {
+			DKIM_MFREE(results);
+			return DKIM_SSP_TEMPFAIL;
+		} else
+		if (!str_diff(results, "e=perm;")) {
+			DKIM_MFREE(results);
+			return DKIM_SSP_SCOPE;
+		}
+		bIsParentSSP = 1;
+	}
+	/*-
+	 * PG.1 2013-01-03
+	 * Bug fix by Piotr Gronek, Faculty of Physics & Applied Computer Science, Poland 2013-01-03
+	 * Deallocating storage for 'results' here is premature - moved beyond last reference to it.
+	 *
+	 */
+	if (!ParseTagValues(results, tags, values)) {
+		DKIM_MFREE(results);
+		return DKIM_SSP_UNKNOWN;
+	}
+	DKIM_MFREE(results);
+	if (values[0] != NULL) {
+		if (strcasecmp(values[0], "all") == 0)
+			iSSP = DKIM_SSP_ALL;
+		else
+		if (strcasecmp(values[0], "strict") == 0)
+			iSSP = DKIM_SSP_STRICT;
+	}
+	// flags
+	if (values[1] != NULL) {
+		char           *s, *p;
+		for (p = values[1], s = values[1]; *p; p++) {
+			if (*p == '|')
+				*p = 0;
+			else
+				continue;
+			if (!str_diff(s, "y"))
+				*bTesting = 1;
+			else
+			if (!str_diff(s, "s")) {
+				if (bIsParentSSP) {
+					/*-
+					 * this is a parent's SSP record that should not apply to subdomains
+					 * the message is non-suspicious
+					 */
+					*bTesting = 0;
+					return (DKIM_SSP_UNKNOWN);
+				}
+			}
+			s = p + 1;
+		}
+	}
+	return iSSP;
+}
+
+int
+checkADSP(char *domain)
+{
+	char           *query, *results;
+	char           *tags[] = { "dkim", 0};
+	char           *values[1];
+
+	results = dns_text(domain);
+	if (!str_diff(results, "e=perm;")) {
+		DKIM_MFREE(results);
+		return DKIM_ADSP_SCOPE;
+	} else
+	if (!str_diff(results, "e=temp;")) {
+		DKIM_MFREE(results);
+		return DKIM_ADSP_TEMPFAIL;
+	}
+	if (!(query = DKIM_MALLOC(str_len("_adsp._domainkey.") + str_len(domain) + 1))) {
+		DKIM_MFREE(results);
+		die(51, 0);
+	}
+	sprintf(query, "_adsp._domainkey.%s", domain);
+	results = dns_text(query);
+	DKIM_MFREE(query);
+	if (!str_diff(results, "e=perm;")) {
+		DKIM_MFREE(results);
+		return DKIM_ADSP_SCOPE;
+	} else
+	if (!str_diff(results, "e=temp;")) {
+		DKIM_MFREE(results);
+		return DKIM_ADSP_TEMPFAIL;
+	}
+	/*-
+	 * PG.1 2013-01-03
+	 * Bug fix by Piotr Gronek, Faculty of Physics & Applied Computer Science, Poland 2013-01-03
+	 *
+	 * Deallocating storage for 'results' here is premature - moved beyond last reference to it.
+	 *
+	 */
+	if (!ParseTagValues(results, tags, values)) {
+		DKIM_MFREE(results);
+		return DKIM_SSP_UNKNOWN;
+	}
+	DKIM_MFREE(results);
+	if (values[0] != NULL) {
+		if (strcasecmp(values[0], "all") == 0)
+			return (DKIM_ADSP_ALL);
+		else
+		if (strcasecmp(values[0], "discardable") == 0)
+			return (DKIM_ADSP_DISCARDABLE);
+	}
+	return DKIM_ADSP_UNKNOWN; /*- No ADSP Record */
+}
+
+void
+dkimverify_exit(int dkimRet, char *status, char *code)
+{
+	if (dkimRet < 0) {
+		if (dkimverify[str_chr(dkimverify, 'F' - dkimRet)])
+			custom_error("qmail-dkim", "D", status, 0, code);
+		if (dkimverify[str_chr(dkimverify, 'f' - dkimRet)])
+			custom_error("qmail-dkim", "Z", status, 0, code);
+	} else {
+		if (dkimverify[str_chr(dkimverify, 'A' + dkimRet)])
+			custom_error("qmail-dkim", "D", status, 0, code);
+		if (dkimverify[str_chr(dkimverify, 'a' + dkimRet)])
+			custom_error("qmail-dkim", "Z", status, 0, code);
+	}
+}
+
+void
+writeHeaderNexit(int ret, int origRet, int resDKIMSSP, int resDKIMADSP, int useSSP, int useADSP)
+{
+	char           *dkimStatus = 0, *sspStatus = 0, *adspStatus = 0, *code = 0, *orig = 0;
+	char            strnum[FMT_ULONG];
+
+	switch (ret)
+	{
+	case DKIM_SUCCESS:			/*- 0 */ /*- A */
+		dkimStatus = "good        ";
+		code = "X.7.0";
+		break;
+	case DKIM_FINISHED_BODY:	/*- 1 process result: no more message body is needed */
+		dkimStatus = "process result: no more message body is needed";
+		code = "X.7.0";
+		break;
+	case DKIM_PARTIAL_SUCCESS:	/*- 2 verify result: at least one but not all signatures verified */
+		dkimStatus = "verify result: at least none but not all signatures verified";
+		code = "X.7.0";
+		break;
+	case DKIM_NEUTRAL:			/*- 3 verify result: no signatures verified but message is not suspicious */
+		dkimStatus = "verify result: no signatures verified but message is not suspicious";
+		code = "X.7.0";
+		break;
+	case DKIM_SUCCESS_BUT_EXTRA:/*- 4 signature result: signature verified but it did not include all of the body */
+		dkimStatus = "signature result: signature verified but it did not include all of the body";
+		code = "X.7.0";
+		break;
+	case DKIM_FAIL:				/*- -1 */ /*- F */
+		dkimStatus = "DKIM Signature verification failed";
+		code = "X.7.0";
+		break;
+	case DKIM_BAD_SYNTAX:		/*- -2 */ /*- G */
+		dkimStatus = "signature error: DKIM-Signature could not parse or has bad tags/values";
+		code = "X.7.5";
+		break;
+	case DKIM_SIGNATURE_BAD:	/*- -3 */
+#if OPENSSL_VERSION_NUMBER >= 0x10101000L
+		dkimStatus = "signature error: RSA/ED25519 verify failed";
+#else
+		dkimStatus = "signature error: RSA verify failed";
+#endif
+		code = "X.7.5";
+		break;
+	case DKIM_SIGNATURE_BAD_BUT_TESTING:
+#if OPENSSL_VERSION_NUMBER >= 0x10101000L
+		dkimStatus = "signature error: RSA/ED25519 verify failed but testing";
+#else
+		dkimStatus = "signature error: RSA verify failed but testing";
+#endif
+		code = "X.7.5";
+		break;
+	case DKIM_SIGNATURE_EXPIRED:
+		dkimStatus = "signature error: x= is old";
+		code = "X.7.5";
+		break;
+	case DKIM_SELECTOR_INVALID:
+		dkimStatus = "signature error: selector doesn't parse or contains invalid values";
+		code = "X.7.5";
+		break;
+	case DKIM_SELECTOR_GRANULARITY_MISMATCH:
+		dkimStatus = "signature error: selector g= doesn't match i=";
+		code = "X.7.5";
+		break;
+	case DKIM_SELECTOR_KEY_REVOKED:
+		dkimStatus = "signature error: selector p= empty";
+		code = "X.7.5";
+		break;
+	case DKIM_SELECTOR_DOMAIN_NAME_TOO_LONG:
+		dkimStatus = "signature error: selector domain name too long to request";
+		code = "X.7.0";
+		break;
+	case DKIM_SELECTOR_DNS_TEMP_FAILURE:
+		dkimStatus = "signature error: temporary dns failure requesting selector";
+		code = "X.7.0";
+		break;
+	case DKIM_SELECTOR_DNS_PERM_FAILURE:
+		dkimStatus = "signature error: permanent dns failure requesting selector";
+		code = "X.7.0";
+		break;
+	case DKIM_SELECTOR_PUBLIC_KEY_INVALID:
+		dkimStatus = "signature error: selector p= value invalid or wrong format";
+		code = "X.7.5";
+		break;
+	case DKIM_NO_SIGNATURES:
+		dkimStatus = "no signatures";
+		code = "X.7.5";
+		break;
+	case DKIM_NO_VALID_SIGNATURES:
+		dkimStatus = "no valid signatures";
+		code = "X.7.5";
+		break;
+	case DKIM_BODY_HASH_MISMATCH:
+		dkimStatus = "signature verify error: message body does not hash to bh value";
+		code = "X.7.7";
+		break;
+	case DKIM_SELECTOR_ALGORITHM_MISMATCH:
+		dkimStatus = "signature error: selector h= doesn't match signature a=";
+		code = "X.7.7";
+		break;
+	case DKIM_STAT_INCOMPAT:
+		dkimStatus = "signature error: incompatible v=";
+		code = "X.7.6";
+		break;
+	case DKIM_UNSIGNED_FROM:
+		dkimStatus = "signature error: not all message's From headers in signature";
+		code = "X.7.7";
+		break;
+	default:
+		dkimStatus = "error";
+		code = "X.3.0";
+		break;
+	}
+	if (useSSP && resDKIMSSP != -1) {
+		switch(resDKIMSSP)
+		{
+			case DKIM_SSP_ALL:
+				sspStatus = (char *) "all;";
+				break;
+			case DKIM_SSP_STRICT:
+				sspStatus = (char *) "strict;";
+				break;
+			case DKIM_SSP_SCOPE:
+				sspStatus = (char *) "out of scope;";
+				break;
+			case DKIM_SSP_TEMPFAIL:
+				sspStatus = (char *) "temporary failure;";
+				break;
+			case DKIM_SSP_UNKNOWN:
+			default:
+				sspStatus = (char *) "unknown;";
+				break;
+		}
+	}
+	if (useADSP && resDKIMADSP != -1) {
+		switch(resDKIMADSP)
+		{
+			case DKIM_ADSP_ALL:
+				adspStatus = (char *) "all;";
+				break;
+			case DKIM_ADSP_DISCARDABLE:
+				adspStatus = (char *) "discardable;";
+				break;
+			case DKIM_ADSP_SCOPE:
+				adspStatus = (char *) "out of scope;";
+				break;
+			case DKIM_ADSP_TEMPFAIL:
+				adspStatus = (char *) "temporary failure;";
+				break;
+			case DKIM_ADSP_UNKNOWN:
+			default:
+				adspStatus = (char *) "unknown ;";
+				break;
+		}
+	}
+	if (!stralloc_copys(&dkimoutput, "DKIM-Status: ") ||
+			!stralloc_cats(&dkimoutput, dkimStatus))
+		die(51, 0);
+	if (origRet != DKIM_MAX_ERROR && ret != origRet) {
+		if (!stralloc_cats(&dkimoutput, "\n\t(old="))
+			die(51, 0);
+		switch (origRet)
+		{
+		case DKIM_SUCCESS:			/*- 0 */ /*- A */
+			orig = "SUCCESS";
+			break;
+		case DKIM_FINISHED_BODY:	/*- 1 process result: no more message body is needed */
+			orig = "FINISHED BODY";
+			break;
+		case DKIM_PARTIAL_SUCCESS:	/*- 2 verify result: at least one but not all signatures verified */
+			orig = "PARTIAL SUCCESS";
+			break;
+		case DKIM_NEUTRAL:			/*- 3 verify result: no signatures verified but message is not suspicious */
+			orig = "NEUTRAL";
+			break;
+		case DKIM_SUCCESS_BUT_EXTRA:/*- 4 signature result: signature verified but it did not include all of the body */
+			orig = "SUCCESS(BUT EXTRA)";
+			break;
+		case DKIM_FAIL:				/*- -1 */ /*- F */
+			orig = "FAIL";
+			break;
+		case DKIM_BAD_SYNTAX:		/*- -2 */ /*- G */
+			orig = "BAD SYNTAX";
+			break;
+		case DKIM_SIGNATURE_BAD:	/*- -3 */
+			orig = "SIGNATURE BAD";
+			break;
+		case DKIM_SIGNATURE_BAD_BUT_TESTING:
+			orig = "SIGNATURE BAD (TESTING)";
+			break;
+		case DKIM_SIGNATURE_EXPIRED:
+			orig = "SIGNATURE EXPIRED";
+			break;
+		case DKIM_SELECTOR_INVALID:
+			orig = "SELECTOR INVALID";
+			break;
+		case DKIM_SELECTOR_GRANULARITY_MISMATCH:
+			orig = "SELECTOR GRANULARITY MISMATCH";
+			break;
+		case DKIM_SELECTOR_KEY_REVOKED:
+			orig = "SELECTOR KEY REVOKED";
+			break;
+		case DKIM_SELECTOR_DOMAIN_NAME_TOO_LONG:
+			orig = "DOMAIN NAME TOO LONG";
+			break;
+		case DKIM_SELECTOR_DNS_TEMP_FAILURE:
+			orig = "DNS TEMP FAILURE";
+			break;
+		case DKIM_SELECTOR_DNS_PERM_FAILURE:
+			orig = "DNS PERM FAILURE";
+			break;
+		case DKIM_SELECTOR_PUBLIC_KEY_INVALID:
+			orig = "PUBLIC KEY INVALID";
+			break;
+		case DKIM_NO_SIGNATURES:
+			orig = "NO SIGNATURES";
+			break;
+		case DKIM_NO_VALID_SIGNATURES:
+			orig = "NO VALID SIGNATURES";
+			break;
+		case DKIM_BODY_HASH_MISMATCH:
+			orig = "BODY HASH MISMATCH";
+			break;
+		case DKIM_SELECTOR_ALGORITHM_MISMATCH:
+			orig = "ALGORITHM MISMATCH";
+			break;
+		case DKIM_STAT_INCOMPAT:
+			orig = "STAT INCOMPAT";
+			break;
+		case DKIM_UNSIGNED_FROM:
+			orig = "UNSIGNED FROM";
+			break;
+		default:
+			orig = "Unkown error";
+			break;
+		}
+		if (!stralloc_cats(&dkimoutput, orig) ||
+				!stralloc_cats(&dkimoutput, ":"))
+			die(51, 0);
+		if (origRet < 0) {
+			if (!stralloc_cats(&dkimoutput, "-"))
+				die(51, 0);
+			strnum[fmt_ulong(strnum, 0 - origRet)] = 0;
+		} else
+			strnum[fmt_ulong(strnum, origRet)] = 0;
+		if (!stralloc_cats(&dkimoutput, strnum) ||
+				!stralloc_cats(&dkimoutput, ")"))
+			die(51, 0);
+	}
+	if (!stralloc_cats(&dkimoutput, "\n"))
+		die(51, 0);
+	if (useSSP && sspStatus) {
+		if (!stralloc_cats(&dkimoutput, "X-DKIM-SSP: ") ||
+				!stralloc_cats(&dkimoutput, sspStatus) ||
+				!stralloc_cats(&dkimoutput, "\n"))
+			die(51, 0);
+	}
+	if (useADSP && adspStatus) {
+		if (!stralloc_cats(&dkimoutput, "X-DKIM-ADSP: ") ||
+				!stralloc_cats(&dkimoutput, adspStatus) ||
+				!stralloc_cats(&dkimoutput, "\n"))
+			die(51, 0);
+	}
+	dkimverify_exit(ret, dkimStatus, code);
+	return;
+}
+
+int
+checkPractice(int dkimRet, int useADSP, int useSSP)
+{
+	char           *ptr;
+
+	if (!(ptr = env_get("DKIMPRACTICE"))) {
+		/*- if SIGN_PRACTICE="local" then you can use DKIMVERIFY env variable too */
+		if (!useADSP && !useSSP)
+			dkimpractice = dkimverify; /*- DKIMVERIFY env variable */
+		else
+			return (0);
+	} else
+		dkimpractice = ptr;
+	if (!*dkimpractice) {
+		if (dkimRet < 0 || dkimRet == DKIM_3PS_SIGNATURE)
+			return (1);
+		return (0);
+	}
+	if (dkimRet < 0) {
+		if (dkimpractice[str_chr(dkimpractice, 'F' - dkimRet)])
+			return (1);
+		if (dkimpractice[str_chr(dkimpractice, 'f' - dkimRet)])
+			return (1);
+	} else {
+		if (dkimpractice[str_chr(dkimpractice, 'A' + dkimRet)])
+			return (1);
+		if (dkimpractice[str_chr(dkimpractice, 'a' + dkimRet)])
+			return (1);
+	}
+	return (0);
+}
+
+static char    *callbackdata;
+
+int
+dns_bypass(const char *domain, char *buffer, int maxlen)
+{
+	if (callbackdata) {
+		str_copy(buffer, callbackdata);
+		return 0;
+	} else
+		return 1;
+}
+
+int
+main(int argc, char *argv[])
+{
+	int             pim[2];
+	int             wstat;
+	int             resDKIMSSP = -1, resDKIMADSP = -1, useSSP = 0, useADSP = 0, accept3ps = 0;
+	int             sCount = 0, sSize = 0;
+	int             ret = 0, origRet = DKIM_MAX_ERROR, i, nSigCount = 0, len, token_len;
+	unsigned long   pid;
+	char           *selector = NULL, *ptr;
+	stralloc        dkimfn = {0};
+	DKIMVerifyDetails *pDetails;
+	DKIMSignOptions   sopts = { 0 };
+	DKIMVerifyOptions vopts = { 0 };
+
+	starttime = now();
+	sig_blocknone();
+	umask(033);
+	if (!(controldir = env_get("CONTROLDIR")))
+		controldir = "control";
+	if (chdir(auto_qmail) == -1)
+		die(61, 0);
+	dkimqueue = env_get("DKIMQUEUE");
+	if (dkimqueue && *dkimqueue)
+		binqqargs[0] = dkimqueue;
+	dkimsign = env_get("DKIMSIGN");
+	dkimverify = env_get("DKIMVERIFY");
+	ptr = (env_get("RELAYCLIENT") || env_get("AUTHINFO")) ? "" : 0;
+	if (dkimverify && ptr && env_get("RELAYCLIENT_NODKIMVERIFY")) {
+		execv(*binqqargs, binqqargs);
+		die(120, 0);
+	}
+	if (!dkimsign && !dkimverify && ptr) {
+		if (!(dkimsign = env_get("DKIMKEY"))) {
+			if (!stralloc_copys(&dkimfn, controldir) ||
+					!stralloc_cats(&dkimfn, "control/domainkeys/%/default") ||
+					!stralloc_0(&dkimfn))
+				die(51, 0);
+			dkimsign = dkimfn.s;
+		}
+	}
+	if (dkimsign) {
+		/* selector */
+		ptr = dkimsign;
+		selector = ptr;
+		while (*ptr) {
+			if (*ptr == '/' && *(ptr + 1))
+				selector = ptr + 1;
+			ptr++;
+		}
+		str_copyb(sopts.szSelector, selector, sizeof(sopts.szSelector) - 1);
+
+		if (dkim_setoptions(&sopts, env_get("DKIMSIGNOPTIONS")))
+			custom_error("qmail-dkim", "Z", "Invalid DKIMSIGNOPTIONS", 0, "X.3.0");
+		ptr = env_get("DKIMIDENTITY");
+		if (ptr && *ptr)
+			str_copyb(sopts.szIdentity, ptr, sizeof(sopts.szIdentity) - 1);
+		ptr = env_get("DKIMEXPIRE");
+		if (ptr && *ptr)
+			sopts.expireTime = starttime + atol(ptr);
+		else
+		if (ptr)
+			sopts.expireTime = 0;
+		sopts.pfnHeaderCallback = SignThisHeader;
+		if (DKIMSignInit(&ctxt, &sopts) != DKIM_SUCCESS) /*- failed to initialize signature */
+			custom_error("qmail-dkim", "Z", "dkim initialization failed", 0, "X.3.0");
+	} else {
+		char           *x;
+
+		if (!dkimverify)
+			dkimverify = "";
+		if (!(x = env_get("SIGN_PRACTICE")))
+			x = "adsp";
+		if (!str_diffn("adsp", x, 4)) {
+			useADSP = 1;
+			accept3ps = 1;
+		} else
+		if (!str_diffn("ssp", x, 3)) {
+			useSSP = 1;
+			accept3ps = 1;
+		} else
+		if (!str_diffn("local", x, 5)) {
+			useSSP = 0;
+			useADSP = 0;
+			accept3ps = 1;
+		}
+		if (useADSP)
+			vopts.nCheckPractices = useADSP;
+		else
+		if (useSSP)
+			vopts.nCheckPractices = useSSP;
+		else
+			vopts.nCheckPractices = 0;
+		vopts.nAccept3ps = accept3ps;
+		if (!(callbackdata = env_get("SELECTOR_DATA")))
+			vopts.pfnSelectorCallback = NULL;	/*- SelectorCallback; */
+		else
+			vopts.pfnSelectorCallback = dns_bypass;
+		if (env_get("UNSIGNED_FROM"))
+			vopts.nAllowUnsignedFromHeaders = 1;
+		vopts.nSubjectRequired = env_get("UNSIGNED_SUBJECT") ? 0 : 1;
+		vopts.nHonorBodyLengthTag = env_get("HONOR_BODYLENGTHTAG") ? 0 : 1;
+		DKIMVerifyInit(&ctxt, &vopts);		/*- this is always successful */
+	}
+	/*- Initialization */
+	uid = getuid();
+	datetime_tai(&dt, starttime);
+	sig_pipeignore();
+	sig_miscignore();
+	sig_alarmcatch(sigalrm);
+	sig_bugcatch(sigbug);
+	alarm(DEATH);
+	mypid = getpid();
+	pidopen(); /*- fd = messfd */
+	if ((readfd = open_read(pidfn)) == -1)
+		die(63, dkimsign ? 1 : 2);
+	if (unlink(pidfn) == -1)
+		die(63, dkimsign ? 1 : 2);
+	substdio_fdbuf(&ssout, write, messfd, outbuf, sizeof(outbuf));
+	substdio_fdbuf(&ssin, read, 0, inbuf, sizeof(inbuf)); /*- message content */
+	for (ret = 0;;) {
+		register int    n;
+		register char  *x;
+
+		if ((n = substdio_feed(&ssin)) < 0) {
+			(dkimsign ? DKIMSignFree : DKIMVerifyFree) (&ctxt);
+			die_read();
+		}
+		if (!n)
+			break;
+		x = substdio_PEEK(&ssin);
+		if (!ret) {
+			if ((ret = (dkimsign ? DKIMSignProcess : DKIMVerifyProcess) (&ctxt, x, n)) == DKIM_INVALID_CONTEXT)
+				(dkimsign ? DKIMSignFree : DKIMVerifyFree) (&ctxt);
+			maybe_die_dkim(ret);
+		}
+		if (substdio_put(&ssout, x, n) == -1) {
+			(dkimsign ? DKIMSignFree : DKIMVerifyFree) (&ctxt);
+			die_write();
+		}
+		substdio_SEEK(&ssin, n);
+	}
+	if (substdio_flush(&ssout) == -1) {
+		(dkimsign ? DKIMSignFree : DKIMVerifyFree) (&ctxt);
+		die_write();
+	}
+	if (dkimsign || dkimverify) {
+		if (dkimsign) {
+			char           *t;
+
+			if (!(t = DKIMSignGetDomain(&ctxt))) {
+				DKIMSignFree(&ctxt);
+				maybe_die_dkim(DKIM_INVALID_CONTEXT);
+			}
+			write_signature(t, &sopts, sizeof(sopts.szSelector) - 1); /*- calls DKIMSignFree(&ctxt) */
+		} else
+		if (dkimverify) {
+			char            szPolicy[512];
+
+			if (!ret) {
+				if ((ret = DKIMVerifyResults(&ctxt, &sCount, &sSize)) != DKIM_SUCCESS)
+					maybe_die_dkim(ret);
+				if ((ret = DKIMVerifyGetDetails(&ctxt, &nSigCount, &pDetails, szPolicy)) != DKIM_SUCCESS)
+					maybe_die_dkim(ret);
+				else
+				for (ret = DKIM_FAIL,i = 0; i < nSigCount; i++) {
+					if (pDetails[i].nResult >= 0) {
+						ret = 0;
+					} else {
+						if (ret == DKIM_FAIL)
+							ret = pDetails[i].nResult;
+					}
+				}
+				if (!nSigCount)
+					ret = DKIM_NO_SIGNATURES;
+			}
+			/*- what to do if DKIM Verification fails */
+			if (checkPractice(ret, useADSP, useSSP)) {
+				char           *domain;
+				int             skip_nosignature_domain = 0;
+
+				origRet = ret;
+				if ((domain = DKIMVerifyGetDomain(&ctxt))) {
+					if (!(ptr = env_get("SIGNATUREDOMAINS"))) {
+						format_controlfile("signaturedomains", 2);
+						if (control_readfile(&sigdomains, fntmp.s, 0) == -1)
+							custom_error("qmail-dkim", "Z", "unable to read signaturedomains.", 0, "X.3.0");
+					} else
+					if (!stralloc_copys(&sigdomains, ptr))
+						die(51, 2);
+					for (len = 0, ptr = sigdomains.s;len < sigdomains.len;) {
+						len += ((token_len = str_len(ptr)) + 1); /*- next domain */
+						if (!case_diffb(ptr, token_len, domain)) {
+							ret = origRet;
+							skip_nosignature_domain = 1;
+							useADSP = 0;
+							useSSP = 0;
+							break;
+						}
+						ptr = sigdomains.s + len;
+					}
+					/* if not found in signaturedomains */
+					if (!skip_nosignature_domain) {
+						if (!(ptr = env_get("NOSIGNATUREDOMAINS"))) {
+							format_controlfile("nosignaturedomains", 2);
+							if (control_readfile(&nsigdomains, fntmp.s, 0) == -1)
+								custom_error("qmail-dkim", "Z", "unable to read nosignaturedomains.", 0, "X.3.0");
+						} else
+						if (!stralloc_copys(&nsigdomains, ptr))
+							die(51, 2);
+						for (len = 0, ptr = nsigdomains.s;len < nsigdomains.len;) {
+							len += ((token_len = str_len(ptr)) + 1); /*- next domain */
+							if (*ptr == '*' || !case_diffb(ptr, token_len, domain)) {
+								ret = DKIM_NEUTRAL;
+								useADSP = 0;
+								useSSP = 0;
+								break;
+							}
+							ptr = nsigdomains.s + len;
+						}
+					}
+				}
+				if (!domain || !*domain)
+					; /*- do nothing ? */
+				else
+				if (useADSP) {
+					resDKIMADSP = checkADSP(domain);
+					if (sCount > 0) {
+						if (resDKIMADSP == DKIM_ADSP_UNKNOWN || resDKIMADSP == DKIM_ADSP_ALL)
+							ret = (sCount == sSize ? DKIM_SUCCESS : DKIM_PARTIAL_SUCCESS);
+					}
+					/* if the message should be signed, return fail */
+					if (resDKIMADSP == DKIM_ADSP_DISCARDABLE)
+						ret = DKIM_FAIL;
+					else
+						ret = DKIM_NEUTRAL;
+				} else
+				if (useSSP) {
+					int             bTestingPractices = 0;
+					char           *domain_t;
+
+					if ((domain_t = DKIMVerifyGetDomain(&ctxt)))
+						resDKIMSSP = checkSSP(domain_t, &bTestingPractices);
+					if (sCount > 0) {
+						if ((resDKIMSSP == DKIM_SSP_UNKNOWN || resDKIMSSP == DKIM_SSP_ALL))
+							ret = (sCount == sSize ? DKIM_SUCCESS : DKIM_PARTIAL_SUCCESS);
+					}
+					// if the SSP is testing, return neutral
+					if (bTestingPractices)
+						ret = DKIM_NEUTRAL;
+					/* if the message should be signed, return fail */
+					if (resDKIMSSP == DKIM_SSP_ALL || resDKIMSSP == DKIM_SSP_STRICT)
+						ret = DKIM_FAIL;
+					else
+						ret = DKIM_NEUTRAL;
+				}
+			}
+			DKIMVerifyFree(&ctxt);
+			writeHeaderNexit(ret, origRet, resDKIMSSP, resDKIMADSP, useSSP, useADSP);
+		} /*- if (dkimverify) */
+	}
+	if (pipe(pim) == -1)
+		die(59, 0);
+	switch (pid = vfork())
+	{
+	case -1:
+		close(pim[0]);
+		close(pim[1]);
+		die(58, 0);
+	case 0:
+		close(pim[1]);
+		if (fd_move(0, pim[0]) == -1)
+			die(120, 0);
+		if (!(ptr = env_get("DKIMSIGNEXTRA")))
+			execv(*binqqargs, binqqargs);
+		else {
+			if (!env_put2("NODKIMKEYS", "qmail-dkim") || !env_put2("DKIMSIGN", ptr))
+				die(51, 0);
+			else
+			if ((ptr = env_get("DKIMSIGNOPTIONSEXTRA")) && !env_put2("DKIMSIGNOPTIONS", ptr))
+				die(51, 0);
+			if (!env_unset("DKIMSIGNEXTRA"))
+				die(51, 0);
+			execv(argv[0], argv);
+		}
+		die(120, 0);
+	}
+	close(pim[0]);
+	substdio_fdbuf(&ssin, read, readfd, inbuf, sizeof(inbuf));
+	substdio_fdbuf(&ssout, write, pim[1], outbuf, sizeof(outbuf));
+	if (substdio_bput(&ssout, dkimoutput.s, dkimoutput.len) == -1) /*- write DKIM signature */
+		die_write();
+	switch (substdio_copy(&ssout, &ssin))
+	{
+	case -2:
+		die_read();
+	case -3:
+		die_write();
+	}
+	if (substdio_flush(&ssout) == -1)
+		die_write();
+	close(pim[1]);
+	if (wait_pid(&wstat, pid) != pid)
+		die(122, 0);
+	if (wait_crashed(wstat))
+		die(123, 0);
+	die(wait_exitcode(wstat), 0);
+}
+
+#ifndef lint
+void
+getversion_qmail_dkim_c()
+{
+	static char    *x = "$Id: qmail-dkim.c,v 1.72 2023-02-01 18:15:33+05:30 Cprogrammer Exp mbhangui $";
+
+#ifdef HASDKIM
+	x = sccsidmakeargsh;
+	x = sccsidqmultih;
+	x = sccsidpidopenh;
+	x = sccsidgetdomainth;
+#endif
+	x++;
+}
+#endif
+
+/*
+ * $Log: qmail-dkim.c,v $
+ * Revision 1.75  2023-02-17 11:49:48+05:30  Cprogrammer
+ * added env variable NODKIMKEYS to disable reading of dkimkeys control file
+ * disable dkimkeys when doing DKIMSIGNEXTRA
+ *
+ * Revision 1.72  2023-02-01 18:15:33+05:30  Cprogrammer
+ * use dkimkeys for setting env variables facilitating multi-signature generation with mixed encryption methods
+ *
+ * Revision 1.71  2023-01-30 10:42:16+05:30  Cprogrammer
+ * set pfnSelectorCallback to dns_bypass if SELECTOR_DATA is set
+ *
+ * Revision 1.70  2023-01-29 22:37:42+05:30  Cprogrammer
+ * fixed ed25519 signature
+ * added DKIMSIGNEXTRA, DKIMSIGNOPTIONSEXTRA env variables to insert additional signature
+ *
+ * Revision 1.69  2023-01-26 22:59:19+05:30  Cprogrammer
+ * removed setting redundant -b option
+ * update verification message to include ED25519 failure
+ *
+ * Revision 1.68  2022-10-17 19:44:32+05:30  Cprogrammer
+ * use exit codes defines from qmail.h
+ *
+ * Revision 1.67  2022-10-17 12:28:50+05:30  Cprogrammer
+ * replace all '%' character with domain name
+ *
+ * Revision 1.66  2022-10-03 12:28:16+05:30  Cprogrammer
+ * fixed return exit codes
+ *
+ * Revision 1.65  2022-10-02 22:21:48+05:30  Cprogrammer
+ * fixed 'Private key file does not exist' for DKIMSIGN with '%'
+ *
+ * Revision 1.64  2022-04-03 18:44:21+05:30  Cprogrammer
+ * refactored qmail_open() error codes
+ *
+ * Revision 1.63  2022-03-08 22:59:35+05:30  Cprogrammer
+ * use custom_error() from custom_error.c
+ *
+ * Revision 1.62  2021-09-12 14:17:30+05:30  Cprogrammer
+ * restore gid after reading private key file
+ *
+ * Revision 1.61  2021-08-29 23:27:08+05:30  Cprogrammer
+ * define functions as noreturn
+ *
+ * Revision 1.60  2021-08-28 23:16:06+05:30  Cprogrammer
+ * control file dkimkeys for domain specific private key, selector
+ *
+ * Revision 1.59  2021-06-15 22:15:14+05:30  Cprogrammer
+ * pass tmpdir argument to pidopen
+ *
+ * Revision 1.58  2021-06-15 11:53:44+05:30  Cprogrammer
+ * moved pidopen out to its own file
+ *
+ * Revision 1.57  2021-06-09 21:14:33+05:30  Cprogrammer
+ * use qmulti() instead of exec of qmail-multi
+ *
+ * Revision 1.56  2021-05-26 10:44:21+05:30  Cprogrammer
+ * handle access() error other than ENOENT
+ *
+ * Revision 1.55  2020-05-11 11:06:35+05:30  Cprogrammer
+ * fixed shadowing of global variables by local variables
+ *
+ * Revision 1.54  2020-04-01 16:14:36+05:30  Cprogrammer
+ * added header for makeargs() function
+ *
+ * Revision 1.53  2019-06-14 21:26:37+05:30  Cprogrammer
+ * added env variable HONOR_BODYLENGTHTAG to honor body length tag during verification
+ *
+ * Revision 1.52  2019-02-18 22:18:12+05:30  Cprogrammer
+ * allow DKIMVERIFY env variable in place of DKIMPRACTICE when SIGN_PRACTICE="local"
+ *
+ * Revision 1.51  2019-02-17 11:38:51+05:30  Cprogrammer
+ * set original DKIM error for SIGN_PRACTICE=local
+ *
+ * Revision 1.50  2019-02-15 21:25:04+05:30  Cprogrammer
+ * skip nosignaturedomains if domain is present in signaturedomains
+ *
+ * Revision 1.49  2018-08-08 23:58:01+05:30  Cprogrammer
+ * issue success if at lease one one good signature is found
+ *
+ * Revision 1.48  2017-09-05 12:37:16+05:30  Cprogrammer
+ * added missing DKIM_MFREE()
+ *
+ * Revision 1.47  2016-06-03 09:57:59+05:30  Cprogrammer
+ * moved qmail-multi to sbin
+ *
+ * Revision 1.46  2016-05-17 19:44:58+05:30  Cprogrammer
+ * use auto_control, set by conf-control to set control directory
+ *
+ * Revision 1.45  2016-03-01 18:48:02+05:30  Cprogrammer
+ * added env variable UNSIGNED_SUBJECT to verify dkim without subject field
+ *
+ * Revision 1.44  2015-12-15 16:05:58+05:30  Cprogrammer
+ * increased buffer size for long header issue
+ *
+ * Revision 1.43  2014-01-22 22:45:01+05:30  Cprogrammer
+ * treat AUTHINFO environment like RELAYCLIENT environment variable
+ *
+ * Revision 1.42  2013-10-01 17:11:24+05:30  Cprogrammer
+ * fixed QMAILQUEUE recursion
+ *
+ * Revision 1.41  2013-09-16 22:16:35+05:30  Cprogrammer
+ * corrected logic for RELAYCLIENT_NODKIMVERIFY
+ *
+ * Revision 1.40  2013-09-13 16:34:35+05:30  Cprogrammer
+ * turn off verification if RELAYCLIENT, DKIMVERIFY and RELAYCLIENT_NODKIMVERIFY is set
+ *
+ * Revision 1.39  2013-08-18 15:53:30+05:30  Cprogrammer
+ * revert back to default verification mode if both dksign, dkverify are not set
+ *
+ * Revision 1.38  2013-08-17 15:00:33+05:30  Cprogrammer
+ * BUG - corrected location of private key when % sign is removed
+ *
+ * Revision 1.37  2013-01-24 22:37:22+05:30  Cprogrammer
+ * BUG (fix by Piotr Gronek) - DKIM_FREE(results) called before call to ParseTagValues()
+ * alternate code for DKIMSIGN selector file name
+ *
+ * Revision 1.36  2012-08-16 08:01:46+05:30  Cprogrammer
+ * do not skip X-Mailer headers
+ *
+ * Revision 1.35  2011-11-10 14:32:08+05:30  Cprogrammer
+ * BUG ssout to be assigned only after pidopen
+ *
+ * Revision 1.34  2011-11-07 09:35:59+05:30  Cprogrammer
+ * set ssout, sserr, ssin before executing other functions
+ *
+ * Revision 1.33  2011-07-29 09:29:17+05:30  Cprogrammer
+ * fixed key file name
+ *
+ * Revision 1.32  2011-07-28 19:36:36+05:30  Cprogrammer
+ * BUG - fixed opening of private key with absolute path
+ *
+ * Revision 1.31  2011-07-22 14:40:05+05:30  Cprogrammer
+ * fixed checking of private key file
+ *
+ * Revision 1.30  2011-06-04 14:49:48+05:30  Cprogrammer
+ * remove '%' sign from private key if key not found
+ *
+ * Revision 1.29  2011-06-04 14:22:29+05:30  Cprogrammer
+ * added DKIM_UNSIGNED_FROM error code for dkimpractice
+ *
+ * Revision 1.28  2011-06-04 14:07:41+05:30  Cprogrammer
+ * added DKIM_UNSIGNED_FROM
+ *
+ * Revision 1.27  2011-02-10 23:39:59+05:30  Cprogrammer
+ * use DKIMKEY to override defult control/domainkeys/%/default
+ *
+ * Revision 1.26  2011-02-06 10:13:50+05:30  Cprogrammer
+ * BUG - signature was wrongly freed before being accessed.
+ *
+ * Revision 1.25  2011-02-05 09:47:47+05:30  Cprogrammer
+ * fixed SIGSEGV occuring for messages without body
+ *
+ * Revision 1.24  2010-11-02 18:45:14+05:30  Cprogrammer
+ * Improve DKIM signing/verification speed
+ *
+ * Revision 1.23  2010-07-21 08:59:57+05:30  Cprogrammer
+ * use CONTROLDIR environment variable instead of a hardcoded control directory
+ *
+ * Revision 1.22  2009-04-22 13:42:51+05:30  Cprogrammer
+ * made fd for custom error configurable through env variable ERROR_FD
+ *
+ * Revision 1.21  2009-04-21 09:05:48+05:30  Cprogrammer
+ * return relevant error message for reading private key
+ *
+ * Revision 1.20  2009-04-21 08:55:41+05:30  Cprogrammer
+ * return temporary error for temp failures
+ *
+ * Revision 1.19  2009-04-20 22:19:01+05:30  Cprogrammer
+ * made dkimopts global
+ *
+ * Revision 1.18  2009-04-16 13:48:32+05:30  Cprogrammer
+ * added dkim_setoptions() to set all DKIM options
+ *
+ * Revision 1.17  2009-04-07 11:36:56+05:30  Cprogrammer
+ * use TMPDIR env variable for tmp directory
+ *
+ * Revision 1.16  2009-04-05 12:52:17+05:30  Cprogrammer
+ * added preprocessor warning
+ *
+ * Revision 1.15  2009-04-04 00:33:44+05:30  Cprogrammer
+ * removed dk_strdup()
+ *
+ * Revision 1.14  2009-03-31 08:21:58+05:30  Cprogrammer
+ * set dkimsign when RELAYCLIENT is defined when both dkimsign and dkimverify are undefined
+ *
+ * Revision 1.13  2009-03-30 22:25:54+05:30  Cprogrammer
+ * made DKIM messages friendlier
+ *
+ * Revision 1.12  2009-03-30 14:47:59+05:30  Cprogrammer
+ * added descriptive text for original dkim error
+ *
+ * Revision 1.11  2009-03-29 19:20:43+05:30  Cprogrammer
+ * added nosignaturedomains
+ *
+ * Revision 1.10  2009-03-28 22:27:02+05:30  Cprogrammer
+ * use DKIMSIGN, DKIMVERIFY if RELAYCLIENT is not set
+ *
+ * Revision 1.9  2009-03-28 22:03:05+05:30  Cprogrammer
+ * fixed DKIM return codes
+ *
+ * Revision 1.8  2009-03-28 13:37:37+05:30  Cprogrammer
+ * call DKIMVerifyGetDetails() always
+ *
+ * Revision 1.7  2009-03-28 11:39:23+05:30  Cprogrammer
+ * set automatic setting of dkimsign, dkimverify variables based on RELAYCLIENT
+ *
+ * Revision 1.6  2009-03-28 11:35:58+05:30  Cprogrammer
+ * added ADSP/SSP
+ *
+ * Revision 1.5  2009-03-22 17:39:38+05:30  Cprogrammer
+ * set identity using basename of signature or environment variable DKIMIDENTITY
+ *
+ * Revision 1.4  2009-03-22 16:58:38+05:30  Cprogrammer
+ * fixed bug with verification
+ * report custom errors to qmail-queue through custom error interface
+ *
+ * Revision 1.3  2009-03-21 12:34:38+05:30  Cprogrammer
+ * use hasdkim.h for conditional compilation of dkim
+ *
+ * Revision 1.2  2009-03-20 22:35:57+05:30  Cprogrammer
+ * set error to DKIM_NO_SIGNATURE when DKIM-Signature is not present
+ *
+ * Revision 1.1  2009-03-18 13:54:49+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
diff -Naur netqmail-1.06.org/qmail.h netqmail-1.06/qmail.h
--- netqmail-1.06.org/qmail.h	1998-06-15 16:23:16.000000000 +0530
+++ netqmail-1.06/qmail.h	2022-12-09 22:58:50.000000000 +0530
@@ -3,11 +3,13 @@
 
 #include "substdio.h"
 
+#define CUSTOM_ERR_FD 4
 struct qmail {
   int flagerr;
   unsigned long pid;
   int fdm;
   int fde;
+  int fdc;
   substdio ss;
   char buf[1024];
 } ;
diff -Naur netqmail-1.06.org/qmail-inject.c netqmail-1.06/qmail-inject.c
--- netqmail-1.06.org/qmail-inject.c	1998-06-15 16:23:16.000000000 +0530
+++ netqmail-1.06/qmail-inject.c	2022-12-09 22:58:50.000000000 +0530
@@ -55,7 +55,7 @@
 
 void put(s,len) char *s; int len;
 { if (flagqueue) qmail_put(&qqt,s,len); else substdio_put(subfdout,s,len); }
-void puts(s) char *s; { put(s,str_len(s)); }
+void my_puts(s) char *s; { put(s,str_len(s)); }
 
 void perm() { _exit(100); }
 void temp() { _exit(111); }
@@ -549,16 +549,16 @@
 
   if (i == tocclist.len) return;
 
-  puts("Mail-Followup-To: ");
+  my_puts("Mail-Followup-To: ");
   i = tocclist.len;
   while (i--) {
     if (!stralloc_copy(&sa,&tocclist.sa[i])) die_nomem();
     if (!stralloc_0(&sa)) die_nomem();
     if (!quote2(&sa2,sa.s)) die_nomem();
     put(sa2.s,sa2.len);
-    if (i) puts(",\n  ");
+    if (i) my_puts(",\n  ");
   }
-  puts("\n");
+  my_puts("\n");
 }
 
 void finishheader()
@@ -580,9 +580,9 @@
    if (!stralloc_0(&sa)) die_nomem();
    if (!quote2(&sa2,sa.s)) die_nomem();
 
-   puts("Return-Path: <");
+   my_puts("Return-Path: <");
    put(sa2.s,sa2.len);
-   puts(">\n");
+   my_puts(">\n");
   }
 
  /* could check at this point whether there are any recipients */
@@ -594,23 +594,23 @@
    if (!htypeseen[H_R_DATE])
     {
      if (!newfield_datemake(starttime)) die_nomem();
-     puts("Resent-");
+     my_puts("Resent-");
      put(newfield_date.s,newfield_date.len);
     }
    if (!htypeseen[H_R_MESSAGEID])
     {
      if (!newfield_msgidmake(control_idhost.s,control_idhost.len,starttime)) die_nomem();
-     puts("Resent-");
+     my_puts("Resent-");
      put(newfield_msgid.s,newfield_msgid.len);
     }
    if (!htypeseen[H_R_FROM])
     {
      defaultfrommake();
-     puts("Resent-");
+     my_puts("Resent-");
      put(defaultfrom.s,defaultfrom.len);
     }
    if (!htypeseen[H_R_TO] && !htypeseen[H_R_CC])
-     puts("Resent-Cc: recipient list not shown: ;\n");
+     my_puts("Resent-Cc: recipient list not shown: ;\n");
   }
  else
   {
@@ -630,7 +630,7 @@
      put(defaultfrom.s,defaultfrom.len);
     }
    if (!htypeseen[H_TO] && !htypeseen[H_CC])
-     puts("Cc: recipient list not shown: ;\n");
+     my_puts("Cc: recipient list not shown: ;\n");
    finishmft();
   }
 
diff -Naur netqmail-1.06.org/qmail-lspawn.c netqmail-1.06/qmail-lspawn.c
--- netqmail-1.06.org/qmail-lspawn.c	1998-06-15 16:23:16.000000000 +0530
+++ netqmail-1.06/qmail-lspawn.c	2022-12-09 22:58:50.000000000 +0530
@@ -1,4 +1,5 @@
 #include "fd.h"
+#include "env.h"
 #include "wait.h"
 #include "prot.h"
 #include "substdio.h"
@@ -170,6 +171,7 @@
 char *s; char *r; int at;
 {
  int f;
+ char *ptr;
 
  if (!(f = fork()))
   {
@@ -226,7 +228,10 @@
    if (prot_uid(uid) == -1) _exit(QLX_USAGE);
    if (!getuid()) _exit(QLX_ROOT);
 
-   execv(*args,args);
+	if(!(ptr = env_get("QMAILLOCAL")))
+		execv(*args, args);
+	else
+		execv(ptr, args);
    if (error_temp(errno)) _exit(QLX_EXECSOFT);
    _exit(QLX_EXECHARD);
   }
diff -Naur netqmail-1.06.org/qmail-pop3d.c netqmail-1.06/qmail-pop3d.c
--- netqmail-1.06.org/qmail-pop3d.c	2007-12-01 01:52:54.000000000 +0530
+++ netqmail-1.06/qmail-pop3d.c	2022-12-09 22:58:50.000000000 +0530
@@ -45,7 +45,7 @@
 {
   substdio_put(&ssout,buf,len);
 }
-void puts(s) char *s;
+void my_puts(s) char *s;
 {
   substdio_puts(&ssout,s);
 }
@@ -55,9 +55,9 @@
 }
 void err(s) char *s;
 {
-  puts("-ERR ");
-  puts(s);
-  puts("\r\n");
+  my_puts("-ERR ");
+  my_puts(s);
+  my_puts("\r\n");
   flush();
 }
 
@@ -73,7 +73,7 @@
 void err_nosuch() { err("unable to open that message"); }
 void err_nounlink() { err("unable to unlink all deleted messages"); }
 
-void okay(arg) char *arg; { puts("+OK \r\n"); flush(); }
+void okay(arg) char *arg; { my_puts("+OK \r\n"); flush(); }
 
 void printfn(fn) char *fn;
 {
@@ -153,11 +153,11 @@
  
   total = 0;
   for (i = 0;i < numm;++i) if (!m[i].flagdeleted) total += m[i].size;
-  puts("+OK ");
+  my_puts("+OK ");
   put(strnum,fmt_uint(strnum,numm));
-  puts(" ");
+  my_puts(" ");
   put(strnum,fmt_ulong(strnum,total));
-  puts("\r\n");
+  my_puts("\r\n");
   flush();
 }
 
@@ -171,9 +171,9 @@
 
 void pop3_last(arg) char *arg;
 {
-  puts("+OK ");
+  my_puts("+OK ");
   put(strnum,fmt_uint(strnum,last));
-  puts("\r\n");
+  my_puts("\r\n");
   flush();
 }
 
@@ -222,10 +222,10 @@
 int flaguidl;
 {
   put(strnum,fmt_uint(strnum,i + 1));
-  puts(" ");
+  my_puts(" ");
   if (flaguidl) printfn(m[i].fn);
   else put(strnum,fmt_ulong(strnum,m[i].size));
-  puts("\r\n");
+  my_puts("\r\n");
 }
 
 void dolisting(arg,flaguidl) char *arg; int flaguidl;
@@ -234,7 +234,7 @@
   if (*arg) {
     i = msgno(arg);
     if (i == -1) return;
-    puts("+OK ");
+    my_puts("+OK ");
     list(i,flaguidl);
   }
   else {
@@ -242,7 +242,7 @@
     for (i = 0;i < numm;++i)
       if (!m[i].flagdeleted)
 	list(i,flaguidl);
-    puts(".\r\n");
+    my_puts(".\r\n");
   }
   flush();
 }
diff -Naur netqmail-1.06.org/qmail-popup.c netqmail-1.06/qmail-popup.c
--- netqmail-1.06.org/qmail-popup.c	2007-12-01 01:52:54.000000000 +0530
+++ netqmail-1.06/qmail-popup.c	2022-12-09 22:58:50.000000000 +0530
@@ -38,7 +38,7 @@
 char ssinbuf[128];
 substdio ssin = SUBSTDIO_FDBUF(saferead,0,ssinbuf,sizeof ssinbuf);
 
-void puts(s) char *s;
+void my_puts(s) char *s;
 {
   substdio_puts(&ssout,s);
 }
@@ -48,9 +48,9 @@
 }
 void err(s) char *s;
 {
-  puts("-ERR ");
-  puts(s);
-  puts("\r\n");
+  my_puts("-ERR ");
+  my_puts(s);
+  my_puts("\r\n");
   flush();
 }
 
@@ -66,7 +66,7 @@
 void err_wantuser() { err("USER first"); }
 void err_authoriz(arg) char *arg; { err("authorization first"); }
 
-void okay(arg) char *arg; { puts("+OK \r\n"); flush(); }
+void okay(arg) char *arg; { my_puts("+OK \r\n"); flush(); }
 void pop3_quit(arg) char *arg; { okay(0); die(); }
 
 
@@ -127,10 +127,10 @@
   s += fmt_ulong(s,(unsigned long) now());
   *s++ = '@';
   *s++ = 0;
-  puts("+OK <");
-  puts(unique);
-  puts(hostname);
-  puts(">\r\n");
+  my_puts("+OK <");
+  my_puts(unique);
+  my_puts(hostname);
+  my_puts(">\r\n");
   flush();
 }
 void pop3_user(arg) char *arg;
diff -Naur netqmail-1.06.org/qmail-pw2u.c netqmail-1.06/qmail-pw2u.c
--- netqmail-1.06.org/qmail-pw2u.c	1998-06-15 16:23:16.000000000 +0530
+++ netqmail-1.06/qmail-pw2u.c	2022-12-09 22:58:50.000000000 +0530
@@ -1,3 +1,4 @@
+#include <unistd.h>
 #include <sys/types.h>
 #include <sys/stat.h>
 #include "substdio.h"
diff -Naur netqmail-1.06.org/qmail-qmtpd.c netqmail-1.06/qmail-qmtpd.c
--- netqmail-1.06.org/qmail-qmtpd.c	1998-06-15 16:23:16.000000000 +0530
+++ netqmail-1.06/qmail-qmtpd.c	2022-12-09 22:58:50.000000000 +0530
@@ -1,3 +1,5 @@
+#include <unistd.h>
+#include <unistd.h>
 #include "stralloc.h"
 #include "substdio.h"
 #include "qmail.h"
diff -Naur netqmail-1.06.org/qmail-rspawn.c netqmail-1.06/qmail-rspawn.c
--- netqmail-1.06.org/qmail-rspawn.c	1998-06-15 16:23:16.000000000 +0530
+++ netqmail-1.06/qmail-rspawn.c	2022-12-09 22:58:50.000000000 +0530
@@ -1,3 +1,4 @@
+#include "env.h"
 #include "fd.h"
 #include "wait.h"
 #include "substdio.h"
@@ -82,7 +83,7 @@
 char *s; char *r; int at;
 {
  int f;
- char *(args[5]);
+ char *ptr, *(args[5]);
 
  args[0] = "qmail-remote";
  args[1] = r + at + 1;
@@ -95,7 +96,10 @@
    if (fd_move(0,fdmess) == -1) _exit(111);
    if (fd_move(1,fdout) == -1) _exit(111);
    if (fd_copy(2,1) == -1) _exit(111);
-   execvp(*args,args);
+   if(!(ptr = env_get("QMAILREMOTE")))
+      execvp(*args, args);
+   else
+      execvp(ptr, args);
    if (error_temp(errno)) _exit(111);
    _exit(100);
   }
diff -Naur netqmail-1.06.org/qmail-send.c netqmail-1.06/qmail-send.c
--- netqmail-1.06.org/qmail-send.c	1998-06-15 16:23:16.000000000 +0530
+++ netqmail-1.06/qmail-send.c	2022-12-09 22:58:50.000000000 +0530
@@ -754,7 +754,7 @@
     { log1("warning: trouble injecting bounce message, will try later\n"); return 0; }
 
    strnum2[fmt_ulong(strnum2,id)] = 0;
-   log2("bounce msg ",strnum2);
+   my_log2("bounce msg ",strnum2);
    strnum2[fmt_ulong(strnum2,qp)] = 0;
    log3(" qp ",strnum2,"\n");
   }
@@ -794,8 +794,8 @@
   for (c = 0;c < CHANNELS;++c) {
     strnum2[fmt_ulong(strnum2,(unsigned long) concurrencyused[c])] = 0;
     strnum3[fmt_ulong(strnum3,(unsigned long) concurrency[c])] = 0;
-    log2(chanstatusmsg[c],strnum2);
-    log2("/",strnum3);
+    my_log2(chanstatusmsg[c],strnum2);
+    my_log2("/",strnum3);
   }
   if (flagexitasap) log1(" exitasap");
   log1("\n");
@@ -859,7 +859,7 @@
 
  strnum2[fmt_ulong(strnum2,d[c][i].delid)] = 0;
  strnum3[fmt_ulong(strnum3,jo[j].id)] = 0;
- log2("starting delivery ",strnum2);
+ my_log2("starting delivery ",strnum2);
  log3(": msg ",strnum3,tochan[c]);
  logsafe(recip);
  log1("\n");
@@ -1352,14 +1352,14 @@
 	 fnmake_info(id);
          log3("warning: trouble writing to ",fn.s,"\n"); goto fail;
 	}
-       log2("info msg ",strnum3);
+       my_log2("info msg ",strnum3);
        strnum2[fmt_ulong(strnum2,(unsigned long) st.st_size)] = 0;
-       log2(": bytes ",strnum2);
+       my_log2(": bytes ",strnum2);
        log1(" from <"); logsafe(todoline.s + 1);
        strnum2[fmt_ulong(strnum2,pid)] = 0;
-       log2("> qp ",strnum2);
+       my_log2("> qp ",strnum2);
        strnum2[fmt_ulong(strnum2,uid)] = 0;
-       log2(" uid ",strnum2);
+       my_log2(" uid ",strnum2);
        log1("\n");
        break;
      case 'T':
diff -Naur netqmail-1.06.org/qmail-showctl.c netqmail-1.06/qmail-showctl.c
--- netqmail-1.06.org/qmail-showctl.c	1998-06-15 16:23:16.000000000 +0530
+++ netqmail-1.06/qmail-showctl.c	2022-12-09 22:58:50.000000000 +0530
@@ -112,7 +112,7 @@
   substdio_puts(subfdout,"\n");
   substdio_puts(subfdout,fn);
   substdio_puts(subfdout,": ");
-  switch(control_readfile(&line,fn)) {
+  switch(control_readfile(&line,fn, 0)) {
     case 0:
       substdio_puts(subfdout,"(Default.) ");
       substdio_puts(subfdout,def);
diff -Naur netqmail-1.06.org/qmail-smtpd.c netqmail-1.06/qmail-smtpd.c
--- netqmail-1.06.org/qmail-smtpd.c	2007-12-01 01:52:54.000000000 +0530
+++ netqmail-1.06/qmail-smtpd.c	2022-12-09 22:58:50.000000000 +0530
@@ -25,6 +25,7 @@
 #include "commands.h"
 
 #define MAXHOPS 100
+static char     strnum[FMT_ULONG];
 unsigned int databytes = 0;
 int timeout = 1200;
 
@@ -218,6 +219,7 @@
 
 
 int seenmail = 0;
+int rcptcount = 0;
 int flagbarf; /* defined if seenmail */
 stralloc mailfrom = {0};
 stralloc rcptto = {0};
@@ -261,6 +263,7 @@
   if (!stralloc_cats(&rcptto,"T")) die_nomem();
   if (!stralloc_cats(&rcptto,addr.s)) die_nomem();
   if (!stralloc_0(&rcptto)) die_nomem();
+  rcptcount++;
   out("250 ok\r\n");
 }
 
diff -Naur netqmail-1.06.org/qregex.c netqmail-1.06/qregex.c
--- netqmail-1.06.org/qregex.c	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/qregex.c	2022-12-09 22:58:50.000000000 +0530
@@ -0,0 +1,239 @@
+/*
+ * $Log: qregex.c,v $
+ * Revision 1.13  2007-12-20 13:51:04+05:30  Cprogrammer
+ * removed compiler warning
+ *
+ * Revision 1.12  2005-08-23 17:41:36+05:30  Cprogrammer
+ * regex to be turned on only of QREGEX is defined to non-zero value
+ *
+ * Revision 1.11  2005-04-02 19:07:25+05:30  Cprogrammer
+ * use internal wildmat version
+ *
+ * Revision 1.10  2005-01-22 00:39:04+05:30  Cprogrammer
+ * added missing error handling
+ *
+ * Revision 1.9  2004-10-22 20:29:45+05:30  Cprogrammer
+ * added RCS id
+ *
+ * Revision 1.8  2004-09-21 23:48:18+05:30  Cprogrammer
+ * made matchregex() visible
+ * introduced dotChar (configurable dot char)
+ *
+ * Revision 1.7  2004-02-05 18:48:48+05:30  Cprogrammer
+ * changed curregex to static
+ *
+ * Revision 1.6  2003-12-23 23:22:53+05:30  Cprogrammer
+ * implicitly use wildcard if address starts with '@'
+ *
+ * Revision 1.5  2003-12-22 18:33:12+05:30  Cprogrammer
+ * added address_match()
+ *
+ * Revision 1.4  2003-12-22 13:21:08+05:30  Cprogrammer
+ * added text and pattern as part of error message
+ *
+ * Revision 1.3  2003-12-22 10:04:04+05:30  Cprogrammer
+ * conditional compilation of qregex
+ *
+ * Revision 1.2  2003-12-21 15:32:18+05:30  Cprogrammer
+ * added regerror
+ *
+ * Revision 1.1  2003-12-20 13:17:16+05:30  Cprogrammer
+ * Initial revision
+ *
+ * qregex (v2)
+ * $Id: qregex.c,v 1.13 2007-12-20 13:51:04+05:30 Cprogrammer Stab mbhangui $
+ *
+ * Author  : Evan Borgstrom (evan at unixpimps dot org)
+ * Created : 2001/12/14 23:08:16
+ * Modified: $Date: 2007-12-20 13:51:04+05:30 $
+ * Revision: $Revision: 1.13 $
+ *
+ * Do POSIX regex matching on addresses for anti-relay / spam control.
+ * It logs to the maillog
+ * See the qregex-readme file included with this tarball.
+ * If you didn't get this file in a tarball please see the following URL:
+ *  http://www.unixpimps.org/software/qregex
+ *
+ * qregex.c is released under a BSD style copyright.
+ * See http://www.unixpimps.org/software/qregex/copyright.html
+ *
+ * Note: this revision follows the coding guidelines set forth by the rest of
+ *       the qmail code and that described at the following URL.
+ *       http://cr.yp.to/qmail/guarantee.html
+ * 
+ */
+#include "case.h"
+#include "scan.h"
+#include "stralloc.h"
+#include "constmap.h"
+#include "substdio.h"
+#include "byte.h"
+#include "env.h"
+#include <sys/types.h>
+#include <regex.h>
+#include <unistd.h>
+
+static int      wildmat_match(stralloc *, int, struct constmap *, int, stralloc *);
+static int      regex_match(stralloc *, int, stralloc *);
+int             wildmat_internal(char *, char *);
+
+static char     sserrbuf[512];
+static substdio sserr = SUBSTDIO_FDBUF(write, 2, sserrbuf, sizeof(sserrbuf));
+static char     dotChar = '@';
+
+int
+address_match(stralloc *addr, int bhfok, stralloc *bhf,
+	struct constmap *mapbhf, int bhpok, stralloc *bhp)
+{
+	char           *ptr;
+	int             x = 0;
+
+	case_lowerb(addr->s, addr->len); /*- convert into lower case */
+	if ((ptr = env_get("QREGEX")))
+		scan_int(ptr, &x);
+	if (ptr && x)
+		return (regex_match(addr, bhfok, bhf));
+	else
+		return (wildmat_match(addr, bhfok, mapbhf, bhpok, bhp));
+}
+
+int
+matchregex(char *text, char *regex)
+{
+	regex_t         qreg;
+	char            errbuf[512];
+	int             retval = 0;
+
+#define REGCOMP(X,Y)    regcomp(&X, Y, REG_EXTENDED|REG_ICASE)
+	/*- build the regex */
+	if ((retval = REGCOMP(qreg, regex)) != 0)
+	{
+		regerror(retval, &qreg, errbuf, sizeof(errbuf));
+		regfree(&qreg);
+		if (substdio_puts(&sserr, text) == -1)
+			return (-retval);
+		if (substdio_puts(&sserr, ": ") == -1)
+			return (-retval);
+		if (substdio_puts(&sserr, regex) == -1)
+			return (-retval);
+		if (substdio_puts(&sserr, ": ") == -1)
+			return (-retval);
+		if (substdio_puts(&sserr, errbuf) == -1)
+			return (-retval);
+		if (substdio_puts(&sserr, "\n") == -1)
+			return (-retval);
+		if (substdio_flush(&sserr) == -1)
+			return (-retval);
+		return (-retval);
+	}
+	/*- execute the regex */
+#define REGEXEC(X,Y)    regexec(&X, Y, (size_t) 0, (regmatch_t *) 0, (int) 0)
+	retval = REGEXEC(qreg, text);
+	regfree(&qreg);
+	return (retval == REG_NOMATCH ? 0 : 1);
+}
+
+static int
+wildmat_match(stralloc * addr, int mapfile, struct constmap *ptrmap, int patfile, stralloc *wildcard)
+{
+	int             i = 0;
+	int             j = 0;
+	int             k = 0;
+	char            subvalue;
+
+	if (mapfile)
+	{
+		if (constmap(ptrmap, addr->s, addr->len - 1))
+			return 1;
+		if ((j = byte_rchr(addr->s, addr->len, dotChar)) < addr->len)
+		{
+			if (constmap(ptrmap, addr->s + j, addr->len - j - 1))
+				return 1;
+		}
+	}
+	/*- Include control file control/xxxxpatterns and evaluate with Wildmat check */
+	if (patfile && wildcard)
+	{
+		i = 0;
+		for (j = 0; j < wildcard->len; ++j)
+		{
+			if (!wildcard->s[j])
+			{
+				subvalue = wildcard->s[i] != '!';
+				if (!subvalue)
+					i++;
+				if ((k != subvalue) && wildmat_internal(addr->s, wildcard->s + i))
+					k = subvalue;
+				i = j + 1;
+			}
+		}
+		return k;
+	}
+	return (0);
+}
+
+static int
+regex_match(stralloc * addr, int mapfile, stralloc *map)
+{
+	int             i = 0;
+	int             j = 0;
+	int             k = 0;
+	int             negate = 0, match;
+	static stralloc curregex = { 0 };
+
+	match = 0;
+	if (mapfile)
+	{
+		while (j < map->len)
+		{
+			i = j;
+			while ((map->s[i] != '\0') && (i < map->len))
+				i++;
+			if (map->s[j] == '!')
+			{
+				negate = 1;
+				j++;
+			}
+			if (*(map->s + j) == dotChar)
+			{
+				if (!stralloc_copys(&curregex, ".*"))
+					return(-1);
+				if (!stralloc_catb(&curregex, map->s + j, (i - j)))
+					return(-1);
+			} else
+			if (!stralloc_copyb(&curregex, map->s + j, (i - j)))
+				return(-1);
+			if (!stralloc_0(&curregex))
+				return(-1);
+			if((k = matchregex(addr->s, curregex.s)) == 1)
+			{
+				if (negate)
+					return(0);
+				match = 1;
+			}
+			j = i + 1;
+			negate = 0;
+		}
+	}
+	return (match);
+}
+
+void
+setdotChar(c)
+	char            c;
+{
+	dotChar = c;
+	return;
+}
+
+void
+getversion_qregex_c()
+{
+	static char    *x = "$Id: qregex.c,v 1.13 2007-12-20 13:51:04+05:30 Cprogrammer Stab mbhangui $";
+
+#ifdef INDIMAIL
+	x = sccsidh;
+#else
+	x++;
+#endif
+}
diff -Naur netqmail-1.06.org/qregex.h netqmail-1.06/qregex.h
--- netqmail-1.06.org/qregex.h	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/qregex.h	2022-12-09 22:58:50.000000000 +0530
@@ -0,0 +1,24 @@
+/*
+ * $Log: qregex.h,v $
+ * Revision 1.3  2004-09-21 23:49:02+05:30  Cprogrammer
+ * added matchregex() and setdotChar()
+ *
+ * Revision 1.2  2003-12-22 18:35:26+05:30  Cprogrammer
+ * added address_match() function
+ *
+ * Revision 1.1  2003-12-20 13:17:45+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
+/*
+ * simple header file for the matchregex prototype 
+ */
+#ifndef _QREGEX_H_
+#define _QREGEX_H_
+#include "constmap.h"
+#include "stralloc.h"
+
+int             address_match(stralloc *, int, stralloc *, struct constmap *, int, stralloc *);
+int             matchregex(char *, char *);
+void            setdotChar(char);
+#endif
diff -Naur netqmail-1.06.org/qsutil.c netqmail-1.06/qsutil.c
--- netqmail-1.06.org/qsutil.c	1998-06-15 16:23:16.000000000 +0530
+++ netqmail-1.06/qsutil.c	2022-12-09 22:58:50.000000000 +0530
@@ -12,7 +12,7 @@
  substdio_putflush(&sserr,sa->s,sa->len); }
 void log1(s1) char *s1; {
  substdio_putsflush(&sserr,s1); }
-void log2(s1,s2) char *s1; char *s2; {
+void my_log2(s1,s2) char *s1; char *s2; {
  substdio_putsflush(&sserr,s1);
  substdio_putsflush(&sserr,s2); }
 void log3(s1,s2,s3) char *s1; char *s2; char *s3; {
diff -Naur netqmail-1.06.org/qsutil.h netqmail-1.06/qsutil.h
--- netqmail-1.06.org/qsutil.h	1998-06-15 16:23:16.000000000 +0530
+++ netqmail-1.06/qsutil.h	2022-12-09 22:58:50.000000000 +0530
@@ -2,7 +2,7 @@
 #define QSUTIL_H
 
 extern void log1();
-extern void log2();
+extern void my_log2();
 extern void log3();
 extern void logsa();
 extern void nomem();
diff -Naur netqmail-1.06.org/readwrite.h netqmail-1.06/readwrite.h
--- netqmail-1.06.org/readwrite.h	1998-06-15 16:23:16.000000000 +0530
+++ netqmail-1.06/readwrite.h	2022-12-09 22:58:50.000000000 +0530
@@ -1,7 +1,6 @@
 #ifndef READWRITE_H
 #define READWRITE_H
 
-extern int read();
-extern int write();
+#include <unistd.h>
 
 #endif
diff -Naur netqmail-1.06.org/scan.h netqmail-1.06/scan.h
--- netqmail-1.06.org/scan.h	1998-06-15 16:23:16.000000000 +0530
+++ netqmail-1.06/scan.h	2022-12-09 22:58:50.000000000 +0530
@@ -2,6 +2,7 @@
 #define SCAN_H
 
 extern unsigned int scan_uint();
+extern unsigned int scan_int();
 extern unsigned int scan_xint();
 extern unsigned int scan_nbbint();
 extern unsigned int scan_ushort();
diff -Naur netqmail-1.06.org/scan_ulong.c netqmail-1.06/scan_ulong.c
--- netqmail-1.06.org/scan_ulong.c	1998-06-15 16:23:16.000000000 +0530
+++ netqmail-1.06/scan_ulong.c	2022-12-09 22:58:50.000000000 +0530
@@ -9,3 +9,43 @@
     { result = result * 10 + c; ++pos; }
   *u = result; return pos;
 }
+
+unsigned int
+scan_int(s, i)
+	register char  *s;
+	register int   *i;
+{
+	register unsigned int pos;
+	register int result;
+	register unsigned char c;
+	int             sign;
+
+	pos = 0;
+	result = 0;
+	sign = 1;
+	/*-
+	 * determine sign of the number
+	 */
+	switch (s[0])
+	{
+		case '\0':
+			return 0;
+		case '-':
+			++pos;
+			sign = -1;
+			break;
+		case '+':
+			++pos;
+			sign = 1;
+			break;
+		default:
+			break;
+	}
+	while ((c = (unsigned char)(s[pos] - '0')) < 10)
+	{
+		result = result * 10 + c;
+		++pos;
+	}
+	*i = result * sign;
+	return pos;
+}
diff -Naur netqmail-1.06.org/scan_xlong.c netqmail-1.06/scan_xlong.c
--- netqmail-1.06.org/scan_xlong.c	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/scan_xlong.c	2022-12-09 22:58:50.000000000 +0530
@@ -0,0 +1,47 @@
+/*
+ * $Log: scan_xlong.c,v $
+ * Revision 1.2  2005-06-15 22:35:48+05:30  Cprogrammer
+ * added RCS version information
+ *
+ * Revision 1.1  2005-06-15 22:11:59+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
+#include "scan.h"
+
+static int
+fromhex(unsigned char c)
+{
+	if (c >= '0' && c <= '9')
+		return c - '0';
+	else
+	if (c >= 'A' && c <= 'F')
+		return c - 'A' + 10;
+	else
+	if (c >= 'a' && c <= 'f')
+		return c - 'a' + 10;
+	return -1;
+}
+
+unsigned int
+scan_xlong(char *src, unsigned long *dest)
+{
+	register const char *tmp = src;
+	register int    l = 0;
+	register unsigned char c;
+	while ((c = fromhex(*tmp)) < 16)
+	{
+		l = (l << 4) + c;
+		++tmp;
+	}
+	*dest = l;
+	return tmp - src;
+}
+
+void
+getversion_scan_xlong_c()
+{
+	static char    *x = "$Id: scan_xlong.c,v 1.2 2005-06-15 22:35:48+05:30 Cprogrammer Stab mbhangui $";
+
+	x++;
+}
diff -Naur netqmail-1.06.org/socket_v4mappedprefix.c netqmail-1.06/socket_v4mappedprefix.c
--- netqmail-1.06.org/socket_v4mappedprefix.c	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/socket_v4mappedprefix.c	2022-12-09 22:58:50.000000000 +0530
@@ -0,0 +1,9 @@
+/*
+ * $Log: socket_v4mappedprefix.c,v $
+ * Revision 1.1  2005-06-15 22:12:51+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
+#ifdef IPV6
+unsigned char V4mappedprefix[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff };
+#endif
diff -Naur netqmail-1.06.org/socket_v6any.c netqmail-1.06/socket_v6any.c
--- netqmail-1.06.org/socket_v6any.c	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/socket_v6any.c	2022-12-09 22:58:50.000000000 +0530
@@ -0,0 +1,9 @@
+/*
+ * $Log: socket_v6loopback.c,v $
+ * Revision 1.1  2005-06-15 22:13:07+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
+#ifdef IPV6
+const unsigned char V6any[16]={0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
+#endif
diff -Naur netqmail-1.06.org/softwarelicense1-1.html netqmail-1.06/softwarelicense1-1.html
--- netqmail-1.06.org/softwarelicense1-1.html	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/softwarelicense1-1.html	2022-12-09 22:58:50.000000000 +0530
@@ -0,0 +1,59 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
+<html>
+<head>
+<title>Yahoo! DomainKeys Public License Agreement v1.0</title>
+<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
+</head>
+
+<body>
+Yahoo! DomainKeys Public License Agreement v1.1<br>
+(this &quot;Agreement&quot;)
+<p>Copyright (c) 2004, Yahoo! Inc.<br>
+ All rights reserved.</p>
+
+<br>
+<a href=http://domainkeys.sourceforge.net/license/softwarelicense1-1.html>(Available online)</a>
+<br>
+
+
+<p>This Agreement is between Licensor and You.  You agree to be bound by all the terms and conditions set forth below, and, subject to those terms and conditions, You may use the intellectual property described below. </p>
+<p>1.    LICENSE GRANT. </p>
+<p>1.1. Subject to the terms and conditions of this Agreement, each DomainKeys Developer hereby grants You a royalty-free, perpetual, worldwide, sublicensable, non-exclusive license to use, reproduce, modify, publicly display, publicly perform, and distribute the Licensed Code.</p>
+<p>1.2. Subject to the terms and conditions of this Agreement, Licensor hereby grants You a royalty-free, perpetual, worldwide, sublicensable, non-exclusive license under its rights to the Yahoo! Patent Claims to make, use, sell, offer for sale, and/or import the Licensed Code for the sole purpose of implementing a sender verification solution in connection with e-mail. </p>
+<p>2.    DEFINITIONS. </p>
+<p>2.1. &quot;Contributions&quot; means any modifications to the Licensed Code, and/or any portions thereof, that are distributed under this Agreement.  A Contribution includes, without limitation, any addition to or deletion from the contents of a file containing any Licensed Code, or any new file that contains any part of the Licensed Code.</p>
+<p>2.2. &quot;DomainKeys Developer(s)&quot; means Yahoo, Inc. (&quot;Yahoo!&quot;), Licensor, and/or any other individual or entity who distributes code under this Agreement.</p>
+<p>2.3. &quot;Licensed Code&quot; means the Original Code, any Contributions (whether made by You or any DomainKeys Developer other than You), and the combination of Original Code and any such Contributions.</p>
+<p>2.4. &quot;Licensor&quot; means Yahoo! or any other individual or entity that elects to use this Agreement to license intellectual property to any licensee.</p>
+<p>2.5. &quot;Original Code&quot; means the source code and binary code that is based on the Specifications and distributed by or on behalf of Yahoo! under this Agreement for the sole purpose of implementing a sender verification solution in connection with e-mail, including any updates or upgrades to such code made available by Yahoo!.</p>
+<p>2.6. &quot;Specifications&quot; means the specification having submission ID &quot;draft-delany-domainkeys-base-01.txt&quot; dated Aug 2004 published through the IETF (Internet Engineering Task Force). The Specifications may be found at the following link: <br>
+<a href="http://antispam.yahoo.com/domainkeys/draft-delany-domainkeys-base-02.txt">http://antispam.yahoo.com/domainkeys/draft-delany-domainkeys-base-02.txt</a></p>
+<p>
+ 2.7. &quot;Yahoo! Patent Claims&quot; shall mean those claims of all Yahoo! foreign and domestic patents and patent applications that base their priority on U.S. Provisional Patent Application Ser. Nos. 60/497,794, filed Aug. 26, 2003, or 60/553,300, filed Mar. 15, 2004, or U.S. Patent Application Ser. Nos. 10/671,319, filed Sep. 24, 2003, or 10/805,181, filed Mar. 19, 2004.  </p>
+<p>2.8. &quot;You&quot; or &quot;Your&quot; means an individual, company, or other legal entity exercising any rights under this Agreement.  Any individual who accepts the terms and conditions of this Agreement on behalf of a company or other legal entity represents and warrants that the individual has the authority to enter into this Agreement on behalf of the company or other legal entity. </p>
+<p>3.    TERMS. </p>
+<p>3.1. You agree not to assert against Yahoo!, any other DomainKeys Developer or any of their respective licensees under Section 3.4, a patent infringement claim based on the manufacture, use, sale, offer for sale and/or importation of any of the specific portions of a hardware or software implementation expressly required to be compliant with the Specifications for the sole purpose of implementing a sender verification solution in connection with e-mail (&quot;Licensed Code IP Claim&quot;).</p>
+<p>3.2. To indicate your assent to the terms and conditions of this Agreement and in order to obtain a license to use, reproduce, modify, publicly display, publicly perform, distribute, and sublicense Licensed Code, You must:</p>
+<p>(a) include, attach or preserve the following prominently displayed statement in the Licensed Code: &quot;This code incorporates intellectual property owned by Yahoo! and licensed pursuant to the Yahoo! DomainKeys Public License Agreement.&quot;; </p>
+<p>(b) preserve the copyright and other proprietary notices and disclaimers of DomainKeys Developers as they appear in the Licensed Code; and  </p>
+<p>(c) if the Licensed Code developed by You is distributed in source form, You must identify Yourself, in the source code of such Licensed Code, as the originator of any modifications in a manner that reasonably allows subsequent DomainKeys Developers or their licensees to identify the originator of the modifications.</p>
+<p>3.3. You will not use the name of Yahoo! to endorse or promote any products, services, or Licensed Code without specific prior written permission of Yahoo!.  &quot;DomainKeys&quot; is a trademark of Yahoo!.  However, You may state Your Licensed Code is &quot;DomainKeys compliant&quot;, &quot;supports DomainKeys&quot;, or is &quot;DomainKeys-enabled&quot;, without citation to Yahoo!.  You must create Your own product or service names or trademarks for Your Licensed Code and You agree not to use the term &quot;DomainKeys&quot; in or as part of a name or trademark for Your Licensed Code.</p>
+<p>3.4. You may choose to distribute Licensed Code or modifications under this Agreement or a different agreement, provided that:</p>
+<p>(a) a copy of this Agreement or the different agreement is included with each copy of the Licensed Code or modifications along with the following prominently displayed statement: &quot;By using, reproducing, modifying, publicly displaying, publicly performing, distributing, and/or sublicensing this code as permitted, you agree to the terms and conditions of the Yahoo! DomainKeys Public License Agreement or other agreement contained herein.&quot;; and</p>
+<p>(b) if distributed under a different agreement, such different agreement contains terms and conditions that (i) provide no fewer rights, privileges and immunities to DomainKeys Developers than the terms and conditions of this Agreement, including, without limitation, Sections 1.2, 3.1, 3.4, 3.7, 4.1, 4.2, and 4.3, except that You may alter the terms and conditions of Section 1.1 and (ii) apply such terms and conditions to the Licensed Code and/or modifications made by You.</p>
+<p>3.5. You acknowledge that Licensed Code may be subject to U.S. export restriction and other applicable national and international laws.  You agree to comply with all export, re-export, or import restrictions, laws, or regulations. </p>
+<p>3.6. Yahoo!, and only Yahoo!, may, from time to time and at its sole discretion, update or modify the terms of this Agreement.  If Yahoo! makes any such modifications, You may continue under the terms and conditions of this Agreement or agree to the updated or modified terms and conditions.  For the most recent version of this Agreement please contact Yahoo!.</p>
+<p>3.7. This Agreement and the rights hereunder will terminate: <br>
+ (a) automatically without notice from Yahoo!, if You at any time during the term of this Agreement assert any Licensed Code IP Claim against Yahoo!; </p>
+<p>(b) upon written notice from Yahoo!, if You at any time during the term of this Agreement assert any Licensed Code IP Claim against any DomainKeys Developer (other than Yahoo!) or any licensees of any DomainKeys Developer; or </p>
+<p>(c) where (a) or (b) do not apply, automatically without notice from Yahoo!, if You fail to comply with any term(s) of this Agreement and fail to cure such breach within 30 days of You becoming aware of such breach. </p>
+<p>3.8. This Agreement constitutes the entire agreement between the parties with respect to the subject matter hereof.  This Agreement shall be governed by and construed under the laws of the United States and the State of California without giving effect to California conflict of law provisions or to construction provisions favoring either party.  All actions arising out of or relating to this Agreement that involve Yahoo! as a party will be adjudicated exclusively by the Superior Court of the State of California for the County of Santa Clara or the United States District Court for the Northern District of California. </p>
+<p>3.9. In the event that any provision of this Agreement is deemed to be invalid, such invalidity shall not affect the remainder of this Agreement.</p>
+<p>4.    <b>LEGAL DISCLAIMERS. </b></p>
+<p>4.1. <b>THE YAHOO! PATENT CLAIMS, THIS AGREEMENT, LICENSED CODE, THE DOMAINKEYS TRADEMARK, AND THE SPECIFICATIONS ARE PROVIDED ON AN &quot;AS IS&quot; BASIS, WITHOUT REPRESENTATIONS, WARRANTIES OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING, WITHOUT LIMITATION, ANY REPRESENTATIONS, WARRANTIES OR CONDITIONS OF TITLE, NON-INFRINGEMENT, MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE.</b>  You are solely responsible for determining the appropriateness of exercising any rights under this Agreement and using the Specifications, Licensed Code, and the DomainKeys trademark and assume all risks associated in connection therewith, including, but not limited to, the risks and costs of program errors, compliance with applicable laws, damage to or loss of data, programs or equipment, and unavailability or interruption of operations. </p>
+<p>4.2. You expressly acknowledge and agree that no assurances are provided by DomainKeys Developers with respect to the validity of the Yahoo! Patent Claims or that the Specifications, Licensed Code, the DomainKeys trademark or any implementations related to the Specifications, Licensed Code or the DomainKeys trademark do not infringe or misappropriate the patent, trademark or other intellectual property rights of any other entity.  DomainKeys Developers disclaim any liability to You for claims brought by any other person or entity based on infringement or misappropriation of intellectual property rights or otherwise.  As a condition to exercising the rights and licenses granted hereunder, You hereby assume sole responsibility to secure any other intellectual property rights needed. </p>
+<p>4.3. <b>DOMAINKEYS DEVELOPERS SHALL NOT HAVE ANY LIABILITY FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING WITHOUT LIMITATION LOST PROFITS), HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE EXERCISE OF ANY RIGHTS UNDER THIS AGREEMENT, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGES, AND EVEN IF THE REMEDIES PROVIDED FOR IN THIS AGREEMENT FAIL OF THEIR ESSENTIAL PURPOSE.</b></p>
+
+</body>
+</html>
+
diff -Naur netqmail-1.06.org/spawn-filter.9 netqmail-1.06/spawn-filter.9
--- netqmail-1.06.org/spawn-filter.9	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/spawn-filter.9	2022-12-09 22:58:50.000000000 +0530
@@ -0,0 +1,103 @@
+.TH spawn-filter 8
+.SH NAME
+spawn-filter \- Helper for running filters for qmail-local and qmail-remote
+.SH SYNOPSIS
+.B spawn-filter args
+.SH DESCRIPTION
+.B spawn-filter
+is a utility to help qmail run any filter during local or remote delivery. It
+can run any filter which expects to read mess on fd 0 and writes back the message on fd 1.
+The filter can be turned on individually for local and remote mails by defining
+.B QMAILLOCAL
+and
+.B QMAILREMOTE
+environment variables respectively in
+.B qmail-send
+supervise or rc script. If spawn-filter is invoked as qmail-local, it executes the
+original
+.B qmail-local
+after runing the mail through the filter. If spawn-filter is invoked as qmail-remote, it
+executes the original
+.B qmail-remote
+after running the mail through the filter. Hence QMAILLOCAL should be set as QMAILHOME/bin/spawn-filter
+for filtering local mails and QMAILREMOTE as QMAILHOME/bin/spawn-filter for filtering
+remote mails.
+
+Filters can be run by setting the environment variable
+.B FILTERARGS
+or by using a control file
+.BR filterargs.
+The environment variable overrides the control file.
+.B spawn-filter
+uses /bin/sh to run the filter (with arguments) specified by the FILTERARGS environment variable or the control file
+.BR filterargs .
+The environment variable FILTERARGS apply to both local and remote mails. For individual domain level control,
+it is best to set using the control file filterargs.
+
+.TP 5
+.I filterargs
+The format of this file is of the form
+.B domain:args
+for both local and remote mails.
+.B domain:remote:args
+for remote mails and
+.B domain:local:args
+for local mails.
+
+.EX
+indimail.org:remote:QMAILHOME/bin/dk-filter
+.EE
+
+.TP 0
+The sequence in which the filter program is run is given below
+
+.TP 5
+1. create two pipes and fork
+.TP 5
+2. dup write end of the first pipe to descriptor 1, dup write end of the second pipe to descriptor 2 in the child and exec the filter program
+.TP 5
+3. dup read end of the pipe to descriptor 0 in parent and exec qmail-local for local mails and qmail-remote for remote mails.
+.TP 5
+4. Wait for filter to exit and read read end of second pipe for any error messages.
+.TP 5
+5. Report success or failure
+.TP 0
+
+This gives the ability for the any filter program to read the mail message from descriptor 0 before
+passing it to qmail-local/qmail-remote through the pipe.
+
+.B spawn-filter
+will attempt to make the descriptor 0 seekable if the environment variable MAKE_SEEKABLE
+is defined. This may be necessary for certain filter programs which could do lseek().
+
+.B spawn-filter
+sets the environment variable
+.B DOMAIN
+to the recipient domain. This can be conveniently used in programs/scripts which get invoked by
+setting
+.B FILTERARGS
+environment variable or by rules in the control file
+.BR filterargs .
+
+.SH "EXIT CODES"
+.B spawn-filter
+exits 111 for any error or if it is not able to exec
+QMAILHOME/bin/qmail-local (for local mails) or
+QMAILHOME/bin/qmail-remote (for remote mails).
+
+.SH "SEE ALSO"
+qmail-lspawn(8),
+qmail-rspawn(8),
+qmail-local(8),
+qmail-remote(8),
+qmail-smtpd(8),
+qmail-control(5),
+qmail-queue(8)
+
+.SH "AUTHORS"
+
+Manvendra Bhangui.
+.SH PROBLEMS
+Problems with
+.B spawn-filter
+should be forwarded to "Manvendra Bhangui" <mbhangui@gmail.com>
diff -Naur netqmail-1.06.org/spawn-filter.c netqmail-1.06/spawn-filter.c
--- netqmail-1.06.org/spawn-filter.c	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/spawn-filter.c	2023-02-01 17:05:51.000000000 +0530
@@ -0,0 +1,444 @@
+/*
+ * netqmail-version without spam filter
+ *
+ * $Log: spawn-filter.c,v $
+ * Revision 1.41  2009-04-03 11:42:48+05:30  Cprogrammer
+ * create pipe for error messages
+ *
+ * Revision 1.40  2009-04-02 15:17:54+05:30  Cprogrammer
+ * unset QMAILLOCAL in qmail-remote and unset QMAILREMOTE in qmail-local
+ *
+ * Revision 1.39  2008-06-12 08:40:55+05:30  Cprogrammer
+ * added rulesfile argument
+ *
+ * Revision 1.38  2008-05-25 17:16:43+05:30  Cprogrammer
+ * made message more readable by adding a blank space
+ *
+ * Revision 1.37  2007-12-20 13:51:54+05:30  Cprogrammer
+ * avoid loops with FILTERARGS, SPAMFILTERARGS
+ * removed compiler warning
+ *
+ * Revision 1.36  2006-06-07 14:11:28+05:30  Cprogrammer
+ * added SPAMEXT, SPAMHOST, SPAMSENDER, QQEH environment variable
+ * unset FILTERARGS before calling filters
+ *
+ * Revision 1.35  2006-01-22 10:14:45+05:30  Cprogrammer
+ * BUG fix for spam mails wrongly getting blackholed
+ *
+ * Revision 1.34  2005-08-23 17:36:48+05:30  Cprogrammer
+ * gcc 4 compliance
+ * delete sender in spam notification
+ *
+ * Revision 1.33  2005-04-02 19:07:47+05:30  Cprogrammer
+ * use internal wildmat version
+ *
+ * Revision 1.32  2004-11-22 19:50:53+05:30  Cprogrammer
+ * include regex.h after sys/types.h to avoid compilation prob on RH 7.3
+ *
+ * Revision 1.31  2004-10-22 20:30:35+05:30  Cprogrammer
+ * added RCS id
+ *
+ * Revision 1.30  2004-10-21 21:56:21+05:30  Cprogrammer
+ * change for two additional arguments to strerr_die()
+ *
+ * Revision 1.29  2004-10-11 14:06:14+05:30  Cprogrammer
+ * use control_readulong instead of control_readint
+ *
+ * Revision 1.28  2004-09-22 23:14:20+05:30  Cprogrammer
+ * replaced atoi() with scan_int()
+ *
+ * Revision 1.27  2004-09-08 10:54:49+05:30  Cprogrammer
+ * incorrect exit code in report() function for remote
+ * mails. Caused qmail-rspawn to report "Unable to run qmail-remote"
+ *
+ * Revision 1.26  2004-07-17 21:23:31+05:30  Cprogrammer
+ * change qqeh code in qmail-remote
+ *
+ * Revision 1.25  2004-07-15 23:40:46+05:30  Cprogrammer
+ * fixed compilation warning
+ *
+ * Revision 1.24  2004-07-02 16:15:25+05:30  Cprogrammer
+ * override control files rejectspam, spamredirect by
+ * environment variables REJECTSPAM and SPAMREDIRECT
+ * allow patterns in domain specification in the control files
+ * spamfilterargs, filterargs, rejectspam and spamredirect
+ *
+ * Revision 1.23  2004-06-03 22:58:34+05:30  Cprogrammer
+ * fixed compilation problem without indimail
+ *
+ * Revision 1.22  2004-05-23 22:18:17+05:30  Cprogrammer
+ * added envrules filename as argument
+ *
+ * Revision 1.21  2004-05-19 23:15:07+05:30  Cprogrammer
+ * added comments
+ *
+ * Revision 1.20  2004-05-12 22:37:47+05:30  Cprogrammer
+ * added check DATALIMIT check
+ *
+ * Revision 1.19  2004-05-03 22:17:36+05:30  Cprogrammer
+ * use QUEUE_BASE instead of auto_qmail
+ *
+ * Revision 1.18  2004-02-13 14:51:24+05:30  Cprogrammer
+ * added envrules
+ *
+ * Revision 1.17  2004-01-20 06:56:56+05:30  Cprogrammer
+ * unset FILTERARGS for notifications
+ *
+ * Revision 1.16  2004-01-20 01:52:08+05:30  Cprogrammer
+ * report string length corrected
+ *
+ * Revision 1.15  2004-01-10 09:44:36+05:30  Cprogrammer
+ * added comment for exit codes of bogofilter
+ *
+ * Revision 1.14  2004-01-08 00:32:49+05:30  Cprogrammer
+ * use TMPDIR environment variable for temporary directory
+ * send spam reports to central spam logger
+ *
+ * Revision 1.13  2003-12-30 00:44:42+05:30  Cprogrammer
+ * set argv[0] from spamfilterprog
+ *
+ * Revision 1.12  2003-12-22 18:34:25+05:30  Cprogrammer
+ * replaced spfcheck() with address_match()
+ *
+ * Revision 1.11  2003-12-20 01:35:06+05:30  Cprogrammer
+ * added wait_pid to prevent zombies
+ *
+ * Revision 1.10  2003-12-17 23:33:39+05:30  Cprogrammer
+ * improved logic for getting remote/local tokens
+ *
+ * Revision 1.9  2003-12-16 10:38:24+05:30  Cprogrammer
+ * fixed incorrect address being returned if filterargs contained local: or
+ * remote: directives
+ *
+ * Revision 1.8  2003-12-15 20:46:19+05:30  Cprogrammer
+ * added case 100 to bounce mail
+ *
+ * Revision 1.7  2003-12-15 13:51:44+05:30  Cprogrammer
+ * code to run additional filters using /bin/sh
+ *
+ * Revision 1.6  2003-12-14 11:36:18+05:30  Cprogrammer
+ * added option to blackhole spammers
+ *
+ * Revision 1.5  2003-12-13 21:08:46+05:30  Cprogrammer
+ * extensive rewrite
+ * common report() function for local/remote mails to report errors
+ *
+ * Revision 1.4  2003-12-12 20:20:55+05:30  Cprogrammer
+ * use -a option to prevent using header addresses
+ *
+ * Revision 1.3  2003-12-09 23:37:16+05:30  Cprogrammer
+ * change for spawn-filter to be called as qmail-local or qmail-remote
+ *
+ * Revision 1.2  2003-12-08 23:48:23+05:30  Cprogrammer
+ * new function getDomainToken() to retrieve domain specific values
+ * read rejectspam and spamredirect only if SPAMEXITCODE is set
+ *
+ * Revision 1.1  2003-12-07 13:02:00+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
+#include "fmt.h"
+#include "str.h"
+#include "strerr.h"
+#include "env.h"
+#include "substdio.h"
+#include "subfd.h"
+#include "stralloc.h"
+#include "error.h"
+#include "control.h"
+#include "wait.h"
+#include "qregex.h"
+#include "getDomainToken.h"
+#include "auto_qmail.h"
+#include <regex.h>
+#include <unistd.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <fcntl.h>
+
+#define REGCOMP(X,Y)    regcomp(&X, Y, REG_EXTENDED|REG_ICASE)
+#define REGEXEC(X,Y)    regexec(&X, Y, (size_t) 0, (regmatch_t *) 0, (int) 0)
+
+static int      mkTempFile(int);
+static void     report(int, char *, char *, char *, char *, char *, char *);
+static int      run_mailfilter(char *, char *, char **);
+int             wildmat_internal(char *, char *);
+
+static int      remotE;
+stralloc        sender = { 0 };
+stralloc        recipient = { 0 };
+
+static void
+report(int errCode, char *s1, char *s2, char *s3, char *s4, char *s5, char *s6)
+{
+	if (!remotE) /*- strerr_die does not return */
+		strerr_die(errCode, s1, s2, s3, s4, s5, s6, 0, 0, (struct strerr *) 0);
+	/*- h - hard, s - soft */
+	if (substdio_put(subfdoutsmall, errCode == 111 ? "s" : "h", 1) == -1)
+		_exit(111);
+	if (s1 && substdio_puts(subfdoutsmall, s1) == -1)
+		_exit(111);
+	if (s2 && substdio_puts(subfdoutsmall, s2) == -1)
+		_exit(111);
+	if (s3 && substdio_puts(subfdoutsmall, s3) == -1)
+		_exit(111);
+	if (s4 && substdio_puts(subfdoutsmall, s4) == -1)
+		_exit(111);
+	if (s5 && substdio_puts(subfdoutsmall, s5) == -1)
+		_exit(111);
+	if (s6 && substdio_puts(subfdoutsmall, s6) == -1)
+		_exit(111);
+	if (substdio_put(subfdoutsmall, "\0", 1) == -1)
+		_exit(111);
+	if (substdio_puts(subfdoutsmall, 
+		errCode == 111 ?  "Zspawn-filter said: Message deferred" : "DGiving up on spawn-filter\n") == -1)
+		_exit(111);
+	if (substdio_put(subfdoutsmall, "\0", 1) == -1)
+		_exit(111);
+	substdio_flush(subfdoutsmall);
+	/*- For qmail-rspawn to stop complaining unable to run qmail-remote */
+	_exit(0);
+}
+
+void
+set_environ(char *host, char *sender, char *recipient)
+{
+	if (!env_put2("DOMAIN", host)) 
+		report(111, "spawn-filter: out of mem: ", error_str(errno), ". (#4.3.0)", 0, 0, 0);
+	if (!env_put2("_SENDER", sender))
+		report(111, "spawn-filter: out of mem: ", error_str(errno), ". (#4.3.0)", 0, 0, 0);
+	if (!env_put2("_RECIPIENT", recipient))
+		report(111, "spawn-filter: out of mem: ", error_str(errno), ". (#4.3.0)", 0, 0, 0);
+	return;
+}
+
+static int
+run_mailfilter(char *domain, char *mailprog, char **argv)
+{
+	char            strnum[FMT_ULONG];
+	pid_t           filt_pid;
+	int             pipefd[2], pipefe[2];
+	int             wstat, filt_exitcode, len = 0;
+	char           *filterargs;
+	static stralloc filterdefs = { 0 };
+	static char     errstr[1024];
+	char            inbuf[1024];
+	char            ch;
+	static substdio errbuf;
+
+	if (!(filterargs = env_get("FILTERARGS")))
+	{
+		if (control_readfile(&filterdefs, "control/filterargs", 0) == -1)
+			report(111, "spawn-filter: Unable to read filterargs: ", error_str(errno), ". (#4.3.0)", 0, 0, 0);
+		filterargs = getDomainToken(domain, &filterdefs);
+	}
+	if (!filterargs)
+	{
+		execv(mailprog, argv);
+		report(111, "spawn-filter: could not exec ", mailprog, ": ", error_str(errno), ". (#4.3.0)", 0);
+		_exit(111); /*- To make compiler happy */
+	}
+	if (pipe(pipefd) == -1)
+		report(111, "spawn-filter: Trouble creating pipes: ", error_str(errno), ". (#4.3.0)", 0, 0, 0);
+	if (pipe(pipefe) == -1)
+		report(111, "spawn-filter: Trouble creating pipes: ", error_str(errno), ". (#4.3.0)", 0, 0, 0);
+	switch ((filt_pid = fork()))
+	{
+	case -1:
+		report(111, "spawn-filter: Trouble creating child filter: ", error_str(errno), ". (#4.3.0)", 0, 0, 0);
+	case 0: /*- Filter Program */
+		set_environ(domain, sender.s, recipient.s);
+		/*- Mail content read from fd 0 */
+		if (mkTempFile(0))
+			report(111, "spawn-filter: lseek error: ", error_str(errno), ". (#4.3.0)", 0, 0, 0);
+		/*- stdout will go here */
+		if (dup2(pipefd[1], 1) == -1 || close(pipefd[0]) == -1)
+			report(111, "spawn-filter: dup2 error: ", error_str(errno), ". (#4.3.0)", 0, 0, 0);
+		if (pipefd[1] != 1)
+			close(pipefd[1]);
+		/*- stderr will go here */
+		if (dup2(pipefe[1], 2) == -1 || close(pipefe[0]) == -1)
+			report(111, "spawn-filter: dup2 error: ", error_str(errno), ". (#4.3.0)", 0, 0, 0);
+		if (pipefe[1] != 2)
+			close(pipefe[1]);
+		/*- Avoid loop if program(s) defined by FILTERARGS call qmail-inject, etc */
+		if (!env_unset("FILTERARGS") || !env_unset("SPAMFILTER"))
+			report(111, "spawn-filter: out of mem: ", error_str(errno), ". (#4.3.0)", 0, 0, 0);
+		execl("/bin/sh", "/bin/sh", "-c", filterargs, (char *) 0);
+		report(111, "spawn-filter: could not exec /bin/sh: ",  filterargs, ": ", error_str(errno), ". (#4.3.0)", 0);
+	default:
+		close(pipefe[1]);
+		close(pipefd[1]);
+		if (dup2(pipefd[0], 0))
+		{
+			close(pipefd[0]);
+			close(pipefe[0]);
+			wait_pid(&wstat, filt_pid);
+			report(111, "spawn-filter: dup2 error: ", error_str(errno), ". (#4.3.0)", 0, 0, 0);
+		}
+		if (pipefd[0] != 0)
+			close(pipefd[0]);
+		if (mkTempFile(0))
+		{
+			close(0);
+			close(pipefe[0]);
+			wait_pid(&wstat, filt_pid);
+			report(111, "spawn-filter: lseek error: ", error_str(errno), ". (#4.3.0)", 0, 0, 0);
+		}
+		break;
+	}
+	/*- Process message if exit code is 0, bounce if 100 */
+	if (wait_pid(&wstat, filt_pid) != filt_pid)
+	{
+		close(0);
+		close(pipefe[0]);
+		report(111, "spawn-filter: waitpid surprise: ", error_str(errno), ". (#4.3.0)", 0, 0, 0);
+	}
+	if (wait_crashed(wstat))
+	{
+		close(0);
+		close(pipefe[0]);
+		report(111, "spawn-filter: filter crashed: ", error_str(errno), ". (#4.3.0)", 0, 0, 0);
+	}
+	switch (filt_exitcode = wait_exitcode(wstat))
+	{
+	case 0:
+		execv(mailprog, argv);
+		report(111, "spawn-filter: could not exec ", mailprog, ": ", error_str(errno), ". (#4.3.0)", 0);
+	case 100:
+		report(100, "Mail Rejected (#5.7.1)", 0, 0, 0, 0, 0);
+	default:
+		substdio_fdbuf(&errbuf, read, pipefe[0], inbuf, sizeof(inbuf));
+		for (len = 0; substdio_bget(&errbuf, &ch, 1) && len < (sizeof(errstr) - 1); len++)
+			errstr[len] = ch;
+		errstr[len] = 0;
+		strnum[fmt_ulong(strnum, filt_exitcode)] = 0;
+		report(111, filterargs, ": (spawn-filter) exit code: ", strnum, *errstr ? ": " : 0, *errstr ? errstr : 0, ". (#4.3.0)");
+	}
+	/*- Not reached */
+	return(111);
+}
+
+int
+mkTempFile(int seekfd)
+{
+	char            inbuf[2048], outbuf[2048], strnum[FMT_ULONG];
+	char           *tmpdir;
+	static stralloc tmpFile = {0};
+	struct substdio _ssin;
+	struct substdio _ssout;
+	int             fd;
+
+	if (lseek(seekfd, 0, SEEK_SET) == 0)
+		return (0);
+	if (errno == EBADF)
+	{
+		strnum[fmt_ulong(strnum, seekfd)] = 0;
+		report(111, "spawn-filter: fd ", strnum, ": ", error_str(errno), ". (#4.3.0)", 0);
+	}
+	if (!(tmpdir = env_get("TMPDIR")))
+		tmpdir = "/tmp";
+	if (!stralloc_copys(&tmpFile, tmpdir))
+		report(111, "spawn-filter: out of mem: ", error_str(errno), ". (#4.3.0)", 0, 0, 0);
+	if (!stralloc_cats(&tmpFile, "/qmailFilterXXX"))
+		report(111, "spawn-filter: out of mem: ", error_str(errno), ". (#4.3.0)", 0, 0, 0);
+	if (!stralloc_catb(&tmpFile, strnum, fmt_ulong(strnum, (unsigned long) getpid())))
+		report(111, "spawn-filter: out of mem: ", error_str(errno), ". (#4.3.0)", 0, 0, 0);
+	if (!stralloc_0(&tmpFile))
+		report(111, "spawn-filter: out of mem: ", error_str(errno), ". (#4.3.0)", 0, 0, 0);
+	if ((fd = open(tmpFile.s, O_RDWR | O_EXCL | O_CREAT, 0600)) == -1)
+		report(111, "spawn-filter: ", tmpFile.s, ": ", error_str(errno), ". (#4.3.0)", 0);
+	unlink(tmpFile.s);
+	substdio_fdbuf(&_ssout, write, fd, outbuf, sizeof(outbuf));
+	substdio_fdbuf(&_ssin, read, seekfd, inbuf, sizeof(inbuf));
+	switch (substdio_copy(&_ssout, &_ssin))
+	{
+	case -2: /*- read error */
+		report(111, "spawn-filter: read error: ", error_str(errno), ". (#4.3.0)", 0, 0, 0);
+	case -3: /*- write error */
+		report(111, "spawn-filter: write error: ", error_str(errno), ". (#4.3.0)", 0, 0, 0);
+	}
+	if (substdio_flush(&_ssout) == -1)
+		report(111, "spawn-filter: write error: ", error_str(errno), ". (#4.3.0)", 0, 0, 0);
+	if (dup2(fd, seekfd) == -1)
+		report(111, "spawn-filter: dup2 error: ", error_str(errno), ". (#4.3.0)", 0, 0, 0);
+	if (lseek(seekfd, 0, SEEK_SET) != 0)
+		report(111, "spawn-filter: lseek: ", error_str(errno), ". (#4.3.0)", 0, 0, 0);
+	return (0);
+}
+
+int
+main(int argc, char **argv)
+{
+	char           *ptr, *mailprog, *domain, *ext;
+	int             len;
+
+	len = str_len(argv[0]);
+	for (ptr = argv[0] + len;*ptr != '/' && ptr != argv[0];ptr--);
+	if (*ptr && *ptr == '/')
+		ptr++;
+	ptr += 6;
+	if (*ptr == 'l') /*- qmail-local Filter */
+	{
+		mailprog = "bin/qmail-local";
+		ext = argv[6];
+		domain = argv[7];
+		remotE = 0;
+		if (!env_unset("QMAILREMOTE"))
+			report(111, "spawn-filter: out of mem: ", error_str(errno), ". (#4.3.0)", 0, 0, 0);
+		/*- sender */
+		if (!stralloc_copys(&sender, argv[8]))
+			report(111, "spawn-filter: out of mem: ", error_str(errno), ". (#4.3.0)", 0, 0, 0);
+		if (!stralloc_0(&sender))
+			report(111, "spawn-filter: out of mem: ", error_str(errno), ". (#4.3.0)", 0, 0, 0);
+		/*- recipient */
+		if (*ext) { /*- EXT */
+			if (!stralloc_copys(&recipient, ext))
+				report(111, "spawn-filter: out of mem: ", error_str(errno), ". (#4.3.0)", 0, 0, 0);
+		} else /*- user */
+		if (!stralloc_copys(&recipient, argv[2]))
+			report(111, "spawn-filter: out of mem: ", error_str(errno), ". (#4.3.0)", 0, 0, 0);
+		if (!stralloc_cats(&recipient, "@"))
+			report(111, "spawn-filter: out of mem: ", error_str(errno), ". (#4.3.0)", 0, 0, 0);
+		if (!stralloc_cats(&recipient, domain))
+			report(111, "spawn-filter: out of mem: ", error_str(errno), ". (#4.3.0)", 0, 0, 0);
+		if (!stralloc_0(&recipient))
+			report(111, "spawn-filter: out of mem: ", error_str(errno), ". (#4.3.0)", 0, 0, 0);
+	} else
+	if (*ptr == 'r') /*- qmail-remote Filter */
+	{
+		mailprog = "bin/qmail-remote";
+		domain = argv[1];
+		remotE = 1;
+		if (!env_unset("QMAILLOCAL"))
+			report(111, "spawn-filter: out of mem: ", error_str(errno), ". (#4.3.0)", 0, 0, 0);
+		/*- sender */
+		if (!stralloc_copys(&sender, argv[2]))
+			report(111, "spawn-filter: out of mem: ", error_str(errno), ". (#4.3.0)", 0, 0, 0);
+		if (!stralloc_0(&sender))
+			report(111, "spawn-filter: out of mem: ", error_str(errno), ". (#4.3.0)", 0, 0, 0);
+		/*- recipient */
+		if (!stralloc_copys(&recipient, argv[3]))
+			report(111, "spawn-filter: out of mem: ", error_str(errno), ". (#4.3.0)", 0, 0, 0);
+		if (!stralloc_0(&recipient))
+			report(111, "spawn-filter: out of mem: ", error_str(errno), ". (#4.3.0)", 0, 0, 0);
+	} else
+	{
+		report(111, "spawn-filter: Incorrect usage. ", argv[0], " (#4.3.0)", 0, 0, 0);
+		_exit(111);
+	}
+	if (chdir(auto_qmail) == -1)
+		report(111, "spawn-filter: Unable to switch to ", auto_qmail, ": ", error_str(errno), ". (#4.3.0)", 0);
+	run_mailfilter(domain, mailprog, argv);
+	report(111, "spawn-filter: could not exec ", mailprog, ": ", error_str(errno), ". (#4.3.0)", 0);
+	/*- Not reached */
+	return(0);
+}
+
+void
+getversion_qmail_spawn_filter_c()
+{
+	static char    *x = "$Id: spawn-filter.c,v 1.41 2009-04-03 11:42:48+05:30 Cprogrammer Stab mbhangui $";
+
+	x++;
+}
diff -Naur netqmail-1.06.org/str_cpyb.c netqmail-1.06/str_cpyb.c
--- netqmail-1.06.org/str_cpyb.c	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/str_cpyb.c	2022-12-09 22:58:50.000000000 +0530
@@ -0,0 +1,53 @@
+/*
+ * $Log: str_cpyb.c,v $
+ * Revision 1.2  2004-10-22 20:30:54+05:30  Cprogrammer
+ * added RCS id
+ *
+ * Revision 1.1  2004-08-15 19:52:35+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
+#include "str.h"
+
+unsigned int
+str_copyb(s, t, max)
+	register char  *s;
+	register char  *t;
+	unsigned int    max;
+{
+	register int    len;
+
+	len = 0;
+	while (max-- > 0)
+	{
+		if (!(*s = *t))
+			return len;
+		++s;
+		++t;
+		++len;
+		if (!(*s = *t))
+			return len;
+		++s;
+		++t;
+		++len;
+		if (!(*s = *t))
+			return len;
+		++s;
+		++t;
+		++len;
+		if (!(*s = *t))
+			return len;
+		++s;
+		++t;
+		++len;
+	}
+	return len;
+}
+
+void
+getversion_str_cpyb_c()
+{
+	static char    *x = "$Id: str_cpyb.c,v 1.2 2004-10-22 20:30:54+05:30 Cprogrammer Stab mbhangui $";
+
+	x++;
+}
diff -Naur netqmail-1.06.org/str_cspn.c netqmail-1.06/str_cspn.c
--- netqmail-1.06.org/str_cspn.c	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/str_cspn.c	2022-12-09 22:58:50.000000000 +0530
@@ -0,0 +1,40 @@
+/*
+ * $Log: str_cspn.c,v $
+ * Revision 1.1  2011-07-12 20:42:00+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
+#include "str.h"
+/*
+ * Span the complement of string s2.
+ */
+size_t
+str_cspn(s1, s2)
+	const char *s1;
+	register const char *s2;
+{
+	register const char *p, *spanp;
+	register char c, sc;
+
+	/*
+	 * Stop as soon as we find any character from s2.  Note that there
+	 * must be a NUL in s2; it suffices to stop when we find that, too.
+	 */
+	for (p = s1;;) {
+		c = *p++;
+		spanp = s2;
+		do {
+			if ((sc = *spanp++) == c)
+				return (p - 1 - s1);
+		} while (sc != 0);
+	}
+	/* NOTREACHED */
+}
+
+void
+getversion_str_cspn_c()
+{
+	static char    *x = "$Id: str_cspn.c,v 1.1 2011-07-12 20:42:00+05:30 Cprogrammer Exp mbhangui $";
+
+	x++;
+}
diff -Naur netqmail-1.06.org/str.h netqmail-1.06/str.h
--- netqmail-1.06.org/str.h	1998-06-15 16:23:16.000000000 +0530
+++ netqmail-1.06/str.h	2022-12-09 22:58:50.000000000 +0530
@@ -2,12 +2,15 @@
 #define STR_H
 
 extern unsigned int str_copy();
+extern unsigned int str_copyb();
 extern int str_diff();
 extern int str_diffn();
 extern unsigned int str_len();
 extern unsigned int str_chr();
 extern unsigned int str_rchr();
 extern int str_start();
+#include <sys/types.h>
+extern size_t str_cspn();
 
 #define str_equal(s,t) (!str_diff((s),(t)))
 
diff -Naur netqmail-1.06.org/surblfilter.9 netqmail-1.06/surblfilter.9
--- netqmail-1.06.org/surblfilter.9	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/surblfilter.9	2022-12-09 22:58:50.000000000 +0530
@@ -0,0 +1,82 @@
+.TH surblfilter 8
+.SH NAME
+surblfilter \- qmail SURBL blocklist interface
+.SH SYNOPSIS
+.B surblfilter
+[
+.B \-v
+]
+[
+.B \-c
+]
+[
+.B \-t
+]
+.SH DESCRIPTION
+\fBSURBL\fRs are lists of web sites that have appeared in unsolicited messages. Unlike most lists,
+SURBLs are not lists of message senders.
+
+Web sites seen in unsolicited messages tend to be more stable than the rapidly changing botnet
+IP addresses used to send the vast majority of them. Sender lists like zen.spamhaus.org can be
+used in a first stage filter to help identify 80% to 90% of unsolicited messages. SURBLs can
+help find about 75% of the otherwise difficult, remaining unsolicited messages in a second
+stage filter. Used together with sender lists, SURBLs have proven to be a highly-effective way
+to detect 95% of unsolicited messages.
+
+\fBsurblfilter\fR reads an rfc822 email on stdin, extracts URL and checks them against SURBL.
+\fBsurblfilter\fR can be used as a filter using \fBqmail-qfilter(1)\fR. It can also be used
+as a qmail-queue(8) frontend by setting QMAILQUEUE environment variable to a wrapper
+QMAILHOME/bin/surblqueue. You can define \fBSURBLQUEUE\fR environment variable to make
+\fBsurblqueue\fR execute something other than \fBqmail-queue\fR(8).
+
+\fBsurblfilter\fR uses \fBQMAILRCPTS\fR environment variable to get the recipient list. You can
+whitelist recipients by having the email addresses in \fIsurblrcpt\fR control file. You can
+change the name of this control file by setting \fBSURBLRCPT\fR environment variable.
+
+.PP
+\fBsurblfilter\fR uses the control file \fIsurbldomainwhite\fR to whitelist a domain.
+
+.PP
+The default SURBL list that is used is \fBmulti.surbl.org\fR. You can use a different list
+by setting the \fIsurbldomain\fR control file.
+
+.PP
+\fBsurblfilter\fR caches results in @controldir@/cache directory. The filename of files in this
+directory represents the domain. If a file has permission 0600, it means that the domain was
+blacklisted. The entries are cached for a default of 300 seconds. You can change this by
+setting \fBCACHELIFETIME\fR environment variable or setting this value in \fBcacheliftime\fR
+control file. The cache directory should be owned by the uid of the running qmail-smtpd(8).
+
+\fBsurblfilter\fR removes all leading host names, subdomains, www., randomized subdomains, etc. In
+order to determine the level of domain check, it uses the control files \fBlevel3-tlds\fR and
+\fBlevel2-tlds\fR. For any domain found in \fBlevel3-tlds\fR, it checks the domain at level4. For any
+domain found in \fBlevel2-tlds\fR, it checks the domain at level3. For all domains not found in
+these two control files, it checks the domain at level2. Please look at http://www.surbl.org/guidelines
+
+for more details.
+
+.SH OPTIONS
+.PP
+.TP
+\fB-v\fR
+Use debug mode
+
+.TP
+\fB-c\fR
+Do not cache results
+
+.TP
+\fB-t\fR
+Do dns text query to get the reason. This option will slow \fBsurblfilter\fR. Remember that
+last octet of the IP address obtained for the domain gives you the reason for the block
+
+.SH RETURN VALUE
+\fBsurbfilter\fR returns 88 if the domain is blocked and prints the reason on standard error.
+This allows for qmail-smtpd(8) to print a permanent error during a SMTP session.
+It returns 111 for all temporary errors. It returns 0 if the message does not contain any
+domain blocked by SURBL
+
+.SH "SEE ALSO"
+qmail-smtpd(8),
+qmail-queue(8),
+qmail-qfilter(1)
diff -Naur netqmail-1.06.org/surblfilter.c netqmail-1.06/surblfilter.c
--- netqmail-1.06.org/surblfilter.c	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/surblfilter.c	2022-12-09 22:58:50.000000000 +0530
@@ -0,0 +1,882 @@
+/*
+ * $Log: surblfilter.c,v $
+ * Revision 1.3  2011-07-13 22:11:13+05:30  Cprogrammer
+ * skip surblrcpt if QMAILRCPTS is not defined
+ *
+ * Revision 1.2  2011-07-13 22:02:13+05:30  Cprogrammer
+ * added surblrcpt functionality
+ *
+ * Revision 1.1  2011-07-13 20:56:34+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
+#include <unistd.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <ctype.h>
+#include <time.h>
+#include <sys/stat.h>
+
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#ifdef DARWIN
+#include <nameser8_compat.h>
+#endif
+#include <arpa/nameser.h>
+#include <resolv.h>
+#include <netdb.h>
+
+#include "alloc.h"
+#include "sgetopt.h"
+#include "error.h"
+#include "scan.h"
+#include "str.h"
+#include "case.h"
+#include "constmap.h"
+#include "auto_qmail.h"
+#include "stralloc.h"
+#include "env.h"
+#include "control.h"
+#include "strerr.h"
+#include "substdio.h"
+#include "getln.h"
+#include "byte.h"
+#include "dns.h"
+#include "ip.h"
+#include "ipalloc.h"
+#include "mess822.h"
+#include "base64.h"
+
+#define FATAL "surblfilter: fatal: "
+
+char           *dns_text(char *);
+
+stralloc        line = { 0 };
+int             debug = 0, do_text = 0, do_cache = 1;
+static int      cachelifetime = 300;
+stralloc        whitelist = { 0 };
+stralloc        surbldomain = { 0 };
+
+/*- SURBL: RCPT whitelist. */
+stralloc        srw = { 0 };
+int             srwok = 0;
+struct constmap mapsrw;
+
+/*- 2 level tld */
+stralloc        l2 = { 0 };
+int             l2ok = 0;
+struct constmap mapl2;
+/*- 3 level tld */
+stralloc        l3 = { 0 };
+int             l3ok = 0;
+struct constmap mapl3;
+
+static char     ssinbuf[1024];
+static substdio ssin = SUBSTDIO_FDBUF(read, 0, ssinbuf, sizeof ssinbuf);
+static char     ssoutbuf[512];
+static substdio ssout = SUBSTDIO_FDBUF(write, 1, ssoutbuf, sizeof ssoutbuf);
+static char     sserrbuf[512];
+static substdio sserr = SUBSTDIO_FDBUF(write, 2, sserrbuf, sizeof(sserrbuf));
+
+void
+out(char *str)
+{
+	if (!str || !*str)
+		return;
+	if (substdio_puts(&ssout, str) == -1)
+		strerr_die2sys(111, FATAL, "write: ");
+	return;
+}
+
+void
+print_debug(char *arg1, char *arg2, char *arg3)
+{
+	if (!debug)
+		return;
+	if (arg1 && substdio_puts(&sserr, arg1) == -1)
+		_exit(1);
+	if (arg2 && substdio_puts(&sserr, arg2) == -1)
+		_exit(1);
+	if (arg3 && substdio_puts(&sserr, arg3) == -1)
+		_exit(1);
+	if ((arg1 || arg2 || arg3) && substdio_puts(&sserr, "\n"))
+		_exit(1);
+	if (substdio_flush(&sserr) == -1)
+		_exit(1);
+}
+
+void
+die_write()
+{
+	strerr_die2sys(111, FATAL, "write: ");
+	return;
+}
+
+void
+flush()
+{
+	if (substdio_flush(&ssout) == -1)
+		strerr_die2sys(111, FATAL, "write: ");
+	return;
+}
+
+void
+logerr(char *s)
+{
+	if (substdio_puts(&sserr, s) == -1)
+		_exit(1);
+}
+
+void
+logerrf(char *s)
+{
+	if (substdio_puts(&sserr, s) == -1)
+		_exit(1);
+	if (substdio_flush(&sserr) == -1)
+		_exit(1);
+}
+
+void
+my_error(char *s1, char *s2, int exit_val)
+{
+	logerr(s1);
+	if (s2) {
+		logerr(": ");
+		logerr(s2);
+	}
+	if (exit_val > 0) {
+		logerr(": ");
+		logerr(error_str(errno));
+	}
+	logerrf("\n");
+	_exit(exit_val > 0 ? exit_val : 0 - exit_val);
+}
+
+void
+die_nomem()
+{
+	substdio_flush(&ssout);
+	substdio_puts(&sserr, "surblfilter: out of memory\n");
+	substdio_flush(&sserr);
+	_exit(1);
+}
+
+void
+die_soft()
+{
+	substdio_flush(&ssout);
+	substdio_puts(&sserr, "surblfilter: DNS temporary failure\n");
+	substdio_flush(&sserr);
+	_exit(1);
+}
+
+void
+die_hard()
+{
+	substdio_flush(&ssout);
+	substdio_puts(&sserr, "surblfilter: DNS permanent failure\n");
+	substdio_flush(&sserr);
+	_exit(1);
+}
+
+void
+die_control()
+{
+	substdio_flush(&ssout);
+	substdio_puts(&sserr, "surblfilter: unable to read controls\n");
+	substdio_flush(&sserr);
+	_exit(1);
+}
+
+static unsigned short
+getshort(unsigned char *cp)
+{
+	return (cp[0] << 8) | cp[1];
+}
+
+static char *
+strdup(const char *str)
+{
+	size_t siz;
+	char *copy;
+
+	siz = str_len((char *) str) + 1;
+	if (!(copy = alloc(siz)))
+		return((char *) 0);
+	byte_copy(copy, siz, (char *) str);
+	return(copy);
+}
+
+/*
+ * we always return a null-terminated string which has been malloc'ed.  The string
+ * is always in the tag=value form.  If a temporary or permanent error occurs,
+ * the string will be exactly "e=perm;" or "e=temp;".
+ * Note that it never returns NULL.
+ */
+char           *
+dns_text(char *dn)
+{
+	u_char          response[PACKETSZ + PACKETSZ + 1];	/* response */
+	int             responselen;			/* buffer length */
+	int             rc;						/* misc variables */
+	int             ancount, qdcount;		/* answer count and query count */
+	u_short         type, rdlength;			/* fields of records returned */
+	u_char         *eom, *cp;
+	u_char          buf[PACKETSZ + PACKETSZ + 1];		/* we're storing a TXT record here, not just a DNAME */
+	u_char         *bufptr;
+
+	for (rc = 0, responselen = PACKETSZ;rc < 2;rc++) {
+		if ((responselen = res_query(dn, C_IN, T_TXT, response, responselen)) < 0) {
+			if (h_errno == TRY_AGAIN)
+				return strdup("e=temp;");
+			else
+				return strdup("e=perm;");
+		}
+		if (responselen <= PACKETSZ)
+			break;
+		else
+		if (responselen >= (2 * PACKETSZ))
+			return strdup("e=perm;");
+	}
+	qdcount = getshort(response + 4);	/* http://crynwr.com/rfc1035/rfc1035.html#4.1.1. */
+	ancount = getshort(response + 6);
+	eom = response + responselen;
+	cp = response + HFIXEDSZ;
+	while (qdcount-- > 0 && cp < eom) {
+		rc = dn_expand(response, eom, cp, (char *) buf, MAXDNAME);
+		if (rc < 0)
+			return strdup("e=perm;");
+		cp += rc + QFIXEDSZ;
+	}
+	while (ancount-- > 0 && cp < eom) {
+		if ((rc = dn_expand(response, eom, cp, (char *) buf, MAXDNAME)) < 0)
+			return strdup("e=perm;");
+		cp += rc;
+		if (cp + RRFIXEDSZ >= eom)
+			return strdup("e=perm;");
+		type = getshort(cp + 0);	/* http://crynwr.com/rfc1035/rfc1035.html#4.1.3. */
+		rdlength = getshort(cp + 8);
+		cp += RRFIXEDSZ;
+		if (type != T_TXT) {
+			cp += rdlength;
+			continue;
+		}
+		bufptr = buf;
+		while (rdlength && cp < eom) {
+			unsigned int    cnt;
+
+			cnt = *cp++;		/* http://crynwr.com/rfc1035/rfc1035.html#3.3.14. */
+			if (bufptr - buf + cnt + 1 >= (2 * PACKETSZ))
+				return strdup("e=perm;");
+			if (cp + cnt > eom)
+				return strdup("e=perm;");
+			byte_copy((char *) bufptr, cnt, (char *) cp);
+			rdlength -= cnt + 1;
+			bufptr += cnt;
+			cp += cnt;
+			*bufptr = '\0';
+		}
+		return (char *) strdup((char *) buf);
+	}
+	return strdup("e=perm;");
+}
+
+static char    *
+uri_decode(char *str, size_t str_len, char **strend)
+{
+	size_t          i = 0, j = 0, found;
+	int             pasthostname = 0;
+	char           *str_bits = "\r\n\t \'\"<>()";
+
+	for (i = 0; i < str_len; i++, j++) {
+		if (str[i] == '%' || (!pasthostname && str[i] == '=')) {
+			if (i + 2 < str_len) {
+				if (isxdigit(str[i + 1]) && isxdigit(str[i + 2])) {
+					int             c1 = str[i + 1];
+					int             c2 = str[i + 2];
+					int             num = (	/* first character */
+											  ((c1 & 0xF)	/* take right half */
+											   +(9 * (c1 >> 6)))	/* add 9 if character is a-f or A-F */
+											  <<4	/* pack into the left half of the byte */
+						) | (	/* second character */
+								(c2 & 0xF)
+								+ (9 * (c2 >> 6))
+						);		/* leave it as the left half */
+					str[j] = tolower(num);
+					i += 2;
+					continue;
+				}
+			}
+		}
+		if (!pasthostname && (str[i] == '?' || str[i] == '/' || str[i] == '\\'))
+			pasthostname = 1;
+		if (i + 1 < str_len) {
+			if (str[i] == '=' && str[i + 1] == '\n') {
+				j -= 1;
+				i += 1;
+				continue;
+			}
+		}
+		if (i + 2 < str_len) {
+			if (str[i] == '=' && str[i + 1] == '\r' && str[i + 2] == '\n') {
+				j -= 1;
+				i += 2;
+				continue;
+			}
+		}
+		found = str_chr(str_bits, str[i]);
+		if (str_bits[found])
+			break;
+		str[j] = tolower(str[i]);
+	}
+	str[j] = '\0';
+	*strend = str + j + 1;
+	return str;
+}
+
+/*
+ * Returns:
+ * -1 on error
+ *  0 if domain wasn't cached
+ *  1 if domain was cached, and not blacklisted
+ *  2 if domain was cached, and blacklisted.
+ *
+ * text != NULL: host blacklisted, text == reason.
+ */
+static int
+cachefunc(char *uri, size_t urilen, char **text, int flag)
+{
+	static char     inbuf[2048];
+	static stralloc cachefile = { 0 }, reason = { 0 };
+	int             fd, i, n, textlen, match;
+	struct stat     st;
+	substdio        ss;
+
+	if (!do_cache)
+		return (0);
+	if (uri[i = str_chr(uri, '/')]) {
+		errno = EINVAL;
+		return (-1);
+	}
+	if (!stralloc_copyb(&cachefile, "control/cache", 13))
+		die_nomem();
+	if (!stralloc_0(&cachefile))
+		die_nomem();
+	if (access(cachefile.s, F_OK))
+		return (0);
+	cachefile.len--;
+	if (!stralloc_append(&cachefile, "/"))
+		die_nomem();
+	if (!stralloc_cats(&cachefile, uri))
+		die_nomem();
+	if (!stralloc_0(&cachefile))
+		die_nomem();
+	if (flag) { /*- add the cache */
+		if (!access(cachefile.s, F_OK))
+			return (0);
+		if ((fd = open(cachefile.s, O_CREAT|O_WRONLY, *text ? 0600 : 0644)) == -1)
+			my_error(cachefile.s, 0, 2);
+		if (*text) {
+			textlen = str_len(*text);
+			if ((n = write(fd, *text, textlen)) == -1) {
+				close(fd);
+				my_error("write", 0, 1);
+			}
+		}
+		if (close(fd))
+			my_error(cachefile.s, 0, 1);
+	} else {
+		if (stat(cachefile.s, &st) == -1) {
+			if (errno == ENOENT)
+				return (0);
+			my_error("stat", 0, 1);
+			return -1;
+		}
+		if (time(0) > st.st_mtime + cachelifetime) {
+			if (unlink(cachefile.s)) {
+				my_error("unlink", 0, 1);
+				return -1;
+			}
+			return (0);
+		}
+		if ((fd = open(cachefile.s, O_RDONLY)) == -1)
+			my_error(cachefile.s, 0, 2);
+		substdio_fdbuf(&ss, read, fd, inbuf, sizeof(inbuf));
+		if (getln(&ss, &reason, &match, '\n') == -1) {
+			close(fd);
+			return -1;
+		}
+		*text = reason.s;
+		close(fd);
+		return (((st.st_mode & 07777) == 0600) ? 2 : 1);
+	}
+	return (0);
+}
+
+static int
+getdnsip(stralloc *ip, stralloc *domain, int *code)
+{
+	char            x[IPFMT];
+	ipalloc         ia = { 0 };
+	int             len;
+
+	if (!stralloc_copys(ip, ""))
+		die_nomem();
+	switch(dns_ip(&ia, domain))
+	{
+	case DNS_MEM:
+		die_nomem();
+	case DNS_SOFT:
+		die_soft();
+	case DNS_HARD:
+		return 0;
+	case 1:
+		if (ia.len <= 0)
+			die_soft();
+	}
+	if (code)
+		*code = *(&ia.ix->ip.d[3]);
+	len = ip_fmt(x, &ia.ix->ip);
+	if (!stralloc_copyb(ip, x, len))
+		die_nomem();
+	return 0;
+}
+
+/*- SURBL: Check surbl rcpt whitelist.  */
+int
+srwcheck(char *arg, int len)
+{
+	int             j;
+
+	if (!srwok)
+		return 0;
+	if (constmap(&mapsrw, arg, len))
+		return 1;
+	if ((j = byte_rchr(arg, len, '@')) < (len - 1)) {
+		if (constmap(&mapsrw, arg + j, len - j))
+			return 1;
+	}
+	return 0;
+}
+
+int
+l2check(char *arg, int len)
+{
+	if (!l2ok)
+		return (0);
+	if (constmap(&mapl2, arg, len))
+		return 1;
+	return (0);
+}
+
+int
+l3check(char *arg, int len)
+{
+	if (!l3ok)
+		return (0);
+	if (constmap(&mapl3, arg, len))
+		return 1;
+	return (0);
+}
+
+/*
+ * Returns -1 on error.
+ * Returns 0 if host does not exist.
+ * Returns 1 if host exists.
+ */
+static int
+checkwhitelist(char *hostname, int hostlen)
+{
+	int             len;
+	char           *ptr;
+
+	for (ptr = whitelist.s, len = 0;len < whitelist.len;) {
+		if (!str_diffn(hostname, ptr, hostlen))
+			return (1);
+		len += (str_len(ptr) + 1);
+		ptr = whitelist.s + len;
+	}
+	return (0);
+}
+
+static int
+getreason(int code, char **text)
+{
+	static stralloc reason = { 0 };
+
+	if (!stralloc_copyb(&reason, "blacklisted by ", 15))
+		die_nomem();
+	if (code & 64 && !stralloc_cats(&reason, debug ? "prolocation/jwspamspy" : "[jp]"))
+		die_nomem();
+	if (code & 32 && !stralloc_cats(&reason, debug ? "abusebutler " : "[ab]"))
+		die_nomem();
+	if (code & 16 && !stralloc_cats(&reason, debug ? "outblaze " : "[ob]"))
+		die_nomem();
+	if (code & 8 && !stralloc_cats(&reason, debug ? "phising " : "[ph]"))
+		die_nomem();
+	if (code & 2 && !stralloc_cats(&reason, debug ? "spamcop " : "[sc]"))
+		die_nomem();
+	if (code & 4 && !stralloc_cats(&reason, debug ? "w.stearns " : "[ws]"))
+		die_nomem();
+	if (!stralloc_0(&reason))
+		die_nomem();
+	*text = reason.s;
+	return (code >= 2);
+}
+
+static int
+checksurbl(char *uri, int urilen, char *surbldomain, char **text)
+{
+	static stralloc ip = { 0 };
+	static stralloc host = { 0 };
+	int             i, code = 0;
+
+	if ((i = checkwhitelist(uri, urilen)) == -1)
+		return -1;
+	else
+	if (i)
+		return (0);
+	if (stralloc_copys(&host, uri) == 0)
+		die_nomem();
+	if (stralloc_append(&host, ".") == 0)
+		die_nomem();
+	if (stralloc_cats(&host, surbldomain) == 0)
+		die_nomem();
+	if (!stralloc_0(&host))
+		die_nomem();
+	if (getdnsip(&ip, &host, &code) == -1)
+		return -1;
+	if (do_text && ip.len > 0) {
+		if (text) {
+			if ((*text = dns_text(host.s)))
+				return 2;
+		}
+		return 1;
+	}
+	if (code > 1)
+		return (getreason(code, text) ? 2 : 0);
+	return 0;
+}
+
+static int
+num_domains(const char *s)
+{
+	int             r = *s ? 1 : 0;
+
+	while (*s) {
+		if (*s++ == '.')
+			++r;
+	}
+	return r;
+}
+
+static char *
+remove_subdomains(char *orig, int output_domains)
+{
+	char           *s = orig + str_len((char *) orig);
+	int             dots = 0;
+
+	while (s > orig) {
+		if (*s == '.')
+			++dots;
+		if (dots == output_domains) {
+			++s;
+			break;
+		}
+		--s;
+	}
+	return s;
+}
+
+/*
+ * Returns 0 if URI was erronous.
+ *         1 if URI was not blacklisted.
+ *         2 if URI was blacklisted.
+ */
+static int
+checkuri(char **ouri, char **text, size_t textlen)
+{
+	char           *uri = *ouri, *uriend, *ptr;
+	char            ipuri[IPFMT];
+	size_t          urilen = 0;
+	ip_addr         ip;
+	int             cached, blacklisted, i, level;
+
+	if (case_diffb(uri, 4, "http"))
+		return 0;
+	uri += 4;
+
+	/*- Check and skip http[s]?:[/\\][/\\]?  */
+	if (*uri == 's')
+		uri++;
+	if (*uri == ':' && (uri[1] == '/' || uri[1] == '\\'))
+		uri += 2;
+	else 
+		return 0;
+	if (*uri == '/' || *uri == '\\')
+		uri++;
+	if (!isalpha(*uri) && !isdigit(*uri))
+		return 0;
+	uri_decode(uri, textlen, &uriend);
+	*ouri = uriend;
+	print_debug("Full    URI: ", uri, 0);
+	uri[(urilen = str_cspn(uri, "/\\?"))] = '\0';
+	if (uri[i = str_chr(uri, '@')])
+		uri += (i + 1);
+	uri[i = str_chr(uri, ':')] = 0;
+	if (ip_scan(uri, &ip)) {
+		ip_fmt(ipuri, &ip);
+		uri = ipuri;
+		print_debug("Proper IP: ", uri, 0);
+	} else {
+		urilen = str_len(uri);
+		print_debug("Full domain: ", uri, 0);
+		level = num_domains(uri);
+		if (level > 2) {
+			ptr = remove_subdomains(uri, 3);
+			if (l3check(ptr, str_len(ptr)))
+				uri = remove_subdomains(uri, 4);
+			else {
+				ptr = remove_subdomains(uri, 2);
+				if (l2check(ptr, str_len(ptr)))
+					uri = remove_subdomains(uri, 3);
+				else
+					uri = remove_subdomains(uri, 2);
+			}
+		} else
+		if (level > 1) {
+			ptr = remove_subdomains(uri, 2);
+			if (l2check(ptr, str_len(ptr)))
+				uri = remove_subdomains(uri, 3);
+			else
+				uri = remove_subdomains(uri, 2);
+		}
+		print_debug("       Part: ", uri, 0);
+	}
+	urilen = str_len(uri);
+	cached = 1;
+	blacklisted = 0;
+	switch (cachefunc(uri, urilen, text, 0))
+	{
+	case 0:
+		cached = 0;
+		break;
+	case 1:
+		blacklisted = 0;
+		break;
+	case 2:
+		blacklisted = 1;
+		break;
+	}
+	if (cached == 0) {
+		switch (checksurbl(uri, urilen, surbldomain.s, text))
+		{
+		case -1:
+			return -1;
+		case 0:
+			blacklisted = 0;
+			*text = (char *) 0;
+			print_debug(uri, ": not blacklisted", 0);
+			break;
+		case 1:
+			*text = "No reason given";
+			blacklisted = 1;
+			print_debug(uri, ": blacklisted. reason - ", *text);
+			break;
+		case 2:
+			blacklisted = 2;
+			print_debug(uri, ": blacklisted. reason - ", *text);
+			break;
+		}
+		cachefunc(uri, urilen, text, 1);
+	}
+	return (blacklisted);
+}
+
+#define DEF_SURBL_DOMAIN "multi.surbl.org"
+
+static int      do_surbl = 1;
+
+static void
+setup()
+{
+	char           *x, *y, *rcpt;
+	int             i;
+
+	if ((rcpt = env_get("QMAILRCPTS"))) {
+		if ((srwok = control_readfile(&srw, "control/surblrcpt", 0)) == -1)
+			die_control();
+		if (srwok && !constmap_init(&mapsrw, srw.s, srw.len, 0))
+			die_nomem();
+	}
+	for (x = y = rcpt, i = 0;rcpt && *x;x++, i++) {
+		if (*x == '\n') {
+			*x = 0;
+			if (srwcheck(y, i)) {
+				do_surbl = 0;
+				return;
+			}
+			y = x + 1;
+			*x = '\n';
+			i = 0;
+		}
+	}
+	if ((l2ok = control_readfile(&l2, "control/level2-tlds", 0)) == -1)
+		die_control();
+	if (l2ok && !constmap_init(&mapl2, l2.s, l2.len, 0))
+		die_nomem();
+	if ((l3ok = control_readfile(&l3, "control/level3-tlds", 0)) == -1)
+		die_control();
+	if (l3ok && !constmap_init(&mapl3, l3.s, l3.len, 0))
+		die_nomem();
+	switch (control_readline(&surbldomain, "control/surbldomain"))
+	{
+	case -1:
+		die_control();
+	case 0:
+		if (!stralloc_copys(&surbldomain, DEF_SURBL_DOMAIN))
+			die_nomem();
+		/*- flow through */
+	case 1:
+		if (!stralloc_0(&surbldomain))
+			die_nomem();
+	}
+	if ((x = env_get("CACHELIFETIME")))
+		scan_int(x, &cachelifetime);
+	else
+	if (control_readint(&cachelifetime, "control/cachelifetime") == -1)
+		die_control();
+	if (control_readfile(&whitelist, "control/surbldomainwhite", 0) == -1)
+		die_control();
+	return;
+}
+
+int
+main(int argc, char **argv)
+{
+	stralloc        base64out = { 0 }, boundary = { 0 };
+	stralloc       *ptr;
+	char           *x, *reason = 0;
+	int             opt, in_header = 1, i, total_bl = 0, blacklisted, match, html_plain_text,
+					base64_decode, found_content_type = 0;
+
+	if (!(x = env_get("SURBL")))
+		do_surbl = 0;
+	while ((opt = getopt(argc, argv, "vtc")) != opteof) {
+		switch (opt) {
+		case 'c':
+			do_cache = 0;
+			break;
+		case 'v':
+			debug = 1;
+			break;
+		case 't':
+			do_text = 1;
+			break;
+		}
+	}
+	if (chdir(auto_qmail) == -1)
+		die_control();
+	if (do_surbl)
+		setup();
+	for (html_plain_text = base64_decode = 0;;) {
+		if (getln(&ssin, &line, &match, '\n') == -1)
+			my_error("getln: ", 0, 1);
+		if (!match && line.len == 0)
+			break;
+		if (substdio_put(&ssout, line.s, line.len))
+			die_write();
+		if (!do_surbl)
+			continue;
+		if (in_header) {
+			if (!str_diffn(line.s, "Content-Type: ", 14)) {
+				found_content_type = 1;
+			}
+			if (found_content_type) {
+				for (i = 0;i < line.len; i++) {
+					if (case_startb(line.s + i, line.len - i, "boundary=")) {
+						if (line.s[i + 9] == '\"' && line.s[line.len -2] == '\"')
+						{
+							if (!stralloc_copyb(&boundary, line.s + i + 10, line.len -i - 12))
+								die_nomem();
+						} else
+						if (!stralloc_copyb(&boundary, line.s + i + 9, line.len - i - 10))
+							die_nomem();
+						if (!stralloc_0(&boundary))
+							die_nomem();
+						boundary.len--;
+					}
+				}
+			}
+			if (!mess822_ok(&line))
+				in_header = 0;
+		} else {
+			if (!str_diffn(line.s, "Content-Type: ", 14)) {
+				if (!str_diffn(line.s + 14, "message/rfc822", 14) ||
+					!str_diffn(line.s + 14, "text/html", 9) ||
+					!str_diffn(line.s + 14, "text/plain", 10))
+						html_plain_text = 1;
+				else
+						html_plain_text = 0;
+			}
+			if (html_plain_text && !str_diffn(line.s, "Content-Transfer-Encoding: ", 27)) {
+				if (!str_diffn(line.s + 27, "base64", 6))
+					base64_decode = 1;
+				else
+					base64_decode = 0;
+			}
+			if (line.len == 1)
+				continue;
+			if (base64_decode) {
+				if (!str_diffn(line.s, "Content-", 8))
+					continue;
+				if (!str_diffn(line.s + 2, boundary.s, boundary.len)) {
+					base64_decode = 0;
+					continue;
+				}
+				if (b64decode((const unsigned char *) line.s, line.len - 1, &base64out) == -1)
+					die_nomem();
+				ptr = &base64out;
+			} else
+				ptr = &line;
+			for (blacklisted = -1, i = 0;i < ptr->len; i++) {
+				if (case_startb(line.s + i, ptr->len - i, "http:")) {
+					x = ptr->s + i;
+					switch (checkuri(&x, &reason, ptr->len - i))
+					{
+					case -1:
+						my_error("checkuri", 0, 111);
+					case 0: /*- no valid uri in line */
+						blacklisted = 0;
+						break;
+					case 1:
+					case 2:
+						blacklisted = 1;
+						break;
+					}
+				}
+				if (blacklisted == 1) {
+					total_bl++;
+					break;
+				}
+			}
+		}
+	} /*- for (html_plain_text = base64_decode = 0;;) { */
+	if (substdio_flush(&ssout) == -1)
+		die_write();
+	if (do_surbl && total_bl) {
+		logerrf("Dmessage contains an URL listed in SURBL blocklist");
+		_exit (88); /*- custom error */
+	}
+	return (0);
+}
+
+void
+getversion_surblfilter_c()
+{
+	static char    *x = "$Id: surblfilter.c,v 1.4 2011-07-13 22:28:32+05:30 Cprogrammer Exp mbhangui $";
+
+	x++;
+}
+
diff -Naur netqmail-1.06.org/surblqueue.sh netqmail-1.06/surblqueue.sh
--- netqmail-1.06.org/surblqueue.sh	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/surblqueue.sh	2022-12-09 22:58:50.000000000 +0530
@@ -0,0 +1,32 @@
+# I should be called by qmail-smtpd or anything that calls qmail-queue
+#
+if [ -f /bin/mktemp ] ; then
+	MKTEMP=/bin/mktemp
+elif [ -f /usr/bin/mktemp ] ; then
+	MKTEMP=/usr/bin/mktemp
+else
+	MKTEMP=mktemp
+fi
+out=`$MKTEMP -t surblXXXXXXXXXX`
+if [ $? -ne 0 ] ; then
+	echo "mktemp: unable to create temp files" 1>&2
+	exit 111
+fi
+#
+# Redirect standard error to 4 so that qmail_open() will pick up the error
+#
+QMAIL/bin/surblfilter > $out 2>&4
+status=$?
+if [ $status -eq 0 ] ; then
+	exec 0<$out
+	/bin/rm -f $out
+	# use SURBLQUEUE to execute queue program (thanks Roberto Puzzanghera)
+	if [ "$SURBLQUEUE" != "" -a -x "$SURBLQUEUE" ]; then
+		exec $SURBLQUEUE
+	else
+		exec QMAIL/bin/qmail-queue
+	fi
+else
+	/bin/rm -f $out
+	exit $status
+fi
diff -Naur netqmail-1.06.org/tai.h netqmail-1.06/tai.h
--- netqmail-1.06.org/tai.h	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/tai.h	2022-12-09 22:58:50.000000000 +0530
@@ -0,0 +1,34 @@
+/*
+ * $Log: tai.h,v $
+ * Revision 1.3  2004-10-11 14:15:10+05:30  Cprogrammer
+ * added function prototypes
+ *
+ * Revision 1.2  2004-09-19 22:49:23+05:30  Cprogrammer
+ * added tai_unix macro
+ *
+ * Revision 1.1  2004-06-16 01:20:25+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
+#ifndef TAI_H
+#define TAI_H
+
+#include "uint64.h"
+
+struct tai
+{
+	uint64          x;
+};
+
+#define tai_unix(t,u) ((void) ((t)->x = 4611686018427387914ULL + (uint64) (u)))
+#define tai_approx(t) ((double) ((t)->x))
+#define tai_less(t,u) ((t)->x < (u)->x)
+#define TAI_PACK 8
+
+void            tai_now(struct tai *);
+void            tai_add();
+void            tai_sub(struct tai *, struct tai *, struct tai *);
+void            tai_pack(char *, struct tai *);
+void            tai_unpack(char *, struct tai *);
+
+#endif
diff -Naur netqmail-1.06.org/TARGETS netqmail-1.06/TARGETS
--- netqmail-1.06.org/TARGETS	1998-06-15 16:23:16.000000000 +0530
+++ netqmail-1.06/TARGETS	2023-02-13 08:44:18.000000000 +0530
@@ -385,3 +385,42 @@
 man
 setup
 check
+qmail-dkim
+qmail-dkim.o
+libdkim.a
+dkimbase.o
+dkim.o
+dkimsign.o
+dkimverify.o
+dkim
+dkim.o
+dkim.8
+qmail-dkim.8
+qmail-dkim.0
+str_cpyb.o
+dkimfuncs.o
+MakeArgs.o
+spawn-filter spawn-filter.o qregex.o wildmat.o
+spawn-filter.8
+spawn-filter.0
+dk-filter echo.o echo dk-filter.0 dk-filter.8
+case_startb.o
+mess822_ok.o
+scan_xlong.o
+socket_v4mappedprefix.o
+socket_v6any.o
+str_cspn.o
+surblfilter.o
+surblfilter
+surblfilter.8
+uint64.h
+surblqueue
+surblfilter.0
+base64sub.o
+dktrace.o
+dknewkey
+dknewkey.8
+time_t_size.h
+getDomainToken.o
+parse_env.o
+dns_text.o
diff -Naur netqmail-1.06.org/testqmail-dks netqmail-1.06/testqmail-dks
--- netqmail-1.06.org/testqmail-dks	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/testqmail-dks	2023-04-26 08:00:40.000000000 +0530
@@ -0,0 +1,1355 @@
+#!/bin/sh
+verbose=0
+domainkey_dir=/tmp/domainkeys
+
+# The domain under your control and for which you
+# have the public key in dns. Have the following
+# keys in dns or modify the RSA 2048, RSA 4096,
+# ed25519 keys appropriately
+#
+if [ $# -eq 0 ] ; then
+	real_domain=$(cat /var/qmail/control/me)
+else
+	real_domain=$1
+fi
+# rsa key 2048
+real_domain_rsa2048=/var/qmail/control/domainkeys/$real_domain/b2048
+
+# rsa key 4096
+real_domain_rsa4096=/var/qmail/control/domainkeys/$real_domain/default
+
+# ed25519 key
+real_domain_ed25519=/var/qmail/control/domainkeys/$real_domain/ed25519
+
+#
+# set bindir and sbindir to locate your binaries. use $PWD
+# to test your binaries at current localtion or use /var/qmail/bin,
+# bin/sbin whatever
+#
+bindir=$PWD
+sbindir=$PWD
+
+dkim=$bindir/dkim
+qmail_dkim=$sbindir"/qmail-dkim"
+dk_filter=$bindir/dk-filter
+dknewkey=$bindir/dknewkey
+
+# for qmail this is 32, for indimail this is 35
+nokeyerror=32
+
+# This is where lot of the output goes
+out=/dev/null
+
+## For testing on indimail. Comment out next 5 lines if not commented
+#real_domain=indimail.org
+#real_domain_rsa2048=/etc/indimail/control/domainkeys/argos.indimail.org/argos
+#real_domain_rsa4096=/etc/indimail/control/domainkeys/argos.indimail.org/b4096
+#real_domain_ed25519=/etc/indimail/control/domainkeys/argos.indimail.org/ed25519
+#nokeyerror=35
+
+if [ ! -d $domainkey_dir ] ; then
+	sudo mkdir -p $domainkey_dir
+	#sudo chown root:qmail $domainkey_dir
+fi
+/bin/rm -f /tmp/control/dkimkeys
+for i in example.com example.org
+do
+	if [ ! -d $domainkey_dir/$i ] ; then
+		sudo mkdir -p $domainkey_dir/$i
+		#sudo chown root:qmail $domainkey_dir/$i
+	fi
+	if [ ! -f $domainkey_dir/$i/default ] ; then
+		echo "Creating private key bits 4096 $domainkey_dir/$i/default"
+		sudo $dknewkey -e -b 4096 $domainkey_dir/$i/default >$out
+		sudo chmod 644 $domainkey_dir/$i/default
+	fi
+	if [ ! -f $domainkey_dir/$i/dkimkeys1 ] ; then
+		echo "Creating private key bits 2048 $domainkey_dir/$i/dkimkeys1"
+		sudo $dknewkey -e -b 2048 $domainkey_dir/$i/dkimkeys1 >$out
+		sudo chmod 644 $domainkey_dir/$i/dkimkeys1
+	fi
+	if [ ! -f $domainkey_dir/$i/dkimkeys2 ] ; then
+		echo "Creating private key $domainkey_dir/$i/dkimkeys2"
+		sudo $dknewkey -e -t ed25519 $domainkey_dir/$i/dkimkeys2 >$out
+		sudo chmod 644 $domainkey_dir/$i/dkimkeys2
+	fi
+done
+
+for i in test default
+do
+	if [ ! -f $domainkey_dir/$i ] ; then
+		echo "Creating private key bits 4096 $domainkey_dir/$i"
+		sudo $dknewkey -e -b 4096 $domainkey_dir/$i >$out
+		sudo chmod 644 $domainkey_dir/$i
+	fi
+done
+
+for i in example.com example.org
+do
+	if [ ! -d $domainkey_dir/$i ] ; then
+		sudo mkdir -p $domainkey_dir/$i
+		#sudo chown root:qmail $domainkey_dir/$i
+	fi
+	if [ ! -f $domainkey_dir/$i/ed25519 ] ; then
+		echo "Creating private key $domainkey_dir/$i/ed25519"
+		sudo $dknewkey -e -t ed25519 $domainkey_dir/$i/ed25519 >$out
+		sudo chmod 644 $domainkey_dir/$i/ed25519
+	fi
+done
+mkdir -p /tmp/control
+
+failed=0
+echo "testing real domain $real_domain (rsa2048+rsa4096+ed25519) using dkim with selector from dns"
+for k in $real_domain_rsa2048 $real_domain_rsa4096 $real_domain_ed25519
+do
+	case $k in
+		$real_domain_rsa2048)
+		echo "    testing rsa2048"
+		;;
+		$real_domain_rsa4096)
+		echo "    testing rsa4096"
+		;;
+		$real_domain_ed25519)
+		echo "    testing ed25519"
+		;;
+	esac
+	if [ $verbose -gt 0 ] ; then
+		echo "testing real domain $real_domain $ktype DKIM record"
+	fi
+	ktype=$(cat $k.pub| grep "k="|sed 's{v=DKIM1;{{'|cut -d= -f2|cut -d';' -f1)
+	case $ktype in
+		"rsa")
+		enc="2"
+		;;
+		"ed25519")
+		enc="4"
+		;;
+	esac
+	(
+	echo "From: postmaster@$real_domain"
+	echo "To: postmaster@$real_domain"
+	echo "Subject: Test"
+	echo "Date: $(date -R)"
+	echo
+	echo "Test message"
+	) > /tmp/mail.txt 
+	(cat /tmp/mail.txt | $bindir/dkim -z $enc -s "$k"; cat /tmp/mail.txt) | $bindir/dkim -v > $out
+	ret=$?
+	/bin/rm -f /tmp/mail.txt
+	if [ $ret -eq 0 ] ; then
+		if [ $verbose -gt 0 ] ; then
+			echo "SUCCESS: [ret=$ret] domain=$real_domain key=$k"
+			echo
+		fi
+		echo SUCCESS ======================== >$out
+	else
+		echo "FAILED : [ret=$ret] domain=$real_domain key=$k"
+		echo
+		echo FAILURE [$ret] ======================== >$out
+		echo >$out
+		failed=1
+	fi
+done
+
+if [ $verbose -eq 0 -a $failed -eq 0 ] ; then
+	echo "  Success"
+	echo
+fi
+if [ $failed -eq 1 ] ; then
+	echo "Test Failed for real domain $real_domain (rsa2048+rsa4096+ed25519) using $dkim with selector from dns"
+	exit 1
+elif [ $verbose -ne 0 ] ; then
+	echo "All Tests succeeded for real domain $real_domain (rsa2048+rsa4096+ed25519) using $dkim with selector from dns"
+fi
+
+failed=0
+echo "testing multi-signature real domain $real_domain (rsa4096+ed25519) signing+verification by dkim with selector from dns"
+if [ $verbose -gt 0 ] ; then
+	echo "testing real domain $real_domain multi DKIM record"
+fi
+(
+echo "From: postmaster@$real_domain"
+echo "To: postmaster@$real_domain"
+echo "Subject: Test"
+echo "Date: $(date -R)"
+echo
+echo "Test message"
+) > /tmp/mail.txt 
+(cat /tmp/mail.txt | $bindir/dkim -z 2 -s $real_domain_rsa4096 -z 4 -s $real_domain_ed25519; cat /tmp/mail.txt) | $bindir/dkim -vV >$out 2>/tmp/err.out
+ret=$?
+/bin/rm -f /tmp/mail.txt
+grep Signature /tmp/err.out | sed -e 's{Signature #{    Signature{g' \
+	-e 's{01{rsa-256{' -e 's{02{ed25519{' -e 's{Failure.*{Failure - Correct{'
+if [ $ret -eq 0 ] ; then
+	if [ $verbose -gt 0 ] ; then
+		echo "SUCCESS: [ret=$ret] domain=$real_domain key=$real_domain_rsa4096+$real_domain_ed25519"
+		echo
+	fi
+	echo SUCCESS ======================== >$out
+else
+	echo "FAILED : [ret=$ret] domain=$real_domain key=$real_domain_rsa4096+$real_domain_ed25519"
+	echo
+	echo FAILURE [$ret] ======================== >$out
+	echo >$out
+	failed=1
+fi
+
+if [ $verbose -eq 0 -a $failed -eq 0 ] ; then
+	echo "  Success"
+	echo
+fi
+if [ $failed -eq 1 ] ; then
+	echo "Test Failed for real domain $real_domain (rsa2048+rsa4096+ed25519) using $dkim with selector from dns"
+	exit 1
+elif [ $verbose -ne 0 ] ; then
+	echo "All Tests succeeded for real domain $real_domain (rsa2048+rsa4096+ed25519) using $dkim with selector from dns"
+fi
+
+failed=0
+echo "testing multi-signature real domain $real_domain (rsa4096+ed25519) signing by qmail-dkim, verification by dkim with selector from dns"
+if [ $verbose -gt 0 ] ; then
+	echo "testing real domain $real_domain multi DKIM record"
+fi
+(
+echo "From: postmaster@$real_domain"
+echo "To: postmaster@$real_domain"
+echo "Subject: Test"
+echo "Date: $(date -R)"
+echo
+echo "Test message"
+) | env - \
+		CONTROLDIR=/tmp/control \
+		DKIMSIGN="$real_domain_rsa4096" \
+		DKIMSIGNOPTIONS="-z 2" \
+		DKIMSIGNEXTRA="$real_domain_ed25519" \
+		DKIMSIGNOPTIONSEXTRA="-z 4" \
+		DKIMQUEUE=/bin/cat \
+		$qmail_dkim | $bindir/dkim -vV >$out 2>/tmp/err.out
+ret=$?
+grep Signature /tmp/err.out | sed -e 's{Signature #{    Signature{g' \
+	-e 's{01{ed25519{' -e 's{02{rsa-256{' -e 's{Failure.*{Failure - Correct{'
+if [ $ret -eq 0 ] ; then
+	if [ $verbose -gt 0 ] ; then
+		echo "SUCCESS: [ret=$ret] domain=$real_domain key=$real_domain_rsa4096+$real_domain_ed25519"
+		echo
+	fi
+	echo SUCCESS ======================== >$out
+else
+	echo "FAILED : [ret=$ret] domain=$real_domain key=$real_domain_rsa4096+$real_domain_ed25519"
+	echo
+	echo FAILURE [$ret] ======================== >$out
+	echo >$out
+	failed=1
+fi
+
+if [ $verbose -eq 0 -a $failed -eq 0 ] ; then
+	echo "  Success"
+	echo
+fi
+if [ $failed -eq 1 ] ; then
+	echo "Test Failed for real domain $real_domain (rsa2048+rsa4096+ed25519) using $dkim with selector from dns"
+	exit 1
+elif [ $verbose -ne 0 ] ; then
+	echo "All Tests succeeded for real domain $real_domain (rsa2048+rsa4096+ed25519) using $dkim with selector from dns"
+fi
+
+failed=0
+echo "testing real domain $real_domain (rsa2048+rsa4096+ed25519) using qmail-dkim with selector from dns"
+for k in $real_domain_rsa2048 $real_domain_rsa4096 $real_domain_ed25519
+do
+	if [ $verbose -gt 0 ] ; then
+		echo "testing real domain $real_domain"
+	fi
+	case $k in
+		$real_domain_rsa2048)
+		echo "    testing rsa2048"
+		;;
+		$real_domain_rsa4096)
+		echo "    testing rsa4096"
+		;;
+		$real_domain_ed25519)
+		echo "    testing ed25519"
+		;;
+	esac
+	ktype=$(cat $k.pub| grep "k="|sed 's{v=DKIM1;{{'|cut -d= -f2|cut -d';' -f1)
+	case $ktype in
+		"rsa")
+		enc="2"
+		;;
+		"ed25519")
+		enc="4"
+		;;
+	esac
+	(
+	echo "From: postmaster@$real_domain"
+	echo "To: postmaster@$real_domain"
+	echo "Subject: Test"
+	echo "Date: $(date -R)"
+	echo
+	echo "Test message"
+	) | env - \
+		DKIMSIGN="$k" \
+		DKIMSIGNOPTIONS="-z $enc" \
+		DKIMQUEUE=/bin/cat \
+		$qmail_dkim | env - \
+			DKIMVERIFY="" \
+			DKIMQUEUE=/bin/cat \
+			$qmail_dkim > $out
+	ret=$?
+	if [ $ret -eq 0 ] ; then
+		if [ $verbose -gt 0 ] ; then
+			echo "SUCCESS: [ret=$ret] domain=$real_domain key=$real_domain_key"
+			echo
+		fi
+		echo SUCCESS ======================== >$out
+	else
+		echo "FAILED : [ret=$ret] domain=$real_domain key=$real_domain_key"
+		echo
+		echo FAILURE [$ret] ======================== >$out
+		echo >$out
+		failed=1
+	fi
+done
+
+if [ $verbose -eq 0 -a $failed -eq 0 ] ; then
+	echo "  Success"
+	echo
+fi
+if [ $failed -eq 1 ] ; then
+	echo "Test Failed for real domain $real_domain (rsa2048+rsa4096+ed25519) using $qmail_dkim with selector from dns"
+	exit 1
+elif [ $verbose -ne 0 ] ; then
+	echo "All Tests succeeded for real domain $real_domain (rsa2048+rsa4096+ed25519) using $qmail_dkim with selector from dns"
+fi
+
+echo "testing dkim with different key types (rsa2048+rsa4096+ed25519) signing+verification by dkim"
+failed=0
+for i in dkimkeys1 default ed25519
+do
+	if [ $verbose -gt 0 ] ; then
+		echo testing key type $i
+	fi
+	if [ "$i" = "ed25519" ] ; then
+		enc=4
+	else
+		enc=2
+	fi
+	case $i in
+		dkimkeys1)
+		echo "    testing rsa2048"
+		;;
+		default)
+		echo "    testing rsa4096"
+		;;
+		ed25519)
+		echo "    testing ed25519"
+		;;
+	esac
+	for j in example.com example.org
+	do
+		selector=$(cat $domainkey_dir/$j/$i.pub |sed -e 's{.*({{' -e 's{).*{{' -e '/^$/d' -e 's{"{{g' -e 's{\t{{g' | tr -d '\n')
+		if [ $verbose -gt 0 ] ; then
+			echo "($dkim -z $enc -s $domainkey_dir/$j/$i </tmp/mail.txt;cat /tmp/mail.txt) | $dkim -v -T $selector"
+		fi
+		(
+		echo "From: postmaster@$j"
+		echo "To: postmaster@$j"
+		echo "Subject: Test"
+		echo "Date: $(date -R)"
+		echo
+		echo "Test message"
+		) > /tmp/mail.txt
+		(cat /tmp/mail.txt | $dkim -z $enc -s $domainkey_dir/$j/$i; cat /tmp/mail.txt) | $dkim -v -T "$selector" > $out
+		ret=$?
+		/bin/rm /tmp/mail.txt
+		if [ $ret -eq 0 ] ; then
+			if [ $verbose -gt 0 ] ; then
+				echo "SUCCESS: [ret=$ret]  $selector"
+				echo
+			fi
+			echo SUCCESS ======================== >$out
+		else
+			echo "FAILED : [ret=$ret] domain=$j key=$domainkey_dir/$j/$i $selector"
+			echo
+			echo FAILURE [$ret] ======================== >$out
+			echo >$out
+			failed=1
+		fi
+	done
+done
+
+if [ $verbose -eq 0 -a $failed -eq 0 ] ; then
+	echo "  Success"
+	echo
+fi
+if [ $failed -eq 1 ] ; then
+	echo "Test Failed for $dkim with different key types (rsa+ed25519)"
+	exit 1
+elif [ $verbose -ne 0 ] ; then
+	echo "All Tests succeeded for $dkim with different key types (rsa+ed25519)"
+fi
+
+echo "testing multi-signature signing+verification by dkim"
+failed=0
+for i in example.com example.org
+do
+	key1=$domainkey_dir/$i/default
+	key2=$domainkey_dir/$i/ed25519
+	(
+	echo "From: postmaster@$i"
+	echo "To: postmaster@$i"
+	echo "Subject: Test"
+	echo "Date: $(date -R)"
+	echo
+	echo "Test message"
+	) > /tmp/mail.txt
+	(cat /tmp/mail.txt | $dkim -z 2 -s $key1 -z 4 -s $key2; cat /tmp/mail.txt) > /tmp/result.out
+	/bin/rm -f /tmp/mail.txt
+	for j in default ed25519
+	do
+		if [ $verbose -gt 0 ] ; then
+			echo key $j domain $i
+		fi
+		selector=$(cat $domainkey_dir/$i/$j.pub |sed -e 's{.*({{' -e 's{).*{{' -e '/^$/d' -e 's{"{{g' -e 's{\t{{g' | tr -d '\n')
+		case $j in
+			default)
+			echo "  rsa+ed25519 with rsa-256 selector"
+			;;
+			ed25519)
+			echo "  rsa+ed25519 with ed25519 selector"
+			;;
+		esac
+		sig_count=$(grep DKIM-Signature /tmp/result.out|wc -l)
+		$dkim -vV -T "$selector" > $out 2>/tmp/err.out < /tmp/result.out
+		ret=$?
+		grep Signature /tmp/err.out | sed -e 's{Signature #{    Signature{g' \
+			-e 's{01{rsa-256{' -e 's{02{ed25519{' -e 's{Failure.*{Failure - Correct{'
+		if [ $ret -eq 0 -a $sig_count -eq 2 ] ; then
+			if [ $verbose -gt 0 ] ; then
+				echo "SUCCESS: [ret=$ret]  dkim -s $key1 -s $key2..."
+				echo
+			fi
+			echo SUCCESS ======================== >$out
+		else
+			echo "FAILED : [ret=$ret] domain=$i sig_count=$sig_count dkim -s $key1 -s $key2..."
+			echo
+			echo FAILURE [$ret] ======================== >$out
+			echo >$out
+			failed=1
+		fi
+	done
+	/bin/rm -f /tmp/result.out /tmp/err.out
+done
+
+if [ $verbose -eq 0 -a $failed -eq 0 ] ; then
+	echo "  Success"
+	echo
+fi
+if [ $failed -eq 1 ] ; then
+	echo "Test Failed for  multi-signature signing+verification by $dkim"
+	exit 1
+elif [ $verbose -ne 0 ] ; then
+	echo "All Tests succeeded for  multi-signature signing+verification by $dkim"
+fi
+
+echo "testing multi-signature signing by qmail-dkim + verification by dkim DKIMSIGNEXTRA in env"
+failed=0
+key1=$domainkey_dir/%/default
+key2=$domainkey_dir/%/ed25519
+for i in example.com example.org
+do
+	(
+	echo "From: postmaster@$i"
+	echo "To: postmaster@$i"
+	echo "Subject: Test"
+	echo "Date: $(date -R)"
+	echo
+	echo "Test message"
+	) | env \
+		CONTROLDIR=/tmp/control \
+		DKIMSIGN="$key1" \
+		DKIMSIGNOPTIONS="-z 2" \
+		DKIMQUEUE=/bin/cat \
+		DKIMSIGNEXTRA="$key2" \
+		DKIMSIGNOPTIONSEXTRA="-z 4" \
+		ERR_FD=2 \
+	$qmail_dkim > /tmp/result.out
+	sig_count=$(grep DKIM-Signature /tmp/result.out|wc -l)
+	for j in default ed25519
+	do
+		if [ $verbose -gt 0 ] ; then
+			echo key $j domain $i
+		fi
+		selector=$(cat $domainkey_dir/$i/$j.pub |sed -e 's{.*({{' -e 's{).*{{' -e '/^$/d' -e 's{"{{g' -e 's{\t{{g' | tr -d '\n')
+		case $j in
+			default)
+			echo "  rsa+ed25519 with rsa-256 selector"
+			;;
+			ed25519)
+			echo "  rsa+ed25519 with ed25519 selector"
+			;;
+		esac
+		$dkim -vV -T "$selector" >$out 2>/tmp/err.out < /tmp/result.out
+		ret=$?
+		grep Signature /tmp/err.out | sed -e 's{Signature #{    Signature{g' \
+			-e 's{01{ed25519{' -e 's{02{rsa-256{' -e 's{Failure.*{Failure - Correct{'
+		if [ $ret -eq 0 -a $sig_count -eq 2 ] ; then
+			if [ $verbose -gt 0 ] ; then
+				echo "SUCCESS: [ret=$ret] domain=$i sig_count=$sig_count $qmail_dkim"
+				echo
+			fi
+			echo SUCCESS ======================== >$out
+		else
+			echo "FAILED : [ret=$ret] domain=$i sig_count=$sig_count $qmail_dkim"
+			echo
+			echo FAILURE [$ret] ======================== >$out
+			echo >$out
+			failed=1
+		fi
+	done
+	/bin/rm -f /tmp/result.out /tmp/err.out
+done
+
+if [ $verbose -eq 0 -a $failed -eq 0 ] ; then
+	echo "  Success"
+	echo
+fi
+if [ $failed -eq 1 ] ; then
+	echo "Test Failed for  multi-signature signing by $qmail_dkim + verification by $dkim DKIMSIGNEXTRA in env"
+	exit 1
+elif [ $verbose -ne 0 ] ; then
+	echo "All Tests succeeded for  multi-signature signing by $qmail_dkim + verification by $dkim DKIMSIGNEXTRA in env"
+fi
+
+echo "testing multi-signature signing by qmail-dkim + verification by dkim DKIMSIGNEXTRA in dkimkeys"
+(
+echo "ex*.com:/tmp/domainkeys/%/dkimkeys1:DKIMSIGNEXTRA=/tmp/domainkeys/%/dkimkeys2,DKIMSIGNOPTIONS=-z 4"
+echo "ex.*.org:/tmp/domainkeys/%/dkimkeys1:QREGEX=1,DKIMSIGNEXTRA=/tmp/domainkeys/%/dkimkeys2,DKIMSIGNOPTIONS=-z 4"
+) >/tmp/control/dkimkeys
+failed=0
+for i in example.com example.org
+do
+	(
+	echo "From: postmaster@$i"
+	echo "To: postmaster@$i"
+	echo "Subject: Test"
+	echo "Date: $(date -R)"
+	echo
+	echo "Test message"
+	) | env \
+	CONTROLDIR=/tmp/control \
+	DKIMSIGN="" \
+	DKIMSIGNOPTIONS="-z 2" \
+	DKIMQUEUE=/bin/cat \
+	ERR_FD=2 \
+	$qmail_dkim > /tmp/result.out
+	sig_count=$(grep DKIM-Signature /tmp/result.out|wc -l)
+	for j in dkimkeys1 dkimkeys2
+	do
+		if [ $verbose -gt 0 ] ; then
+			echo key $j domain $i
+		fi
+		selector=$(cat $domainkey_dir/$i/$j.pub |sed -e 's{.*({{' -e 's{).*{{' -e '/^$/d' -e 's{"{{g' -e 's{\t{{g' | tr -d '\n')
+		case $j in
+			dkimkeys1)
+			echo "  rsa+ed25519 with rsa-256 selector"
+			;;
+			dkimkeys2)
+			echo "  rsa+ed25519 with ed25519 selector"
+			;;
+		esac
+		$dkim -vV -T "$selector" >$out 2>/tmp/err.out < /tmp/result.out
+		ret=$?
+		grep Signature /tmp/err.out | sed -e 's{Signature #{    Signature{g' \
+			-e 's{01{ed25519{' -e 's{02{rsa-256{' -e 's{Failure.*{Failure - Correct{'
+		if [ $ret -eq 0 -a $sig_count -eq 2 ] ; then
+			if [ $verbose -gt 0 ] ; then
+				echo "SUCCESS: [ret=$ret] domain=$i sig_count=$sig_count dkimkeys $qmail_dkim" 
+				echo
+			fi
+			echo SUCCESS ======================== >$out
+		else
+			echo "FAILED : [ret=$ret] domain=$i sig_count=$sig_count dkimkeys $qmail_dkim"
+			echo
+			echo FAILURE [$ret] ======================== >$out
+			echo >$out
+			failed=1
+		fi
+	done
+	/bin/rm -f /tmp/result.out /tmp/err.out
+done
+/bin/rm -f /tmp/control/dkimkeys
+
+if [ $verbose -eq 0 -a $failed -eq 0 ] ; then
+	echo "  Success"
+	echo
+fi
+if [ $failed -eq 1 ] ; then
+	echo "Test Failed for  multi-signature signing by $qmail_dkim + verification by $dkim DKIMSIGNEXTRA in dkimkeys"
+	exit 1
+elif [ $verbose -ne 0 ] ; then
+	echo "All Tests succeeded for  multi-signature signing by $qmail_dkim + verification by $dkim DKIMSIGNEXTRA in dkimkeys"
+fi
+
+echo "testing multi-signature signing+verification by qmail-dkim"
+failed=0
+key1=$domainkey_dir/%/default
+key2=$domainkey_dir/%/ed25519
+for i in example.com example.org
+do
+	(
+	echo "From: postmaster@$i"
+	echo "To: postmaster@$i"
+	echo "Subject: Test"
+	echo "Date: $(date -R)"
+	echo
+	echo "Test message"
+	) | env \
+		CONTROLDIR=/tmp/control \
+		DKIMSIGN="$key1" \
+		DKIMSIGNOPTIONS="-z 2" \
+		DKIMQUEUE=/bin/cat \
+		DKIMSIGNEXTRA="$key2" \
+		DKIMSIGNOPTIONSEXTRA="-z 4" \
+		ERR_FD=2 \
+		$qmail_dkim > /tmp/result.out
+	sig_count=$(grep DKIM-Signature /tmp/result.out|wc -l)
+	for j in default ed25519
+	do
+		if [ $verbose -gt 0 ] ; then
+			echo key $j domain $i
+		fi
+		selector=$(cat $domainkey_dir/$i/$j.pub |sed -e 's{.*({{' -e 's{).*{{' -e '/^$/d' -e 's{"{{g' -e 's{\t{{g' | tr -d '\n')
+		case $j in
+			default)
+			echo "  rsa+ed25519 with rsa-256 selector"
+			;;
+			ed25519)
+			echo "  rsa+ed25519 with ed25519 selector"
+			;;
+		esac
+		cat /tmp/result.out | env - \
+				DKIMVERIFY="" \
+				SELECTOR_DATA="$selector" \
+				DKIMQUEUE=/bin/cat \
+				VERBOSE=1 \
+				$qmail_dkim >$out 2>/tmp/err.out
+		ret=$?
+		grep Signature /tmp/err.out | sed -e 's{Signature #{    Signature{g' \
+			-e 's{01{ed25519{' -e 's{02{rsa-256{' -e 's{Failure.*{Failure - Correct{'
+		if [ $ret -eq 0 -a $sig_count -eq 2 ] ; then
+			if [ $verbose -gt 0 ] ; then
+				echo "SUCCESS: [ret=$ret] domain=$i sig_count=$sig_count env - DKIMSIGN=$key1 DKIMSIGNEXTRA=$key2... $qmail_dkim"
+				echo
+			fi
+			echo SUCCESS ======================== >$out
+		else
+			echo "FAILED : [ret=$ret] domain=$i sig_count=$sig_count env - DKIMSIGN=$key1 DKIMSIGNEXTRA=$key2... $qmail_dkim"
+			echo
+			echo FAILURE [$ret] ======================== >$out
+			echo >$out
+			failed=1
+		fi
+	done
+done
+
+if [ $verbose -eq 0 -a $failed -eq 0 ] ; then
+	echo "  Success"
+	echo
+fi
+if [ $failed -eq 1 ] ; then
+	echo "Test Failed for  multi-signature signing+verification by $qmail_dkim"
+	exit 1
+elif [ $verbose -ne 0 ] ; then
+	echo "All Tests succeeded for  multi-signature signing+verification by $qmail_dkim"
+fi
+
+echo "testing multi-signature signing+verification by dk-filter"
+failed=0
+key1=$domainkey_dir/%/default
+key2=$domainkey_dir/%/ed25519
+for i in example.com example.org
+do
+	(
+	echo "From: postmaster@$i"
+	echo "To: postmaster@$i"
+	echo "Subject: Test"
+	echo "Date: $(date -R)"
+	echo
+	echo "Test message"
+	) | env \
+		NODK="1" \
+		QMAILREMOTE="1" \
+  		_SENDER=postmaster@$i \
+		CONTROLDIR=/tmp \
+		DKIMSIGN="$key1" \
+		DKIMSIGNOPTIONS="-z 2" \
+		DKIMSIGNEXTRA="$key2" \
+		DKIMSIGNOPTIONSEXTRA="-z 4" $dk_filter > /tmp/result.out
+	sig_count=$(grep DKIM-Signature /tmp/result.out|wc -l)
+	for j in default ed25519
+	do
+		if [ $verbose -gt 0 ] ; then
+			echo key $j domain $i
+		fi
+		selector=$(cat $domainkey_dir/$i/$j.pub |sed -e 's{.*({{' -e 's{).*{{' -e '/^$/d' -e 's{"{{g' -e 's{\t{{g' | tr -d '\n')
+		case $j in
+			default)
+			echo "  rsa+ed25519 with rsa-256 selector"
+			;;
+			ed25519)
+			echo "  rsa+ed25519 with ed25519 selector"
+			;;
+		esac
+		cat /tmp/result.out | env - \
+			NODK="1" \
+			QMAILREMOTE="1" \
+			DKIMVERIFY="1" \
+			VERBOSE=1 \
+			SELECTOR_DATA="$selector" \
+		$dk_filter >$out 2>/tmp/err.out
+		ret=$?
+		grep Signature /tmp/err.out | sed -e 's{Signature #{    Signature{g' \
+			-e 's{01{rsa-256{' -e 's{02{ed25519{' -e 's{Failure.*{Failure - Correct{'
+		if [ $ret -eq 0 -a $sig_count -eq 2 ] ; then
+			if [ $verbose -gt 0 ] ; then
+				echo "SUCCESS: [ret=$ret] domain=$i sig_count=$sig_count env - DKIMSIGN=$key1 DKIMSIGNEXTRA=$key2... dk-filter"
+				echo
+			fi
+			echo SUCCESS ======================== >$out
+		else
+			echo "FAILED : [ret=$ret] domain=$i sig_count=$sig_count env - DKIMSIGN=$key1 DKIMSIGNEXTRA=$key2... dk-filter"
+			echo
+			echo FAILURE [$ret] ======================== >$out
+			echo >$out
+			failed=1
+		fi
+	done
+	/bin/rm -f /tmp/result.out
+done
+
+if [ $verbose -eq 0 -a $failed -eq 0 ] ; then
+	echo "  Success"
+	echo
+fi
+if [ $failed -eq 1 ] ; then
+	echo "Test Failed for  multi-signature signing+verification by dk-filter"
+	exit 1
+elif [ $verbose -ne 0 ] ; then
+	echo "All Tests succeeded for  multi-signature signing+verification by dk-filter"
+fi
+
+echo "testing qmail-dkim signing+verification by qmail-dkim"
+failed=0
+for i in $domainkey_dir/test $domainkey_dir/%/default $domainkey_dir/%/test $domainkey_dir/%/ed25519
+do
+	for j in example.com example.org
+	do
+		selector=""
+		if [ "$i" = "$domainkey_dir/test" -a -f $i.pub ] ; then
+			selector=$(cat $i.pub |sed -e 's{.*({{' -e 's{).*{{' -e '/^$/d' -e 's{"{{g' -e 's{\t{{g' | tr -d '\n')
+		fi
+		if [ -z "$selector" ] ; then
+			case $i in
+			$domainkey_dir/%/default)
+			enc="-z 2"
+			if [ -f $domainkey_dir/$j/default.pub ] ; then
+				selector=$(cat $domainkey_dir/$j/default.pub |sed -e 's{.*({{' -e 's{).*{{' -e '/^$/d' -e 's{"{{g' -e 's{\t{{g' | tr -d '\n')
+			elif [ -f $domainkey_dir/default.pub ] ; then
+				selector=$(cat $domainkey_dir/default.pub |sed -e 's{.*({{' -e 's{).*{{' -e '/^$/d' -e 's{"{{g' -e 's{\t{{g' | tr -d '\n')
+			fi
+			;;
+			$domainkey_dir/%/test)
+			enc="-z 2"
+			if [ -f $domainkey_dir/$j/test.pub ] ; then
+				selector=$(cat $domainkey_dir/$j/test.pub |sed -e 's{.*({{' -e 's{).*{{' -e '/^$/d' -e 's{"{{g' -e 's{\t{{g' | tr -d '\n')
+			elif [ -f $domainkey_dir/test.pub ] ; then
+				selector=$(cat $domainkey_dir/test.pub |sed -e 's{.*({{' -e 's{).*{{' -e '/^$/d' -e 's{"{{g' -e 's{\t{{g' | tr -d '\n')
+			fi
+			;;
+			$domainkey_dir/%/ed25519)
+			enc="-z 4"
+			if [ -f $domainkey_dir/$j/ed25519.pub ] ; then
+				selector=$(cat $domainkey_dir/$j/ed25519.pub |sed -e 's{.*({{' -e 's{).*{{' -e '/^$/d' -e 's{"{{g' -e 's{\t{{g' | tr -d '\n')
+			elif [ -f $domainkey_dir/ed25519.pub ] ; then
+				selector=$(cat $domainkey_dir/ed25519.pub |sed -e 's{.*({{' -e 's{).*{{' -e '/^$/d' -e 's{"{{g' -e 's{\t{{g' | tr -d '\n')
+			fi
+			;;
+			esac
+		fi
+		if [ $verbose -gt 0 ] ; then
+			echo key=$i domain=$j
+		fi
+		(
+		echo "From: postmaster@$j"
+		echo "To: postmaster@$j"
+		echo "Subject: Test"
+		echo "Date: $(date -R)"
+		echo
+		echo "Test message"
+		) | env - \
+			CONTROLDIR=/tmp/control \
+			DKIMSIGN="$i" \
+			DKIMSIGNOPTIONS="$enc" \
+			DKIMQUEUE=/bin/cat \
+			$qmail_dkim | env - \
+				DKIMVERIFY="" \
+				SELECTOR_DATA="$selector" \
+				DKIMQUEUE=/bin/cat \
+				$qmail_dkim > $out
+		ret=$?
+		if [ $ret -eq 0 ] ; then
+			if [ $verbose -gt 0 ] ; then
+				echo "SUCCESS: [ret=$ret]  env - DKIMSIGN=$i DKIMQUEUE=/bin/cat $qmail_dkim"
+				echo
+			fi
+			echo SUCCESS ======================== >$out
+		else
+			echo "FAILED : [ret=$ret] domain=$j key=$i env - DKIMSIGN=$i DKIMQUEUE=/bin/cat $qmail_dkim"
+			echo
+			echo FAILURE [$ret] domain=$j ======================== >$out
+			echo >$out
+			failed=1
+		fi
+	done
+done
+
+for i in $domainkey_dir/%/notexist $domainkey_dir/%
+do
+	for j in example.com example.org
+	do
+		if [ $verbose -gt 0 ] ; then
+			echo key=$i domain=$j
+		fi
+		(
+		echo "From: postmaster@$j"
+		echo "To: postmaster@$j"
+		echo "Subject: Test"
+		echo "Date: $(date -R)"
+		echo
+		echo "Test message"
+		) | env - \
+			CONTROLDIR=/tmp/control \
+			DKIMSIGN="$i" \
+			DKIMQUEUE=/bin/cat \
+			$qmail_dkim >$out
+		ret=$?
+		if [ $ret -eq 0 ] ; then
+			if [ $verbose -gt 0 ] ; then
+				echo "SUCCESS: [ret=$ret]  env - DKIMSIGN=$i DKIMQUEUE=/bin/cat $qmail_dkim"
+				echo
+			fi
+			echo SUCCESS ======================== >$out
+		else
+			echo "FAILED : [ret=$ret] domain=$j key=$i env - DKIMSIGN=$i DKIMQUEUE=/bin/cat $qmail_dkim"
+			echo
+			echo FAILURE [$ret] domain=$j ======================== >$out
+			echo >$out
+			failed=1
+		fi
+	done
+done
+
+for i in $domainkey_dir/notexist
+do
+	for j in example.com example.org
+	do
+		if [ $verbose -gt 0 ] ; then
+			echo key $i domain $j
+		fi
+		(
+		echo "From: postmaster@$j"
+		echo "To: postmaster@$j"
+		echo "Subject: Test"
+		echo "Date: $(date -R)"
+		echo
+		echo "Test message"
+		) | env - \
+			CONTROLDIR=/tmp/control \
+			DKIMSIGN="$i" \
+			DKIMQUEUE=/bin/cat \
+			ERROR_FD=2 \
+			$qmail_dkim >$out 2>&1
+		ret=$?
+		if [ $ret -eq 0 ] ; then
+			echo "FAILED : [ret=$ret] domain=$j key=$i env - DKIMSIGN=$i DKIMQUEUE=/bin/cat $qmail_dkim"
+			echo
+			echo FAILURE [$ret] domain=$j ======================== > $out
+			echo >$out
+			failed=1
+		else
+			if [ $ret -ne $nokeyerror -a $ret -ne 88 ] ; then
+				echo "FAILED : [ret=$ret] domain=$j key=$i env - DKIMSIGN=$i DKIMQUEUE=/bin/cat $dkim"
+				echo
+				echo FAILURE [$ret] domain=$j ======================== > $out
+				echo >$out
+				failed=1
+			else
+				if [ $verbose -gt 0 ] ; then
+					echo "SUCCESS: [ret=$ret] env - DKIMSIGN=$i DKIMQUEUE=/bin/cat $dkim"
+				fi
+				echo SUCCESS ======================== >$out
+			fi
+		fi
+	done
+done
+
+if [ $verbose -eq 0 -a $failed -eq 0 ] ; then
+	echo "  Success"
+	echo
+fi
+if [ $failed -eq 1 ] ; then
+	echo "Test failed for $qmail_dkim signing+verification by $qmail_dkim"
+	exit 1
+elif [ $verbose -ne 0 ] ; then
+	echo "All Tests succeeded for $qmail_dkim signing+verification by $qmail_dkim"
+fi
+
+echo "testing dk-filter signing"
+failed=0
+for i in $domainkey_dir/test $domainkey_dir/%/default $domainkey_dir/%/test $domainkey_dir/%/notexist $domainkey_dir/%
+do
+	for j in example.com example.org
+	do
+		if [ $verbose -gt 0 ] ; then
+			echo key $i domain $j
+		fi
+		(
+		echo "From: postmaster@$j"
+		echo "To: postmaster@$j"
+		echo "Subject: Test"
+		echo "Date: $(date -R)"
+		echo
+		echo "Test message"
+		) | env - \
+			NODK="1" \
+			QMAILREMOTE="1" \
+			CONTROLDIR=/tmp/control \
+  			_SENDER=postmaster@$j \
+  			DKIMSIGN=$i \
+  			$dk_filter > $out
+		ret=$?
+		if [ $ret -eq 0 ] ; then
+			if [ $verbose -gt 0 ] ; then
+				echo "SUCCESS: [ret=$ret]  env - NODK=1 QMAILREMOTE=1 _SENDER=postmaster@$j DKIMSIGN=$i DKIMQUEUE=/bin/cat $dk_filter"
+			fi
+			echo SUCCESS ======================== >$out
+		else
+			echo "FAILED : [ret=$ret] domain=$j key=$i env - NODK=1 QMAILREMOTE=1 _SENDER=postmaster@$j DKIMSIGN=$i DKIMQUEUE=/bin/cat $dk_filter"
+			echo
+			echo FAILURE [$ret] domain=$j ======================== >$out
+			echo >$out
+			failed=1
+		fi
+	done
+done
+
+for i in $domainkey_dir/notexist
+do
+	for j in example.com example.org
+	do
+		if [ $verbose -gt 0 ] ; then
+			echo key $i domain $j
+		fi
+		(
+		echo "From: postmaster@$j"
+		echo "To: postmaster@$j"
+		echo "Subject: Test"
+		echo "Date: $(date -R)"
+		echo
+		echo "Test message"
+		) | env - \
+			NODK="1" \
+			QMAILREMOTE="1" \
+			CONTROLDIR=/tmp/control \
+	  		_SENDER=postmaster@$j \
+			DKIMSIGN="$i" \
+			DKIMQUEUE=/bin/cat $dk_filter > $out 2>&1
+		ret=$?
+		if [ $ret -eq 0 ] ; then
+			echo SUCCESS ======================== > $out
+		else
+			if [ $ret -ne $nokeyerror -a $ret -ne 88 ] ; then
+				echo "FAILED : [ret=$ret] domain=$j key=$i env - NODK=1 QMAILREMOTE=1 _SENDER=postmaster@$j DKIMSIGN=$i DKIMQUEUE=/bin/cat $dk_filter"
+				echo
+				echo FAILURE [$ret] domain=$j ======================== > $out
+				echo >$out
+				failed=1
+			else
+				if [ $verbose -gt 0 ] ; then
+					echo "SUCCESS: [ret=$ret] env - NODK=1 QMAILREMOTE=1 _SENDER=postmaster@$j DKIMSIGN=$i DKIMQUEUE=/bin/cat $dk_filter"
+				fi
+			fi
+		fi
+	done
+done
+
+if [ $verbose -eq 0 -a $failed -eq 0 ] ; then
+	echo "  Success"
+	echo
+fi
+if [ $failed -eq 1 ] ; then
+	echo "Test Failed for dk-filter signing"
+	exit 1
+elif [ $verbose -ne 0 ] ; then
+	echo "All Tests succeeded for dk-filter signing"
+fi
+
+echo "testing dk-filter signing+verification by dk-filter"
+failed=0
+for i in default ed25519
+do
+	for j in example.com example.org
+	do
+		if [ $verbose -gt 0 ] ; then
+			echo key $i domain $j
+		fi
+		case $i in 
+			default)
+				enc="-z 2"
+				;;
+			ed25519)
+				enc="-z 4"
+				;;
+		esac
+		selector=$(cat $domainkey_dir/$j/$i.pub |sed -e 's{.*({{' -e 's{).*{{' -e '/^$/d' -e 's{"{{g' -e 's{\t{{g' | tr -d '\n')
+		(
+		echo "From: postmaster@$j"
+		echo "To: postmaster@$j"
+		echo "Subject: Test"
+		echo "Date: $(date -R)"
+		echo
+		echo "Test message"
+		) | env - \
+			NODK="1" \
+			QMAILREMOTE="1" \
+			CONTROLDIR=/tmp/control \
+  			_SENDER=postmaster@$j \
+  			DKIMSIGN="$domainkey_dir/%/$i" \
+			DKIMSIGNOPTIONS="$enc" \
+  			$dk_filter | env - \
+			NODK="1" \
+			QMAILREMOTE="1" \
+			DKIMVERIFY="1" \
+			SELECTOR_DATA="$selector" \
+		$dk_filter > $out
+		ret=$?
+		if [ $ret -eq 0 ] ; then
+			if [ $verbose -gt 0 ] ; then
+				echo "SUCCESS: [ret=$ret]  env - NODK=1 QMAILREMOTE=1 _SENDER=postmaster@$j DKIMSIGN=$i DKIMQUEUE=/bin/cat $dk_filter"
+			fi
+			echo SUCCESS ======================== >$out
+		else
+			echo "FAILED : [ret=$ret] domain=$j key=$i env - NODK=1 QMAILREMOTE=1 _SENDER=postmaster@$j DKIMSIGN=$i DKIMQUEUE=/bin/cat $dk_filter"
+			echo
+			echo FAILURE [$ret] domain=$j ======================== >$out
+			echo >$out
+			failed=1
+		fi
+	done
+done
+
+if [ $verbose -eq 0 -a $failed -eq 0 ] ; then
+	echo "  Success"
+	echo
+fi
+if [ $failed -eq 1 ] ; then
+	echo "Test Failed for dk-filter signing+verification by dk-filter"
+	exit 1
+elif [ $verbose -ne 0 ] ; then
+	echo "All Tests succeeded for dk-filter signing+verification by dk-filter"
+fi
+
+echo "testing dkimkeys control file feature"
+failed=0
+if [ ! -d /tmp/control ] ; then
+	mkdir -p /tmp/control
+fi
+
+(
+echo "ex*.com:/tmp/domainkeys/%/dkimkeys1"
+echo "ex.*.org:/tmp/domainkeys/%/dkimkeys2:QREGEX=1,DKIMSIGNOPTIONS=-z 4"
+) >/tmp/control/dkimkeys
+for i in example.com example.org
+do
+	if [ $verbose -gt 0 ] ; then
+		echo domain $i
+	fi
+	if [ "$i" = "example.com" ] ; then
+		selector=$(cat $domainkey_dir/$i/dkimkeys1.pub |sed -e 's{.*({{' -e 's{).*{{' -e '/^$/d' -e 's{"{{g' -e 's{\t{{g' | tr -d '\n')
+	else
+		selector=$(cat $domainkey_dir/$i/dkimkeys2.pub |sed -e 's{.*({{' -e 's{).*{{' -e '/^$/d' -e 's{"{{g' -e 's{\t{{g' | tr -d '\n')
+	fi
+	(
+	echo "From: postmaster@$i"
+	echo "To: postmaster@$i"
+	echo "Subject: Test"
+	echo "Date: $(date -R)"
+	echo
+	echo "Test message"
+	) | env -  \
+		DKIMSIGN="" \
+		CONTROLDIR=/tmp/control \
+		DKIMQUEUE=/bin/cat \
+		ERROR_FD=2 \
+		$qmail_dkim | $dkim -v -T "$selector" > $out
+	ret=$?
+	if [ $ret -eq 0 ] ; then
+		if [ $verbose -gt 0 ] ; then
+			echo "SUCCESS: [ret=$ret]  dkimkeys"
+			echo
+		fi
+		echo SUCCESS ======================== >$out
+	else
+	(
+	echo "From: postmaster@$i"
+	echo "To: postmaster@$i"
+	echo "Subject: Test"
+	echo "Date: $(date -R)"
+	echo
+	echo "Test message"
+	) >/tmp/mail.txt
+		echo "FAILED : [ret=$ret] domain=$i dkimkeys"
+		echo
+		echo FAILURE [$ret] domain=$i ======================== >$out
+		echo >$out
+		failed=1
+	fi
+done
+
+(
+echo "ex*.com:/tmp/domainkeys/notexists"
+echo "ex*.org:/tmp/domainkeys/notexists:QREGEX=1"
+) >/tmp/control/dkimkeys
+for i in example.com example.org
+do
+	if [ $verbose -gt 0 ] ; then
+		echo domain $i
+	fi
+	(
+	echo "From: postmaster@$i"
+	echo "To: postmaster@$i"
+	echo "Subject: Test"
+	echo "Date: $(date -R)"
+	echo
+	echo "Test message"
+	) | env -  \
+		DKIMSIGN="" \
+		CONTROLDIR=/tmp/control \
+		DKIMQUEUE=/bin/cat \
+		ERROR_FD=2 \
+		$qmail_dkim > $out 2>&1
+	ret=$?
+	if [ $ret -eq 0 ] ; then
+		echo "FAILED : [ret=$ret] domain=$i key=dkimkeys"
+		echo
+		echo FAILURE [$ret] domain=$j ======================== > $out
+		echo >$out
+		failed=1
+	else
+		if [ $ret -ne $nokeyerror -a $ret -ne 88 ] ; then
+			echo "FAILED : [ret=$ret] domain=$i key=dkimkeys"
+			echo
+			echo FAILURE [$ret] domain=$j ======================== > $out
+			echo >$out
+			failed=1
+		else
+			if [ $verbose -gt 0 ] ; then
+				echo "SUCCESS: [ret=$ret] dkimkeys"
+			fi
+			echo SUCCESS ======================== >$out
+		fi
+	fi
+done
+
+if [ $verbose -eq 0 -a $failed -eq 0 ] ; then
+	echo "  Success"
+	echo
+fi
+if [ $failed -eq 1 ] ; then
+	echo "Test Failed for dkimkeys"
+	exit 1
+elif [ $verbose -ne 0 ] ; then
+	echo "All Tests succeeded for dkimkeys"
+fi
+
+echo "testing multi-signature signing+verification by dk-filter DKIMSIGNEXTRA in dkimkeys"
+(
+echo "ex*.com:/tmp/domainkeys/%/dkimkeys1:DKIMSIGNEXTRA=/tmp/domainkeys/%/dkimkeys2,DKIMSIGNOPTIONSEXTRA=-z 4"
+echo "ex.*.org:/tmp/domainkeys/%/dkimkeys1:QREGEX=1,DKIMSIGNEXTRA=/tmp/domainkeys/%/dkimkeys2,DKIMSIGNOPTIONSEXTRA=-z 4"
+) >/tmp/control/dkimkeys
+
+failed=0
+for i in example.com example.org
+do
+	(
+	echo "From: postmaster@$i"
+	echo "To: postmaster@$i"
+	echo "Subject: Test"
+	echo "Date: $(date -R)"
+	echo
+	echo "Test message"
+	) | env \
+		NODK="1" \
+		QMAILREMOTE="1" \
+  		_SENDER=postmaster@$i \
+		CONTROLDIR=/tmp/control \
+		DKIMSIGN="" \
+		DKIMSIGNOPTIONS="-z 2" \
+		$dk_filter > /tmp/result.out
+	sig_count=$(grep DKIM-Signature /tmp/result.out|wc -l)
+	for j in dkimkeys1 dkimkeys2
+	do
+		if [ $verbose -gt 0 ] ; then
+			echo key $j domain $i
+		fi
+		selector=$(cat $domainkey_dir/$i/$j.pub |sed -e 's{.*({{' -e 's{).*{{' -e '/^$/d' -e 's{"{{g' -e 's{\t{{g' | tr -d '\n')
+		case $j in
+			dkimkeys1)
+			echo "  rsa+ed25519 with rsa-256 selector"
+			;;
+			dkimkeys2)
+			echo "  rsa+ed25519 with ed25519 selector"
+			;;
+		esac
+		cat /tmp/result.out | env - \
+			NODK="1" \
+			QMAILREMOTE="1" \
+			DKIMVERIFY="1" \
+			VERBOSE=1 \
+			SELECTOR_DATA="$selector" \
+		$dk_filter >$out 2>/tmp/err.out
+		ret=$?
+		grep Signature /tmp/err.out | sed -e 's{Signature #{    Signature{g' \
+			-e 's{01{rsa-256{' -e 's{02{ed25519{' -e 's{Failure.*{Failure - Correct{'
+		if [ $ret -eq 0 -a $sig_count -eq 2 ] ; then
+			if [ $verbose -gt 0 ] ; then
+				echo "SUCCESS: [ret=$ret] domain=$i sig_count=$sig_count ... dk-filter"
+				echo
+			fi
+			echo SUCCESS ======================== >$out
+		else
+			echo "FAILED : [ret=$ret] domain=$i sig_count=$sig_count ... dk-filter"
+			echo
+			echo FAILURE [$ret] ======================== >$out
+			echo >$out
+			failed=1
+		fi
+	done
+	/bin/rm -f /tmp/result.out
+done
+key1=$domainkey_dir/example.com/dkimkeys1
+qmail_inject=$bindir/qmail-inject
+qmail_queue=$sbindir/qmail-queue
+echo "testing qmail-dkim custom error feature"
+(
+	echo "From: postmaster@$real_domain"
+	echo "To: $user@$real_domain"
+	echo "Subject: Test"
+	echo "Date: $(date -R)"
+	echo
+	echo "Test message"
+) > /tmp/mail.txt 
+for i in PQ pq
+do
+	echo "  testing return value  for DKIMVERIFY=$i"
+	(cat /tmp/mail.txt | $bindir/dkim -z 2 -s $key1; cat /tmp/mail.txt) | env - \
+		QUEUEDIR=/var/indimail/queue/queue1 \
+		CONFSPLIT=23 \
+		BIGTODO=0 \
+		DKIMVERIFY="$i" \
+		QMAILQUEUE=$qmail_dkim \
+		FASTQUEUE=1 \
+		ERROR_FD=2 \
+		$qmail_inject -a $user 2>/tmp/out.$$
+	ret=$?
+	echo "    return value=$ret"
+	case $i in
+		PQ)
+		if [ $ret -eq 100 ] ; then
+			if [ $verbose -gt 0 ] ; then
+				echo "SUCCESS: [ret=$ret] DKIMVERIFY=$i qmail-dkim custom error"
+				echo
+			fi
+			echo SUCCESS ======================== >$out
+		else
+			failed=1
+			echo "FAILED : [ret=$ret] DKIMVERIFY=$i qmail-dkim custom error"
+			echo
+			echo FAILURE [$ret] ======================== >$out
+			echo >>$out
+		fi
+		echo "  testing error message for DKIMVERIFY=$i"
+		echo "    error message=$(cat /tmp/out.$$)"
+		grep "qmail-inject: fatal: qmail-dkim: signature error: permanent dns failure requesting selector (#5.7.0)" /tmp/out.$$ > /dev/null
+		if [ $? -eq 0 ] ; then
+			if [ $verbose -gt 0 ] ; then
+				echo "SUCCESS: [ret=$ret] DKIMVERIFY=$i qmail-dkim custom error message"
+				echo
+			fi
+			echo SUCCESS ======================== >$out
+		else
+			failed=1
+			echo "FAILED : [ret=$ret] DKIMVERIFY=$i qmail-dkim custom error message"
+			echo
+			echo FAILURE [$ret] ======================== >$out
+			echo >>$out
+		fi
+		;;
+		pq)
+		if [ $ret -eq 111 ] ; then
+			if [ $verbose -gt 0 ] ; then
+				echo "SUCCESS: [ret=$ret] DKIMVERIFY=$i qmail-dkim custom error"
+				echo
+			fi
+			echo SUCCESS ======================== >$out
+		else
+			failed=1
+			echo "FAILED : [ret=$ret] DKIMVERIFY=$i qmail-dkim custom error"
+			echo
+			echo FAILURE [$ret] ======================== >$out
+			echo >>$out
+		fi
+		echo "  testing error message for DKIMVERIFY=$i"
+		echo "    error message=$(cat /tmp/out.$$)"
+		grep "qmail-inject: fatal: qmail-dkim: signature error: permanent dns failure requesting selector (#4.7.0)" /tmp/out.$$ > /dev/null
+		if [ $? -eq 0 ] ; then
+			if [ $verbose -gt 0 ] ; then
+				echo "SUCCESS: [ret=$ret] DKIMVERIFY=$i qmail-dkim custom error message"
+				echo
+			fi
+			echo SUCCESS ======================== >$out
+		else
+			failed=1
+			echo "FAILED : [ret=$ret] DKIMVERIFY=$i qmail-dkim custom error message"
+			echo
+			echo FAILURE [$ret] ======================== >$out
+			echo >>$out
+		fi
+		;;
+	esac
+done
+/bin/rm -f /tmp/mail.txt /tmp/out.$$
+if [ $failed -eq 1 ] ; then
+	echo "Test Failed for qmail-dkim custom error"
+	exit 1
+elif [ $verbose -ne 0 ] ; then
+	echo "Test succeeded for qmail-dkim custom error"
+fi
+
+/bin/rm -f /tmp/control/dkimkeys
+
+if [ $verbose -eq 0 -a $failed -eq 0 ] ; then
+	echo "  Success"
+	echo
+fi
+if [ $failed -eq 1 ] ; then
+	echo "Test Failed for  multi-signature signing+verification by dk-filter DKIMSIGNEXTRA in dkimkeys"
+	exit 1
+elif [ $verbose -ne 0 ] ; then
+	echo "All Tests succeeded for  multi-signature signing+verification by dk-filter DKIMSIGNEXTRA in dkimkeys"
+fi
+
+#sudo /bin/rm -f /tmp/domainkeys
+echo "All Tests succeeded"
+exit 0
diff -Naur netqmail-1.06.org/time_t_size.c netqmail-1.06/time_t_size.c
--- netqmail-1.06.org/time_t_size.c	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/time_t_size.c	2022-12-09 22:58:50.000000000 +0530
@@ -0,0 +1,8 @@
+#include <stdio.h>
+#include <time.h>
+int
+main()
+{
+	printf("#define SIZEOF_TIME_T %d\n", sizeof(time_t));
+	return (0);
+}
diff -Naur netqmail-1.06.org/tryulong64.c netqmail-1.06/tryulong64.c
--- netqmail-1.06.org/tryulong64.c	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/tryulong64.c	2022-12-09 22:58:50.000000000 +0530
@@ -0,0 +1,47 @@
+/*
+ * $Log: tryulong64.c,v $
+ * Revision 1.1  2004-05-14 00:45:23+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
+void
+main()
+{
+	unsigned long   u;
+	u = 1;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	if (!u)
+		_exit(1);
+	_exit(0);
+}
diff -Naur netqmail-1.06.org/uint64.h1 netqmail-1.06/uint64.h1
--- netqmail-1.06.org/uint64.h1	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/uint64.h1	2022-12-09 22:58:50.000000000 +0530
@@ -0,0 +1,12 @@
+/*
+ * $Log: uint64.h1,v $
+ * Revision 1.1  2004-10-22 15:00:08+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
+#ifndef UINT64_H
+#define UINT64_H
+
+typedef unsigned long uint64;
+
+#endif
diff -Naur netqmail-1.06.org/uint64.h2 netqmail-1.06/uint64.h2
--- netqmail-1.06.org/uint64.h2	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/uint64.h2	2022-12-09 22:58:50.000000000 +0530
@@ -0,0 +1,12 @@
+/*
+ * $Log: uint64.h2,v $
+ * Revision 1.1  2004-10-22 15:00:36+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
+#ifndef UINT64_H
+#define UINT64_H
+
+typedef unsigned long long uint64;
+
+#endif
diff -Naur netqmail-1.06.org/wildmat.c netqmail-1.06/wildmat.c
--- netqmail-1.06.org/wildmat.c	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/wildmat.c	2022-12-09 22:58:50.000000000 +0530
@@ -0,0 +1,173 @@
+/*-** wildmat.c.orig	Wed Dec  3 11:46:31 1997
+ * $Revision: 1.6 $
+ * Do shell-style pattern matching for ?, \, [], and * characters.
+ * Might not be robust in face of malformed patterns; e.g., "foo[a-"
+ * could cause a segmentation violation.  It is 8bit clean.
+ * 
+ * Written by Rich $alz, mirror!rs, Wed Nov 26 19:03:17 EST 1986.
+ * Rich $alz is now <rsalz@osf.org>.
+ * April, 1991:  Replaced mutually-recursive calls with in-line code
+ * for the star character.
+ *
+ * Special thanks to Lars Mathiesen <thorinn@diku.dk> for the ABORT code.
+ * This can greatly speed up failing wildcard patterns.  For example:
+ * pattern: -*-*-*-*-*-*-12-*-*-*-m-*-*-*
+ * text 1:  -adobe-courier-bold-o-normal--12-120-75-75-m-70-iso8859-1
+ * text 2:  -adobe-courier-bold-o-normal--12-120-75-75-X-70-iso8859-1
+ * Text 1 matches with 51 calls, while text 2 fails with 54 calls.  Without
+ * the ABORT code, it takes 22310 calls to fail.  Ugh.  The following
+ * explanation is from Lars:
+ * The precondition that must be fulfilled is that DoMatch will consume
+ * at least one character in text.  This is true if *p is neither '*' no
+ * '\0'.)  The last return has ABORT instead of FALSE to avoid quadratic
+ * behaviour in cases like pattern "*a*b*c*d" with text "abcxxxxx".  With
+ * FALSE, each star-loop has to run to the end of the text; with ABORT
+ * only the last one does.
+ * 
+ * Once the control of one instance of DoMatch enters the star-loop, that
+ * instance will return either TRUE or ABORT, and any calling instance
+ * will therefore return immediately after (without calling recursively
+ * again).  In effect, only one star-loop is ever active.  It would be
+ * possible to modify the code to maintain this context explicitly,
+ * eliminating all recursive calls at the cost of some complication and
+ * loss of clarity (and the ABORT stuff seems to be unclear enough by
+ * itself).  I think it would be unwise to try to get this into a
+ * released version unless you have a good test data base to try it out
+ * on.
+ */
+#define TRUE			 1
+#define FALSE			 0
+#define ABORT			-1
+
+
+/*- What character marks an inverted character class?  */
+#define NEGATE_CLASS		'^'
+/*- Is "*" a common pattern?  */
+#define OPTIMIZE_JUST_STAR
+/*- Do tar(1) matching rules, which ignore a trailing slash?  */
+#undef MATCH_TAR_PATTERN
+
+
+/*- Match text and p, return TRUE, FALSE, or ABORT.  */
+static int
+DoMatch(text, p)
+	register char  *text;
+	register char  *p;
+{
+	register int    last;
+	register int    matched;
+	register int    reverse;
+
+	for (; *p; text++, p++)
+	{
+		if (*text == '\0' && *p != '*')
+			return ABORT;
+		switch (*p)
+		{
+		case '\\': /*- Literal match with following character.  */
+			p++;
+			/*- FALLTHROUGH */
+		default:
+			if (*text != *p)
+				return FALSE;
+			continue;
+		case '?': /*- Match anything. */
+			continue;
+		case '*':
+			/*- Consecutive stars act just like one.  */
+			while (*++p == '*')
+				continue;
+			/*- Trailing star matches everything.  */
+			if (*p == '\0')
+				return TRUE;
+			while (*text)
+				if ((matched = DoMatch(text++, p)) != FALSE)
+					return matched;
+			return ABORT;
+		case '[':
+			reverse = p[1] == NEGATE_CLASS ? TRUE : FALSE;
+			/*- Inverted character class.  */
+			if (reverse)
+				p++;
+			matched = FALSE;
+			if (p[1] == ']' || p[1] == '-')
+			{
+				if (*++p == *text)
+					matched = TRUE;
+			}
+			for (last = *p; *++p && *p != ']'; last = *p)
+			{
+				/*- This next line requires a good C compiler.  */
+				if (*p == '-' && p[1] != ']' ? *text <= *++p && *text >= last : *text == *p)
+					matched = TRUE;
+			}
+			if (matched == reverse)
+				return FALSE;
+			continue;
+		}
+	}
+
+#ifdef	MATCH_TAR_PATTERN
+	if (*text == '/')
+		return TRUE;
+#endif /*- MATCH_TAR_ATTERN */
+	return *text == '\0';
+}
+
+
+/*- User-level routine.  Returns TRUE or FALSE.  */
+int
+wildmat_internal(text, p)
+	char           *text;
+	char           *p;
+{
+#ifdef	OPTIMIZE_JUST_STAR
+	if (p[0] == '*' && p[1] == '\0')
+		return TRUE;
+#endif /*- OPTIMIZE_JUST_STAR */
+	return DoMatch(text, p) == TRUE;
+}
+
+#if	defined(TEST)
+include < stdio.h >
+/*- Yes, we use gets not fgets.  Sue me.  */
+
+int
+main()
+{
+	char            p[80];
+	char            text[80];
+
+	printf("Wildmat tester.  Enter pattern, then strings to test.\n");
+	printf("A blank line gets prompts for a new pattern; a blank pattern\n");
+	printf("exits the program.\n");
+	for (;;)
+	{
+		printf("\nEnter pattern:  ");
+		(void) fflush(stdout);
+		if (gets(p) == NULL || p[0] == '\0')
+			break;
+		for (;;)
+		{
+			printf("Enter text:  ");
+			(void) fflush(stdout);
+			if (gets(text) == NULL)
+				exit(0);
+			/*- Blank line; go back and get a new pattern.  */
+			if (text[0] == '\0')
+				break;
+			printf("      %s\n", wildmat_internal(text, p) ? "YES" : "NO");
+		}
+	}
+	exit(0);
+	/*- NOTREACHED */
+}
+#endif /*- defined(TEST) */
+
+void
+getversion_wildmat_internal_c()
+{
+	static char    *x = "$Id: wildmat.c,v 1.6 2008-08-03 18:26:33+05:30 Cprogrammer Stab mbhangui $";
+	x++;
+	x--;
+}
diff -Naur netqmail-1.06.org/wildmat.h netqmail-1.06/wildmat.h
--- netqmail-1.06.org/wildmat.h	1970-01-01 05:30:00.000000000 +0530
+++ netqmail-1.06/wildmat.h	2022-12-09 22:58:50.000000000 +0530
@@ -0,0 +1,33 @@
+/*
+ * $Log: wildmat.h,v $
+ * Revision 1.1  2021-05-23 06:35:07+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
+#ifndef _WILDMAT_H
+#define _WILDMAT_H
+
+#ifndef	lint
+static char     sccsidwildmath[] = "$Id: wildmat.h,v 1.1 2021-05-23 06:35:07+05:30 Cprogrammer Exp mbhangui $";
+#endif
+
+#ifndef TRUE
+#define TRUE			 1
+#endif
+#ifndef FALSE
+#define FALSE			 0
+#endif
+#ifndef ABORT
+#define ABORT			-1
+#endif
+
+/*- What character marks an inverted character class?  */
+#define NEGATE_CLASS		'^'
+/*- Is "*" a common pattern?  */
+#define OPTIMIZE_JUST_STAR
+/*- Do tar(1) matching rules, which ignore a trailing slash?  */
+#undef MATCH_TAR_PATTERN
+
+int             wildmat_internal(char *, char *);
+
+#endif
